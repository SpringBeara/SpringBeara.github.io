<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>随机算法</title>
    <link href="/2023/11/28/RandomisedAlgorithm/"/>
    <url>/2023/11/28/RandomisedAlgorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="RandomisedAlgorithm"><a href="#RandomisedAlgorithm" class="headerlink" title="RandomisedAlgorithm"></a>RandomisedAlgorithm</h1><blockquote><p>算法执行过程中面临选择时，随机选择比最优选择更省时，因此随机算法可以很大程度上降低算法的复杂度。主要分为四种随机算法：</p><ul><li>数据概率算法：用于数值问题的求解，随着算法执行时间延长，其得到的近似解的结果与真实结果越相近。</li><li>Las Vegas算法：一旦找到解，解一定正确，但有限度，一旦超过限度，则说明无法找到解，算法失败。</li><li>Monte Carlo算法：一定能找到解，但解不一定正确，执行时间越久，解正确的概率越大。</li><li>Sherwood算法：一定能找到正确的解，用于某确定性算法最坏时间复杂度与平均时间复杂度相差较大的情况，通过降低特定用例与最坏行为之间的关联度来完成优化，比如快速排序中，基准元素选择随机元素。</li></ul></blockquote><h2 id="MonteCarlo"><a href="#MonteCarlo" class="headerlink" title="MonteCarlo"></a>MonteCarlo</h2><blockquote><p>用蒙特卡洛算法求π 设有一个边长为2的正方形，正方形内有一个内切圆，则他们的面积比为4:π. 设有一个随机点，x y随机取到[0,1](只考虑第一象限)</p><p>则x y落在圆内的次数 : x y生成的总次数(足够多),就近似于4:π，设x y总生成次数为n 落在圆内次数为m 则m&#x2F;n&#x3D;4&#x2F;π 因此：π&#x3D;4m&#x2F;n.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randa</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>() % (b - a + <span class="hljs-number">1</span>) + a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">randa01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">randa</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) * <span class="hljs-number">1.0</span> / <span class="hljs-number">100</span>;<span class="hljs-comment">//1.0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">approximatePI</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<span class="hljs-comment">//double xy!!</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>x = <span class="hljs-built_in">randa01</span>(); y = <span class="hljs-built_in">randa01</span>();<br><span class="hljs-keyword">if</span> (x * x + y * y &lt;= <span class="hljs-number">1.0</span>)<br>m++;<br>&#125;<br><span class="hljs-keyword">return</span>  <span class="hljs-number">4.0</span>* m / n;<span class="hljs-comment">//4.0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<span class="hljs-comment">//很重要！随机种子</span><br>cout&lt;&lt; <span class="hljs-built_in">approximatePI</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Las-Vegas"><a href="#Las-Vegas" class="headerlink" title="Las Vegas"></a>Las Vegas</h2><blockquote><p>用拉斯维加斯算法求N皇后问题的一个解，对于每个皇后的纵坐标，都用随机数来试探，直到试探出一组随机数使得条件成立，一旦成立就说明找到了解，否则说明没有找到，很符合Las Vegas算法，而且尝试的次数越多，越容易找到解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> q[MAX];<br><span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randa</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>() % (b - a + <span class="hljs-number">1</span>) + a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; times &lt;&lt; <span class="hljs-string">&quot;次运行找到结果:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (j != q[i]) cout &lt;&lt; <span class="hljs-string">&quot;o &quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;* &quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlace</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt; i) &#123;<br><span class="hljs-keyword">if</span> ((q[k])==j || <span class="hljs-built_in">abs</span>(q[k]-j) == <span class="hljs-built_in">abs</span>(i-k))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>k++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NQueen</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-built_in">printResult</span>(n);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> tryTimes = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> position = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (tryTimes &lt;= n) &#123;<br>position = <span class="hljs-built_in">randa</span>(<span class="hljs-number">1</span>, n);<br>tryTimes++;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">canPlace</span>(layer, position)) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//退出循环有两种情况：找到了一个解break，此情况需要更进一层。</span><br><span class="hljs-comment">//或者是所有位置都尝试了但还是没找到符合要求的，说明之前有一处找错了，说明这次随机没有解决问题</span><br><span class="hljs-keyword">if</span> (tryTimes &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q[layer] = position;<br><span class="hljs-built_in">NQueen</span>(layer + <span class="hljs-number">1</span>, n);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">while</span> (times &lt; <span class="hljs-number">100</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">NQueen</span>(<span class="hljs-number">1</span>,n))<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//找到一个解就不找了</span><br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; times++ &lt;&lt; <span class="hljs-string">&quot;次没找到解\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Sherwood"><a href="#Sherwood" class="headerlink" title="Sherwood"></a>Sherwood</h2><blockquote><p>用舍伍德算法优化快速排序，由于当快速排序选定的基准元素若为最大or最小值时，此时的时间复杂度最差，因此要避免这种极端情况，可以采用生成随机基准，降低特定实例(基准)与最坏行为(极端情况)的关联来改善快排的实际效率。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randa</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>() % (b - a + <span class="hljs-number">1</span>)+a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span> tmp = a[l];<br><span class="hljs-type">int</span> i = l; <span class="hljs-type">int</span> j = r;<br><span class="hljs-keyword">while</span> (i!=j) &#123;<br><span class="hljs-keyword">while</span> (i&lt;j <span class="hljs-keyword">and</span> a[j]&gt;=tmp) j--;<br>a[i] = a[j];<br><span class="hljs-keyword">while</span> (i &lt; j <span class="hljs-keyword">and</span> a[i] &lt;= tmp) i++;<br>a[j] = a[i];<br>&#125;<br>a[i] = tmp;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &lt; r) &#123;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">randa</span>(l, r);<br><span class="hljs-built_in">swap</span>(a[l], a[i]);<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">partition</span>(a, l, r);<br><span class="hljs-built_in">QuickSort</span>(a, l, p <span class="hljs-number">-1</span>);<br><span class="hljs-built_in">QuickSort</span>(a, p+<span class="hljs-number">1</span> , r);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">52</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">222</span>&#125;;<br><span class="hljs-comment">/*int a[10] = &#123; 2,5,1,7,10,6,9,4,3,8 &#125;;*/</span><br><span class="hljs-built_in">QuickSort</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法，算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>随机算法</tag>
      
      <tag>概率算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branch&amp;Bound</title>
    <link href="/2023/11/28/Branch&amp;Bound/"/>
    <url>/2023/11/28/Branch&amp;Bound/</url>
    
    <content type="html"><![CDATA[<h1 id="Branch-Bound"><a href="#Branch-Bound" class="headerlink" title="Branch&amp;Bound"></a>Branch&amp;Bound</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>与回溯法的区别：回溯法掌握穿越时空技术可以遍历所有的解集。而分支限界掌握预知能力，能提前看清unpromising解并跳过他的求解过程，只专注于最优解，也正是他傲慢和无情地依靠自己的预知，他无法遍历所有的解(除非他的预知太烂了！或者解空间本来就很小)。回溯法依次看到每种结局再回退(dfs)，分支限界放眼所有情况但只考虑最有希望的节点(bfs)，按照自己的预测方式走下去,如果预测方式刁钻(优先队列),他在解空间上的遍历还会是跳跃的，运气好的话他甚至能直接找到最优解。</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>用分支限界写01背包，普通队列：</p><p>准备一个队列和三个队列节点:分别表示根节点，左子节点(选择了该层对应的背包)，右子节点(未选择该层对应的背包)。初始化根节点，根节点入队，队不空则循环：{ 出队并记录该节点于e节点(子也将成为父,因此将信息保存到e很合理！),然后考虑左子结点，先剪枝超重的情况,若未超重,则为e1赋数据并判断上界后入队或剪枝 。在考虑右子节点，赋予数据并求上界后入队或剪枝}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> W = <span class="hljs-number">6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> total = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> w[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> v[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-type">int</span> maxValue = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> tatic[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span> &#123;<br><span class="hljs-type">int</span> no;<br><span class="hljs-type">int</span> layer;<br><span class="hljs-type">int</span> weight;<br><span class="hljs-type">int</span> value;<br><span class="hljs-type">double</span> upper;<br><span class="hljs-type">int</span> x[MAX];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(queue&lt;NodeType&gt; &amp;q,NodeType e)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (e.layer == n) &#123;<br><span class="hljs-keyword">if</span> (e.value &gt; maxValue)<br>&#123;<br>maxValue = e.value;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>tatic[i] = e.x[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>q.<span class="hljs-built_in">push</span>(e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bound</span><span class="hljs-params">(NodeType&amp; e)</span> </span>&#123;<br><span class="hljs-type">double</span> nowV = e.value; <span class="hljs-type">int</span> nowW = e.weight; <span class="hljs-type">int</span> layer = e.layer+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (layer &lt;= n &amp;&amp; nowW + w[e.layer] &lt;= W) &#123;<br>nowV += v[layer];<br>nowW += w[layer];<br>layer++;<br>&#125;<br><span class="hljs-keyword">if</span> (layer &lt;= n)<br>e.upper = nowV + (v[layer] / w[layer]) * (W - nowW);<br><span class="hljs-keyword">else</span><br>e.upper = nowV+ v[layer];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><br>NodeType e, e1, e2; queue&lt;NodeType&gt; q;<br>e.value = <span class="hljs-number">0</span>; e.weight = <span class="hljs-number">0</span>; e.layer = <span class="hljs-number">0</span>; e.no = total++;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>e.x[i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*bound(e);*/</span><br>q.<span class="hljs-built_in">push</span>(e);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>e = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (e.weight + w[e.layer + <span class="hljs-number">1</span>] &lt;= W) &#123;<br>e1.no = total++;<br>e1.layer = e.layer + <span class="hljs-number">1</span>;<br>e1.weight = e.weight + w[e1.layer];<br>e1.value = e.value + v[e1.layer];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>e1.x[i] = e.x[i];<br>e1.x[e1.layer] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">bound</span>(e1);<br><span class="hljs-keyword">if</span>(e1.upper&gt;maxValue)<br><span class="hljs-built_in">EnQueue</span>(q, e1);<br>&#125;<br>e2.no = total++;<br><span class="hljs-comment">/*e2.layer = e1.layer;*/</span> <span class="hljs-comment">//错误 不能以e1为基准，因为可能没有e1</span><br>e2.layer = e.layer + <span class="hljs-number">1</span>;<br>e2.value = e.value; e2.weight = e.weight;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>e2.x[i] = e.x[i];<br>e2.x[e2.layer] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">bound</span>(e2);<br><span class="hljs-keyword">if</span> (e2.upper &gt; maxValue)<br><span class="hljs-built_in">EnQueue</span>(q, e2);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">if</span> (tatic[i])<br>cout &lt;&lt; <span class="hljs-string">&quot;选择物品 &quot;</span> &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; 价值为：&quot;</span>&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; 重量为：&quot;</span>&lt;&lt;w[i]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;总价值为：&quot;</span> &lt;&lt; maxValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>优先级队列：</p><p>队列不再按FIFO顺序，而按高upper优先，因此能更快搜索到最优解。只需要将队列换成优先级队列，重载NodeType&lt;运算符：<code>return upper&lt; anotherE.upper</code> 使满足大upper优先。</p><h2 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h2><p>优先级队列解法：优先出队最小的可能cost 即优先出队最小下界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> c[MAX][MAX] = &#123; &#123;<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&#125; &#125;;<br><span class="hljs-type">int</span> tactic[MAX];<br><span class="hljs-type">int</span> minCost=INF;<br><span class="hljs-type">int</span> total = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><br>&#123;<br><span class="hljs-type">int</span> layer;<br><span class="hljs-type">int</span> no;<br><span class="hljs-type">int</span> cost;<br><span class="hljs-type">bool</span> worker[MAX];<span class="hljs-comment">//worker[i]=true表示任务i已经分配</span><br><span class="hljs-type">double</span> lower;<br><span class="hljs-type">int</span> tactic[MAX];<span class="hljs-comment">//x[i]为人员i分配的任务编号</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> NodeType&amp; aNode)<span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> lower&gt;aNode.lower;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bound</span><span class="hljs-params">(NodeType &amp;e)</span> </span>&#123;<br><span class="hljs-type">int</span> lower = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = e.layer + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-type">int</span> nowMinCost = INF;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (e.worker[j] == <span class="hljs-literal">false</span> &amp;&amp; c[i][j] &lt; nowMinCost)<br>nowMinCost = c[i][j];<br>lower += nowMinCost;<br>&#125;<br>e.lower =e.cost+lower;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>NodeType e, e1;<br>priority_queue&lt;NodeType&gt; q;<br>e.cost = <span class="hljs-number">0</span>; e.layer = <span class="hljs-number">0</span>; e.no = total++;<br><span class="hljs-built_in">memset</span>(e.tactic, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(e.tactic));<br><span class="hljs-built_in">memset</span>(e.worker, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(e.worker));<br>q.<span class="hljs-built_in">push</span>(e);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>e = q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (e.layer == n) &#123;<br><span class="hljs-keyword">if</span> (e.cost &lt; minCost) &#123;<br>minCost = e.cost;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>tactic[i] = e.tactic[i];<br>&#125;<br>&#125;<br>e1.layer = e.layer + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (e.worker[i])<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若任务已经分配则跳过</span><br>e1.no = total++;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; e1.tactic[i] = e.tactic[i]; e1.worker[i] = e.worker[i]; &#125;<br>e1.tactic[e1.layer] = i; e1.worker[i] = <span class="hljs-literal">true</span>;<br>e1.cost = e.cost + c[e1.layer][i];<br><span class="hljs-built_in">bound</span>(e1);<br><span class="hljs-keyword">if</span> (e1.lower &lt; minCost)<br>q.<span class="hljs-built_in">push</span>(e1);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">bfs</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;最佳安排方案：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cout &lt;&lt; <span class="hljs-string">&quot;\n给第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个人分配任务&quot;</span> &lt;&lt; tactic[i]&lt;&lt;<span class="hljs-string">&quot; 成本为：&quot;</span>&lt;&lt;c[i][tactic[i]];<br>cout &lt;&lt; <span class="hljs-string">&quot;\n总成本为：&quot;</span> &lt;&lt; minCost;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流水线调度"><a href="#流水线调度" class="headerlink" title="流水线调度"></a>流水线调度</h2><p>建议johnson算法。这里采用优先级队列写出：</p><p>分析：与任务分配几乎相同的写法，流水线调度之前就分析过<code>f1=f1+a[i];f2=max(f1,f2[i-1]+b[i])</code>设问题的解集树的层数表示当前处理的步骤：根节点(无实际意义)，叶节点(处理的最后一步,得到了一组完整方案),因此当程序执行到解集树中某个节点时,考虑当前还没有完成的作业(因此需要设计一个bool数组表示每个作业是否完成了),将这些作业的b时间累加起来就是当前节点的下界，如果该下界还小于已经求出了的minTime的话,就可以果断剪枝了。同时,也知道了,优先出队下界小的节点。</p><p>思路：首先设置节点类型结构体：包括 当前节点的解向量int[]，当前节点的作业完成情况bool[],当前节点的下界,当前节点的层数,a时间累计(f1),b时间累计(f2),操作符重载,还可以增设一个节点编号,可以统计节点数量。然后将根节点初始化并进队,然后只有队不空就循环,在任务分配问题中,进入循环后就判断出队的节点的层数,若为叶节点就输出,实际上,在一个节点产生时就已经可以根据其layer判断是否为叶节点了，因此叶节点其实不必进队！这里将对这一部分进行优化，后续的操作无法复制父节点数据，修改关键数据并判断。此问题的限界函数更简单，只要遍历未完成的任务，将任务的b时间累加加加上当前节点的f2就可以得到下界了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f<span class="hljs-comment">//定义∞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 21</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<span class="hljs-comment">//作业数</span><br><span class="hljs-type">int</span> a[MAX]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//M1上的执行时间,不用下标0的元素</span><br><span class="hljs-type">int</span> b[MAX]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//M2上的执行时间,不用下标0的元素</span><br><br><span class="hljs-comment">//int a[MAX]=&#123;0,5,10,9,7&#125;;//M1上的执行时间,不用下标0的元素</span><br><span class="hljs-comment">//int b[MAX]=&#123;0,7,5, 9,8&#125;;//M2上的执行时间,不用下标0的元素</span><br><br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> bestf=INF;<span class="hljs-comment">//存放最优调度时间</span><br><span class="hljs-type">int</span> bestx[MAX];<span class="hljs-comment">//存放当前作业最佳调度</span><br><span class="hljs-type">int</span> total=<span class="hljs-number">1</span>;<span class="hljs-comment">//结点个数累计</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><span class="hljs-comment">//队列结点类型</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//结点编号</span><br><span class="hljs-type">int</span> x[MAX];<span class="hljs-comment">//x[i]表示第i步分配作业编号</span><br><span class="hljs-type">int</span> y[MAX];<span class="hljs-comment">//y[i]=1表示编号为i的作业已经分配</span><br><span class="hljs-type">int</span> i;<span class="hljs-comment">//步骤编号</span><br><span class="hljs-type">int</span> f1;<span class="hljs-comment">//已经分配作业M1的执行时间</span><br><span class="hljs-type">int</span> f2;<span class="hljs-comment">//已经分配作业M2的执行时间</span><br><span class="hljs-type">int</span> lb;<span class="hljs-comment">//下界</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> NodeType &amp;s) <span class="hljs-type">const</span><span class="hljs-comment">//重载&lt;关系函数</span><br>&#123;<br><span class="hljs-keyword">return</span> lb&gt;s.lb;<span class="hljs-comment">//lb越小越优先出队</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bound</span><span class="hljs-params">(NodeType &amp;e)</span><span class="hljs-comment">//求结点e的限界值</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//扫描所有作业</span><br><span class="hljs-keyword">if</span> (e.y[i]==<span class="hljs-number">0</span>) sum+=b[i];<span class="hljs-comment">//仅累计e.x中还没有分配的作业的b时间</span><br>e.lb=e.f1+sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has</span><span class="hljs-params">(NodeType e,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//作业j是否已经分配</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span> (e.x[i]==j)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span><span class="hljs-comment">//求解流水作业调度问题</span></span><br><span class="hljs-function"></span>&#123;<br>NodeType e,e1;<br>priority_queue&lt;NodeType&gt; qu;<br><span class="hljs-built_in">memset</span>(e.x,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(e.x));<span class="hljs-comment">//初始化根结点的x</span><br><span class="hljs-built_in">memset</span>(e.y,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(e.y));<span class="hljs-comment">//初始化根结点的y</span><br>e.i=<span class="hljs-number">0</span>;<span class="hljs-comment">//根结点</span><br>e.f1=<span class="hljs-number">0</span>;<br>e.f2=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">bound</span>(e);<br>e.no=total++;<br>qu.<span class="hljs-built_in">push</span>(e);<span class="hljs-comment">//根结点进队列</span><br><span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>())<br>&#123;<br>e=qu.<span class="hljs-built_in">top</span>(); qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队结点e</span><br>e1.i=e.i+<span class="hljs-number">1</span>;<span class="hljs-comment">//扩展分配下一个步骤的作业，对应结点e1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//考虑n个作业</span><br>&#123;<br><span class="hljs-keyword">if</span> (e.y[j]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//作业j是否已分配,若已分配，跳过</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1=<span class="hljs-number">1</span>;i1&lt;=n;i1++)<span class="hljs-comment">//复制e.x得到e1.x</span><br>e1.x[i1]=e.x[i1];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2=<span class="hljs-number">1</span>;i2&lt;=n;i2++)<span class="hljs-comment">//复制e.y得到e1.y</span><br>e1.y[i2]=e.y[i2];<br>e1.x[e1.i]=j;<span class="hljs-comment">//为第i步分配作业j</span><br>e1.y[j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//表示作业j已经分配</span><br>e1.f1=e.f1+a[j];<br>e1.f2=<span class="hljs-built_in">max</span>(e.f2,e1.f1)+b[j];<br><span class="hljs-built_in">bound</span>(e1);<br><span class="hljs-keyword">if</span> (e1.i==n)<span class="hljs-comment">//达到叶子结点</span><br>&#123;<br><span class="hljs-keyword">if</span> (e1.f2&lt;bestf)<span class="hljs-comment">//比较求最优解</span><br>&#123;<br>bestf=e1.f2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j1=<span class="hljs-number">1</span>;j1&lt;=n;j1++)<br>bestx[j1]=e1.x[j1];<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//找到一个解后结束</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (e1.f2&lt;=bestf)<span class="hljs-comment">//剪枝</span><br>&#123;<br>e1.no=total++;<span class="hljs-comment">//结点编号增加1</span><br>qu.<span class="hljs-built_in">push</span>(e1);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最优方案:\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   第%d步执行作业%d\n&quot;</span>,k,bestx[k]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   总时间=%d\n&quot;</span>,bestf);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的单源最短路径"><a href="#图的单源最短路径" class="headerlink" title="图的单源最短路径"></a>图的单源最短路径</h2><p>o(<em>￣︶￣</em>)o</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分支限界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Greedy Algorithm</title>
    <link href="/2023/11/24/Greed/"/>
    <url>/2023/11/24/Greed/</url>
    
    <content type="html"><![CDATA[<h1 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h1><blockquote><p>怎么贪才不会翻车？也是一种艺术。</p></blockquote><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并非所有问题用贪心都能找到最优解。需要满足两个性质：1.<strong>贪心选择性质</strong>：问题的整体最优解可以通过一系列局部最优的选择来达到，由数学归纳法证明。2.<strong>最优子结构性质</strong>：问题的最优解包含其子问题的最优解，由反证法证明。</p><p>解题要点：正确找出贪心的原则。一般是最值优先，因此经常需要排序或者使用优先级队列。</p><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><blockquote><p>无脑列出四个最值：1.最早开始时间优先；2.最晚开始时间优先；3.最早结束时间优先；4.最晚结束时间优先。第2和第4显然不对。考虑方案1和方案3。对于模棱两可的决策，直接考虑对应的极端情况。若有2个活动A：A1[0,24] A2[1,2];若用方案1则最终只能安排一个活动，若用方案2则能完成两个活动。因此这里的贪心原则为：最早结束时间优先。定义一个活动结构体，根据end属性排序即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Action</span><br>&#123;<br><span class="hljs-type">int</span> beginTime;<br><span class="hljs-type">int</span> endTime;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> Action&amp; a) &#123;<br><span class="hljs-keyword">return</span> endTime &lt;= a.endTime;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(Action a[],<span class="hljs-type">bool</span> s[])</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + NUM);<span class="hljs-comment">//1.按贪心原则排序</span><br><span class="hljs-type">int</span> preEndTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; NUM; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i].beginTime &gt;= preEndTime)<br>&#123;<br>s[i] = <span class="hljs-literal">true</span>;<br>preEndTime = a[i].endTime;<span class="hljs-comment">//2.其他设计</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Action a[],<span class="hljs-type">bool</span> s[])</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; NUM; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (s[i])<br>cout &lt;&lt; <span class="hljs-string">&quot;Action[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]选取，开始时间:&quot;</span> &lt;&lt; a[i].beginTime &lt;&lt; <span class="hljs-string">&quot;结束时间：&quot;</span> &lt;&lt; a[i].endTime&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Action test1[NUM] = &#123; &#123;<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">11</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">12</span>&#125; ,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">13</span>&#125; &#125;;<br>    <span class="hljs-comment">//supposed:&#123;1,4&#125;-&gt;&#123;5,7&#125;-&gt;&#123;8,11&#125;</span><br>Action test2[NUM] = &#123; &#123;<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">12</span>,<span class="hljs-number">20</span>&#125;,&#123;<span class="hljs-number">22</span>,<span class="hljs-number">23</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; &#125;;<br>    <span class="hljs-comment">//supposed:&#123;0,1&#125;-&gt;&#123;1,2&#125;-&gt;&#123;2,3&#125;-&gt;&#123;4,5&#125;-&gt;&#123;6,7&#125;-&gt;&#123;12,20&#125;-&gt;&#123;22,23&#125;</span><br><span class="hljs-type">bool</span> selected1[NUM] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-type">bool</span> selected2[NUM] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-built_in">solution</span>(test1,selected1);<br><span class="hljs-built_in">display</span>(test1,selected1);<br>cout &lt;&lt; <span class="hljs-string">&quot;//////////////////&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">solution</span>(test2, selected2);<br><span class="hljs-built_in">display</span>(test2, selected2);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p>1.最高价值优先；2.最低重量优先；3.最高性价比优先。无脑3.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//0.背包数据结构，重量和价值，按单位重量价值排序；</span><br><span class="hljs-comment">//1.对排序好的序列依次取得书包；</span><br><span class="hljs-comment">//2.对于最后一个书包，可能会出现无法全拿走的情况，因此需要计算能拿走的最大比例；</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">//notes:这里是按单位重量价值降序排序，但原生的sort函数是升序排列的， 因此需要自定义operator 但是这样会导致语义混乱，因此可以定义一个compare函数，作为sort的参数。</span><br><span class="hljs-comment">//拿走最后一份（或者比例份）要把MAXWEIGHT归零。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span> &#123;<br><span class="hljs-type">double</span> value;<br><span class="hljs-type">double</span> weight;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Take</span><br>&#123;<br><span class="hljs-type">bool</span> isTaken=<span class="hljs-literal">false</span>;<br><span class="hljs-type">double</span> proportion=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(Bag a, Bag b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.value/a.weight&gt;b.value/b.weight;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(Bag b[],Take t[], <span class="hljs-type">int</span> M)</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(b, b + NUM,compare);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;;++i)<br>&#123;<br><span class="hljs-keyword">if</span> (M &gt;= b[i].weight)<br>&#123;<br>t[i].isTaken = <span class="hljs-literal">true</span>;<br>t[i].proportion = <span class="hljs-number">1</span>;<br>M -= b[i].weight;<br><br>&#125;<span class="hljs-comment">//以上为能全部拿走的物品</span><br><span class="hljs-comment">//当背包剩余质量低于当前考虑的物品，则只能尽全力充满背包了，</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M != <span class="hljs-number">0</span>)<br>&#123;<br>t[i].isTaken = <span class="hljs-literal">true</span>;<br>t[i].proportion = M / b[i].weight;<br>M = <span class="hljs-number">0</span>;<span class="hljs-comment">//别忘了M置零！</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Bag b[], Take t[])</span> </span>&#123;<br><span class="hljs-type">double</span> sumValue = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; t[i].isTaken; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Bag:&quot;</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;价值：&quot;</span>&lt;&lt;b[i].value&lt;&lt;<span class="hljs-string">&quot; 重量:&quot;</span>&lt;&lt;b[i].weight &lt;&lt; <span class="hljs-string">&quot;被拿走&quot;</span> &lt;&lt; t[i].proportion &lt;&lt; <span class="hljs-string">&quot;份&quot;</span> &lt;&lt; endl;<br>sumValue += b[i].value * t[i].proportion;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;总价值为：&quot;</span> &lt;&lt; sumValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Bag Bagtest1[NUM] = &#123; &#123;<span class="hljs-number">20</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">30</span>,<span class="hljs-number">20</span>&#125;,&#123;<span class="hljs-number">66</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-number">40</span>,<span class="hljs-number">40</span>&#125;,&#123;<span class="hljs-number">60</span>,<span class="hljs-number">50</span>&#125; &#125;;<br>Take Taketest1[NUM] = &#123;&#125;;<br><span class="hljs-type">int</span> MaxWeight = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">solution</span>(Bagtest1,Taketest1, MaxWeight);<br><span class="hljs-built_in">display</span>(Bagtest1,Taketest1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="田忌赛马"><a href="#田忌赛马" class="headerlink" title="田忌赛马"></a>田忌赛马</h2><blockquote><p>田忌与齐威王赛马，每一局的赢家+1积分 输家-1积分 平局无事发生，田忌如何安排才能获得最多的积分？田忌和齐威王的马们可以用分别用两个数组表示，下标为马的编号，元素值为对应马的速度。先对两组马速度排序，两组双指针，分别指向本组最速のhorse和最慢的马。那么有4种情况：</p><p>1.田最速の马&gt;齐最速の马 （这种情况会出现在齐浪费了他本来最速の马，导致他当前最速の马不如田的）</p><p>此时直接让这两匹马比赛，田田+1.</p><p>2.田最速の马&lt;齐最速の马</p><p>此时让田最拉の马和齐最速の马比，田田-1.</p><p>3.田最速の马&#x3D;齐最速の马</p><p>这时狗一下，考虑最拉の马：</p><p>​3.1 田最拉の马&gt;齐最拉の马 </p><p>​此时直接让这两匹马比赛，田田+1.</p><p>​3.2 田最拉の马&lt;&#x3D;齐最拉の马 </p><p>​此时让田最拉の马和齐最速の马比！田田-1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//1.Tmax&gt;Qmax::Tmax vs Qmax</span><br><span class="hljs-comment">//2.Tmax&lt;Qmax:Tmin vs Qmax</span><br><span class="hljs-comment">//3.Tmax=Qmax:</span><br><span class="hljs-comment">//3.1 Tmin&gt;Qmin Tmin vs Qmin</span><br><span class="hljs-comment">//3.2 Tmin&lt;Qmin Tmin vs Qmax</span><br><span class="hljs-comment">//3.3 Tmin=Qmin Tmin vs Qmax</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> t[],<span class="hljs-type">int</span> q[])</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(t,t+NUM);<br><span class="hljs-built_in">sort</span>(q,q+NUM);<br><span class="hljs-type">int</span> tl = <span class="hljs-number">0</span>, tr = NUM - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> ql = <span class="hljs-number">0</span>, qr = NUM - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (tl &lt;= tr)<br>&#123;<br><span class="hljs-keyword">if</span> (t[tr] &gt; q[qr])<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tr] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[qr] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score += <span class="hljs-number">200</span>;<br>tr--;<br>qr--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[tr] &lt; q[qr])<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tl] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[qr] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score -= <span class="hljs-number">200</span>;<br>tl++;<br>qr--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (t[tl] &gt; q[ql])<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tl] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[ql] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score += <span class="hljs-number">200</span>;<br>tl++;<br>ql++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tl] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[qr] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score -= <span class="hljs-number">200</span>;<br>tl++;<br>qr--;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> Tian[NUM] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//1 2 3 4 5 </span><br><span class="hljs-type">int</span> Qi[NUM] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">//2 3 4 5 6     score:1-6 2-5 ::-400/// 3-2 4-3 5-4::+600/===+200</span><br><span class="hljs-built_in">solution</span>(Tian, Qi);<br>cout &lt;&lt; endl;<br><span class="hljs-type">int</span> T2[NUM] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> Q2[NUM] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-built_in">solution</span>(T2, Q2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多机调度问题"><a href="#多机调度问题" class="headerlink" title="多机调度问题"></a>多机调度问题</h2><blockquote><p>n个作业 m台相同的机器 每个作业都有各自的处理用时 并且作业和作业的处理都是原子化的 怎么安排才能在最短时间内完成所有作业的加工？1.最短作业优先 2.最长作业优先 我一开始竟然还认为是最短作业！但其实不是啊，应该是长作业优先！</p><p>分析：给所有作业按执行时长降序排序，然后按照贪心原则依次分配给机器们，这里就考虑到了，倘若机器数大于作业数，那直接将作业分别分配给每个机器就行，如果机器数少于作业数才需要慢慢做，如果将作业，机器，执行时长独立起来将会很乱！也不便于叙述，不如直接将他们对应绑定作为一个数据结构：分配方案allocation。那么最初的排序也要改动成为对allocation数组按照属性time降序排序，然后每一次处理新作业，就将机器编号+1，但是这就考虑到了，如果已经分配完了所有机器，而后续作业将分配给率先完成的那些之前分配的短作业所在的机器号，那么这里的处理就不必+1，而是直接将完成的allocation的机器编号赋值给当前待处理的作业即可。有点乱，整理后，清晰的思路如下：</p><p>思路：数据结构：先定义一个数据结构表示分配方案：作业编号-作业执行时长-为其分配的机器的编号。将分配方案按作业执行时长降序排序。执行算法：先判断作业数量和机器数量的大小关系，如果机器数量更多，可以直接将每个作业分配给这些机器，此情况最终的执行时长就是max <sub>i in all</sub>(allocation[i].time);如果作业更多，那就要先按贪心原则排好序，再一一入队（从0开始，遍历到machineAmount-1），此过程不需要考虑别的，第一轮分配完毕后，为了分配其余的作业（从machineAmount开始，遍历到jobAmount），考虑已经执行完毕了的短作业，最短的作业最先执行完，因此优先出队短作业（这里的队列就要设计成小根堆了），并做相应的数据处理（分析中提到的机器编号的处理），数据处理完毕后再让一个待处理作业入队即可…</p><p>三部曲：1.定义数据结构和compare函数 2.排序和必要处理 3.展示结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> jobAmount = <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> machineAmount = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//作业和机器的分配关系</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">allocation</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//作业序号</span><br><span class="hljs-type">int</span> t;<span class="hljs-comment">//执行时间</span><br><span class="hljs-type">int</span> mno;<span class="hljs-comment">//机器序号</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> allocation&amp; s) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> t &gt; s.t;<br>&#125;<span class="hljs-comment">//按t越小越优先出队 注意这个出队指的是短作业完成的时间顺序，越短越早出队。</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">allocation</span> A[] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">14</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">16</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">3</span>&#125; &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>allocation e;<br><span class="hljs-keyword">if</span> (jobAmount &lt;= machineAmount)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;为每一个作业分配一台机器\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">sort</span>(A, A + jobAmount);<br>priority_queue&lt;allocation&gt; qu;<span class="hljs-comment">//小根堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; machineAmount; i++)<br>&#123;<br>A[i].mno = i + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  给机器%d分配作业%d,执行时间为%2d,占用时间段:[%d,%d]\n&quot;</span>,<br>A[i].mno, A[i].no, A[i].t, <span class="hljs-number">0</span>, A[i].t);<br>qu.<span class="hljs-built_in">push</span>(A[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = machineAmount; j &lt; jobAmount; j++)<br>&#123;<br>e = qu.<span class="hljs-built_in">top</span>(); qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队e</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  给机器%d分配作业%d,执行时间为%2d,占用时间段:[%d,%d]\n&quot;</span>,<br>e.mno, A[j].no, A[j].t, e.t, e.t + A[j].t);<br>e.t += A[j].t;<br>qu.<span class="hljs-built_in">push</span>(e);<span class="hljs-comment">//e进队</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tactic:\n&quot;</span>);<br><span class="hljs-built_in">solution</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Huffman-编码"><a href="#Huffman-编码" class="headerlink" title="Huffman 编码"></a>Huffman 编码</h2><blockquote><p>字符集{d1…dn} 他们的对应的频率：{f1…fn}。求最优编码方案。</p><p>分析：先根据初始数据构造huffman树，再根据树求出编码。离散数学和数据结构中都学了huffman树的生成过程：每次选择两个最小频率元素作为叶子，再将它们的和作为根，将这个根作为一个叶子，而构造成此叶子的两个元素不再考虑。循环此过程。根据huffman树的生成过程可以发现贪心策略是：优先考虑最低频率的元素作为叶子节点。可以设置huffman树的节点数据结构TreeNode：包含weight，LC，RC，Parent，aChar。字符aChar和它的权值是最初就能初始化的，其它数据的初始化需要考虑建树的过程,最开始会将三个树结构属性全置为-1。在构造树的过程中再详细赋值。考虑树的构造过程，实际上会频繁比较，如果用排序会很低效，每次构造一个新节点后就排序，而且还要除去之前的两个节点，显然， 用优先级队列可以很轻松地解决，重载&lt;使得按照weight小者优先的 原则进行。首先将所有节点进队(0~n-1),然后构造(n~2*n-1),每次构造一个新节点，就将两个节点出队，处理好数据后将新节点入队，就不再需要手动排序了。至此，树就构造好了，接下来就要根据树求编码，对于每一个叶子节点，从它开始依次找到根节点，每当寻根的过程中作为了左孩子，就将编码链接1，否则链接0，最终将这个节点的aChar和构造出的string编码建立映射关系，存入map中，循环如此求出所有字符的编码。最后分别输出。还可以求出wpl，wpl&#x3D;每个叶子*他的深度。 </p><p>思路：</p><p>0.数据结构定义：TreeNode { aChar, weight, LC, RC, Parent}和 NodeType{ no, aChar ,weight, override &lt;}</p><p>1.初始化：TreeNode nodes[N]{xxxx};for(nodes 0 to 2n-1){LC&#x3D;RC&#x3D;Parent&#x3D;-1}</p><p>2.建树：for(leaves 0 to n-1){setData push} for(constructor Nodes n to 2n-1){e1pop; e2pop; e1&amp;e2 setData e; push e}</p><p>3.求编码：for(leaves 0 to n-1){ judge(as LC:1 or 0) &#x3D;&gt;until(root)}, set Map(char,string)}</p><p>4.求wpl：for(leaves 0 to n-1){Sum leafWeight*height }</p><p>5.输出结果：display</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100000</span>;<br><span class="hljs-comment">//四大模块：初始化数据；建树和输出树；建编码并输出编码；计算wpl；</span><br><span class="hljs-comment">//准备条件：初始化一组编码和他对应的频率（权值）。</span><br><span class="hljs-comment">//1.构造huffman树：首先将初始化的编码全部入队（0~n），然后从（n~2*n-1）依次构造出整个树，</span><br><span class="hljs-comment">// 此循环中每次出队（因为以后在构造其他节点时不再考虑）两个最小weight的节点，并利用他们构造出新节点，最为他们的父亲节点</span><br><span class="hljs-comment">// 2.通过huffman树构造编码：每个字符有其对应的编码，因此用map存放对应关系，</span><br><span class="hljs-comment">// 从huffman树的叶子开始依次寻到（until）根节点，每次作为左子节点则将编码连接1，否则连接0...每处理一个就建立mapping</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br><span class="hljs-type">char</span> aChar;<span class="hljs-comment">//字符</span><br><span class="hljs-type">int</span> weight;<span class="hljs-comment">//权值：频率</span><br><span class="hljs-type">int</span> parent;<br><span class="hljs-type">int</span> lChild;<br><span class="hljs-type">int</span> rChild;<br>&#125;;<br><br>TreeNode nodes[MAX];<br>map&lt;<span class="hljs-type">char</span>, string&gt; huffmanCode;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><span class="hljs-comment">//优先队列结点类型</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//对应哈夫曼树ht中的位置</span><br><span class="hljs-type">char</span> aChar;<span class="hljs-comment">//字符</span><br><span class="hljs-type">int</span>  weight;<span class="hljs-comment">//权值</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> NodeType&amp; s) <span class="hljs-type">const</span><br>&#123;<span class="hljs-comment">//用于创建大根堆</span><br><span class="hljs-keyword">return</span> s.weight &lt; weight;<span class="hljs-comment">//weight越小越优先。</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">//构造哈夫曼树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHTree</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>NodeType e, e1, e2;<span class="hljs-comment">//由最小weight的e1 e2 构造e </span><br>priority_queue&lt;NodeType&gt; qu;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; k++)<span class="hljs-comment">//设置所有结点的指针域</span><br>nodes[k].lChild = nodes[k].rChild = nodes[k].parent = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-comment">//将n个结点进队qu</span><br>&#123;<br>e.no = i;<br>e.aChar = nodes[i].aChar;<br>e.weight = nodes[i].weight;<br>qu.<span class="hljs-built_in">push</span>(e);<br>&#125;<br><span class="hljs-comment">//关于此处的n 2*n-1 数据结构上有推导</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; j++)<span class="hljs-comment">//构造哈夫曼树的n-1个非叶结点</span><br>&#123;<br>e1 = qu.<span class="hljs-built_in">top</span>();  qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队权值最小的结点e1</span><br>e2 = qu.<span class="hljs-built_in">top</span>();  qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队权值次小的结点e2</span><br>nodes[j].weight = e1.weight + e2.weight; <span class="hljs-comment">//构造哈夫曼树的非叶结点j</span><br>nodes[j].lChild = e1.no;<br>nodes[j].rChild = e2.no;<br>nodes[e1.no].parent = j;<span class="hljs-comment">//修改e1.no的双亲为结点j</span><br>nodes[e2.no].parent = j;<span class="hljs-comment">//修改e2.no的双亲为结点j</span><br>e.no = j;<span class="hljs-comment">//构造队列结点e</span><br>e.weight = e1.weight + e2.weight;<br>qu.<span class="hljs-built_in">push</span>(e);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHCode</span><span class="hljs-params">()</span><span class="hljs-comment">//构造哈夫曼编码</span></span><br><span class="hljs-function"></span>&#123;<br>string code;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-comment">//构造叶结点i的哈夫曼编码</span><br>&#123;<br>code = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> nowNo = i;<br><span class="hljs-type">int</span> f = nodes[nowNo].parent;<br><span class="hljs-keyword">while</span> (f != <span class="hljs-number">-1</span>)<span class="hljs-comment">//循环到根结点</span><br>&#123;<br><span class="hljs-keyword">if</span> (nodes[f].lChild == nowNo)<span class="hljs-comment">//当前节点作为父节点的左孩子</span><br>code = <span class="hljs-string">&#x27;0&#x27;</span> + code;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//当前节点作为父节点的右孩子</span><br>code = <span class="hljs-string">&#x27;1&#x27;</span> + code;<br>nowNo = f; f = nodes[nowNo].parent;<br>&#125;<br>huffmanCode[nodes[i].aChar] = code;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispHCode</span><span class="hljs-params">()</span><span class="hljs-comment">//输出哈夫曼编码</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">char</span>, string&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = huffmanCode.<span class="hljs-built_in">begin</span>(); it != huffmanCode.<span class="hljs-built_in">end</span>(); ++it)<br>cout &lt;&lt; <span class="hljs-string">&quot;    &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispHTree</span><span class="hljs-params">()</span><span class="hljs-comment">//输出哈夫曼树</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    data=%c, weight=%d, lchild=%d, rchild=%d, parent=%d\n&quot;</span>,<br>nodes[i].aChar, nodes[i].weight, nodes[i].lChild, nodes[i].rChild, nodes[i].parent);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">WPL</span><span class="hljs-params">()</span><span class="hljs-comment">//求WPL</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> wpl = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>wpl += nodes[i].weight * huffmanCode[nodes[i].aChar].<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">return</span> wpl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n = <span class="hljs-number">5</span>;<br>nodes[<span class="hljs-number">0</span>].aChar = <span class="hljs-string">&#x27;a&#x27;</span>; nodes[<span class="hljs-number">0</span>].weight = <span class="hljs-number">4</span>;<span class="hljs-comment">//置初值即n个叶子结点</span><br>nodes[<span class="hljs-number">1</span>].aChar = <span class="hljs-string">&#x27;b&#x27;</span>; nodes[<span class="hljs-number">1</span>].weight = <span class="hljs-number">2</span>;<br>nodes[<span class="hljs-number">2</span>].aChar = <span class="hljs-string">&#x27;c&#x27;</span>; nodes[<span class="hljs-number">2</span>].weight = <span class="hljs-number">1</span>;<br>nodes[<span class="hljs-number">3</span>].aChar = <span class="hljs-string">&#x27;d&#x27;</span>; nodes[<span class="hljs-number">3</span>].weight = <span class="hljs-number">7</span>;<br>nodes[<span class="hljs-number">4</span>].aChar = <span class="hljs-string">&#x27;e&#x27;</span>; nodes[<span class="hljs-number">4</span>].weight = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">CreateHTree</span>();<span class="hljs-comment">//建立哈夫曼树</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;构造的哈夫曼树:\n&quot;</span>);<br><span class="hljs-built_in">DispHTree</span>();<br><span class="hljs-built_in">CreateHCode</span>();<span class="hljs-comment">//求哈夫曼编码</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;产生的哈夫曼编码如下:\n&quot;</span>);<br><span class="hljs-built_in">DispHCode</span>();<span class="hljs-comment">//输出哈夫曼编码</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WPL=%d\n&quot;</span>, <span class="hljs-built_in">WPL</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流水线作业调度"><a href="#流水线作业调度" class="headerlink" title="流水线作业调度"></a>流水线作业调度</h2><blockquote><p>一批作业，他们都需要先在机器A上执行，然后再到B上执行，不同作业在不同机器上执行时间不同。该如何贪心呢？假设只有两个作业JobA JobB 他们在AB上的执行时间分别是(a1,b1)和(a2,b2)</p><ol><li><p>作业A先执行</p></li><li><p>作业B不必等待&#x3D;&gt;总时间为a1+a2+b1+b2-b1&#x3D;&gt;不等待是因为a2&gt;b1</p></li><li><p>作业B需要等待&#x3D;&gt;总时间为a1+a2+b1+b2-a2&#x3D;&gt;等待是因为a2&lt;b1</p></li></ol><p>  因此：A先执行的最短时间：a1+a2+b1+b2-min(b1,a2)</p><ol start="2"><li><p>作业B先执行</p></li><li><p>作业A不必等待&#x3D;&gt;总时间为a1+a2+b1+b2-b2&#x3D;&gt;不等待是因为a1&gt;b2</p></li><li><p>作业A需要等待&#x3D;&gt;总时间为a1+a2+b1+b2-a1&#x3D;&gt;等待是因为a1&lt;b2</p></li></ol><p>  因此：B先执行的最短时间：a1+a2+b1+b2-min(b2,a1)</p><p>综上：最短时间为：a1+a2+b1+b2+max( min(b1,a2) , min(b2,a1) ).根据此思路推导出贪心策略：</p><p>1.若a&gt;b 则让b较大的先执行</p><p>2.若a&lt;&#x3D;b 则让a较小的先执行</p><p>Johnson算法：</p><p>1.将所有作业按照a时间和b时间的大小关系分为两组，一组的作业a&lt;&#x3D;b，记为G1， 另一组作业a&gt;b，记为G2；</p><p>2.G1按a升序排序（最先执行最小a的作业），G2按b降序排序（最先执行最大b的作业）;</p><p>3.先执行完毕所有G1组，再执行完所有G2组。</p><p>（2.确定组内顺序，3.确定组间顺序，确定顺序后直接执行就能得到最佳调度方案）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> a[N]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//对应M1的时间</span><br><span class="hljs-type">int</span> b[N]=&#123;<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//对应M2的时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//作业序号</span><br>    <span class="hljs-type">bool</span> group;<span class="hljs-comment">//1代表第一组G1,0代表第二组G2</span><br>    <span class="hljs-type">int</span> time;<span class="hljs-comment">//a,b的最小时间</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> NodeType &amp;s) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> time&lt;s.time;<span class="hljs-comment">//按time递增排序</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> best[N];<span class="hljs-comment">//最优调度序列</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span><span class="hljs-comment">//求解流水作业调度问题</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,j,k;<br>NodeType c[N];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//n个作业中,求出每个作业的最小加工时间 </span><br>&#123;<br>c[i].no=i;<br>c[i].group=(a[i]&lt;=b[i]);<span class="hljs-comment">//a[i]&lt;=b[i]对应第1组G1,a[i]&gt;b[i]对应第0组G2</span><br>c[i].time=a[i]&lt;=b[i]?a[i]:b[i];<span class="hljs-comment">//第1组存放a[i],第0组存放b[i]</span><br>&#125;<br><span class="hljs-built_in">sort</span>(c,c+n);<span class="hljs-comment">//c元素按time递增排序</span><br>j=<span class="hljs-number">0</span>; k=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//扫描c所有元素,产生最优调度方案</span><br>&#123;<br><span class="hljs-keyword">if</span>(c[i].group==<span class="hljs-number">1</span>)<span class="hljs-comment">//第1组,按time递增排列放在best的前面部分</span><br>best[j++]=c[i].no;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//第0组,按time递减排列放到best的后面部分</span><br>best[k--]=c[i].no;<br>&#125;<br><span class="hljs-type">int</span> f1=<span class="hljs-number">0</span>;<span class="hljs-comment">//累计M1上的执行时间</span><br><span class="hljs-type">int</span> f2=<span class="hljs-number">0</span>;<span class="hljs-comment">//最优调度下的消耗总时间</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>f1+=a[best[i]];<br>f2=<span class="hljs-built_in">max</span>(f2,f1)+b[best[i]];<br>    &#125;<br><span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    总时间: %d\n&quot;</span>,<span class="hljs-built_in">solve</span>());<span class="hljs-comment">//输出:33</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    调度方案: &quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,best[i]+<span class="hljs-number">1</span>);<span class="hljs-comment">//输出:3 1 4 2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>贪心</tag>
      
      <tag>greed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Divide&amp;Conquer</title>
    <link href="/2023/11/24/Divide&amp;Conquer/"/>
    <url>/2023/11/24/Divide&amp;Conquer/</url>
    
    <content type="html"><![CDATA[<h1 id="Divide-Conquer"><a href="#Divide-Conquer" class="headerlink" title="Divide&amp;Conquer"></a>Divide&amp;Conquer</h1><blockquote><p>思想只能作为指导 实践中的细节才是魔鬼藏身之处——二分边界问题 </p></blockquote><span id="more"></span><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>变式：第K 大&#x2F;小 数</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>两种写法:</p><ol><li><p>自顶向下：简洁 可读性好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> NUM[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (i &lt; n)<br>cout &lt;&lt; a[i++] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span>* b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[r - l + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> b_index = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> left = l; <span class="hljs-type">int</span> right = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//判断并复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid <span class="hljs-keyword">and</span> right &lt;= r) &#123;<br><span class="hljs-keyword">if</span> (a[left] &lt; a[right]) b[b_index++] = a[left++];<br><span class="hljs-keyword">else</span>  b[b_index++] = a[right++];<br>&#125;<br><span class="hljs-comment">//多余元素全部复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid)b[b_index++] = a[left++];<br><span class="hljs-keyword">while</span> (right &lt;= r)b[b_index++] = a[right++];<br><span class="hljs-comment">//复制临时数组序列给原数组</span><br><span class="hljs-type">int</span> start = l;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b_index_this = <span class="hljs-number">0</span>; start &lt;= r; start++)<br>a[start] = b[b_index_this++];<br><span class="hljs-keyword">delete</span>[] b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">MergeSort</span>(a,l,mid);<br><span class="hljs-built_in">MergeSort</span>(a,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">Merge</span>(a,l,mid,r);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">MergeSort</span>(NUM, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">display</span>(NUM,<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自底向上：高效 但要考虑的细节多 较繁琐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> NUM[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> times = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> j)</span> </span>&#123;<br><span class="hljs-type">int</span>* b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[j - i + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> b_index = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> left = i; <span class="hljs-type">int</span> right = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//判断并复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid <span class="hljs-keyword">and</span> right &lt;= j) &#123;<br><span class="hljs-keyword">if</span> (a[left] &lt; a[right]) b[b_index++] = a[left++];<br><span class="hljs-keyword">else</span>  b[b_index++] = a[right++];<br>&#125;<br><span class="hljs-comment">//多余元素全部复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid)<br>b[b_index++] = a[left++];<br><span class="hljs-keyword">while</span> (right &lt;= j)<br>b[b_index++] = a[right++];<br><span class="hljs-comment">//复制临时数组序列给原数组</span><br><span class="hljs-type">int</span> start = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b_index_this = <span class="hljs-number">0</span>; start &lt;= j; start++)<br>a[start] = b[b_index_this++];<br><span class="hljs-keyword">delete</span>[] b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergePass</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">index</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//合并相邻表，若能够合并，当前表下标，加上连续两个表长后的下标小于末尾下标，则合并。</span><br><span class="hljs-keyword">for</span> (; index + <span class="hljs-number">2</span> * len - <span class="hljs-number">1</span> &lt; n; index += <span class="hljs-number">2</span> * len)<br><span class="hljs-built_in">merge</span>(a, index, index + len - <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span> * len - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//考虑最后一个轮空的表，其长度会较小，因此当满足index+2*len-1&gt;n and index + len -1&lt;n 则说明有小表，小表的末尾就是n-1.</span><br><span class="hljs-keyword">if</span> (index + len - <span class="hljs-number">1</span> &lt; n)<br><span class="hljs-built_in">merge</span>(a, index, index + len - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//循环的增长与归并算法的趟数有关</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt; n; len *= <span class="hljs-number">2</span>)<br><span class="hljs-built_in">mergePass</span>(a, len, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (i &lt; n)<br>cout &lt;&lt; a[i++] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">mergeSort</span>(NUM,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">display</span>(NUM, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="第K小"><a href="#第K小" class="headerlink" title="第K小"></a>第K小</h3><p>用快排的思想写是最好的。</p><p>画数轴确定递归的判断条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (j - l + <span class="hljs-number">1</span> &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(q, l, j, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="等长有序序列中位数"><a href="#等长有序序列中位数" class="headerlink" title="等长有序序列中位数"></a>等长有序序列中位数</h3><blockquote><p>两个等长序列A B，求他们的中位数。（递增序列）</p></blockquote><p>分析：</p><ol><li>若A B只有一个元素， 取较小者； </li><li>若A B有多个元素，则分别求出A B的中位数，若二者中位数相同，那就是最终答案，若不同：<ol><li>若A的中位数&gt;B的中位数：限制AB序列，取A前半段，B后半段，然后递归；</li><li>若A的中位数&lt;B的中位数：限制AB序列，取A后半段，B前半段，然后递归；</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepart</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;s,<span class="hljs-type">int</span> &amp;t)</span><span class="hljs-comment">//求a[s..t]序列的前半子序列</span><br>&#123;<span class="hljs-type">int</span> m=(s+t)/<span class="hljs-number">2</span>;<br>t=m;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">postpart</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;s,<span class="hljs-type">int</span> &amp;t)</span><span class="hljs-comment">//求a[s..t]序列的后半子序列</span><br>&#123;<span class="hljs-type">int</span> m=(s+t)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> ((s+t)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//序列中有奇数个元素</span><br>s=m;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//序列中有偶数个元素</span><br>s=m+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=s;i&lt;=t;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">midnum</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> s1,<span class="hljs-type">int</span> t1,<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> s2,<span class="hljs-type">int</span> t2)</span><br>&#123;<span class="hljs-comment">//求两个有序序列a[s1..t1]和b[s2..t2]的中位数</span><br><span class="hljs-type">int</span> m1,m2;<br><span class="hljs-keyword">if</span> (s1==t1 &amp;&amp; s2==t2)<span class="hljs-comment">//两序列只有一个元素时返回较小者</span><br><span class="hljs-keyword">return</span> a[s1]&lt;b[s2]?a[s1]:b[s2];<br><span class="hljs-keyword">else</span><br>&#123;m1=(s1+t1)/<span class="hljs-number">2</span>;<span class="hljs-comment">//求a的中位数</span><br>m2=(s2+t2)/<span class="hljs-number">2</span>;<span class="hljs-comment">//求b的中位数</span><br><span class="hljs-keyword">if</span> (a[m1]==b[m2])<span class="hljs-comment">//两中位数相等时返回该中位数</span><br><span class="hljs-keyword">return</span> a[m1];<br><span class="hljs-keyword">if</span> (a[m1]&lt;b[m2])<span class="hljs-comment">//当a[m1]&lt;b[m2]时</span><br>&#123;postpart(s1,t1);<span class="hljs-comment">//a取后半部分</span><br>prepart(s2,t2);<span class="hljs-comment">//b取前半部分</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:&quot;</span>); display(a,s1,t1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b:&quot;</span>); display(b,s2,t2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> midnum(a,s1,t1,b,s2,t2);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//当a[m1]&gt;b[m2]时</span><br>&#123;prepart(s1,t1);<span class="hljs-comment">//a取前半部分</span><br>postpart(s2,t2);<span class="hljs-comment">//b取后半部分</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:&quot;</span>); display(a,s1,t1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b:&quot;</span>); display(b,s2,t2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> midnum(a,s1,t1,b,s2,t2);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span> b[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">//int a[]=&#123;1,3,4,6,9&#125;;</span><br><span class="hljs-comment">//int b[]=&#123;2,3,5,8,10&#125;;</span><br><span class="hljs-type">int</span> n=<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;中位数:%d\n&quot;</span>,midnum(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,b,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><p>区间是 [L,MID-1]  则mid&#x3D;l+r+1&gt;&gt;1 满足条件 L&#x3D;mid 因为右侧是[mid,R]</p><p>区间是[L,MID] 则mid&#x3D;l+r&gt;&gt;1 满足条件 R&#x3D;mid 因为左侧是[L,mid]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><blockquote><p>2<sup>n</sup>规模的棋盘中，有一个特殊块，用L型骨牌填满棋盘，围住特殊块。</p></blockquote><p>分析：为什么用分治法可以完成？因为当棋盘很小时，可以很简单的求出来，那么问题就在于划分棋盘，每次都将棋盘划分为四个小棋盘，说着很简单，但其实最重要的不在于单纯的划分，因为按照一开始所说，棋盘很小时问题很容易解决(一个特殊块的2*2棋盘 只需要一个L型骨牌即可)，这其实意味着棋盘即使很小，但也要<strong>存在</strong>那个特殊块，但目前只有一个特殊块，而棋盘却又很大，因此不仅需要划分，还要在每次划分时选定一个特殊块，而对于本问题，L型骨牌其实就是我们手动构造出来的特殊块了，因为每次划分为4份小棋盘，而其中一份必然是特殊块所在的，其余三个棋盘就没有特殊块了，因此需要为他们添加特殊块，问题来了，构造的特殊块应该放在哪里呢？实际上，放在三个棋盘的交接处即可，这样也就构造了L型骨牌，依次类推..最终一定能填满。</p><p>最复杂的就是分析交接处，要判断不同的象限，将特殊块放在不同的位置：右下，左下，右上，左上。但其实在构造的过程中很容易发现规律，发现规律后就可以直接套了，规律见注释<code>确定是否+1</code>处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> Board[MAX][MAX];<br><span class="hljs-type">int</span> num= <span class="hljs-number">1</span>;<br><span class="hljs-comment">//棋盘问题总结，根据所在区域不同，确定不同操作。</span><br><span class="hljs-comment">//较复杂的是定位，但是在分析过程中，发现很多定位信息是共通的。</span><br><span class="hljs-comment">//脑海中要有草图，特别是三个临界点， 因此其实每种情况都可以根据草图由其他情况的坐标确定是否+1来决定</span><br><span class="hljs-comment">//关于坐标，不要想着x轴y轴，去想行和列，同一行，则行坐标不变，同一列，则列坐标不变！</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChessBoard</span><span class="hljs-params">(<span class="hljs-type">int</span> speRow, <span class="hljs-type">int</span> speCol, <span class="hljs-type">int</span> relaRow, <span class="hljs-type">int</span> relaCol, <span class="hljs-type">int</span> size)</span> </span>&#123;<br><span class="hljs-type">int</span> t=num++;<br><span class="hljs-type">int</span> smallSize = size / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//if在左上区域</span><br><span class="hljs-keyword">if</span> (speCol &lt; relaCol + smallSize <span class="hljs-keyword">and</span> speRow &lt; relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow, relaCol, smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在左上区域的右下角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow+smallSize<span class="hljs-number">-1</span>][relaCol+smallSize<span class="hljs-number">-1</span>] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize - <span class="hljs-number">1</span>, relaCol + smallSize - <span class="hljs-number">1</span>,relaRow,relaCol,smallSize);<br>&#125;<br><span class="hljs-comment">//if在右上区域</span><br><span class="hljs-keyword">if</span> (speCol &gt;= relaCol + smallSize <span class="hljs-keyword">and</span> speRow &lt; relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow, relaCol + smallSize,smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在右上区域的左下角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow + smallSize - <span class="hljs-number">1</span>][relaCol + smallSize] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize - <span class="hljs-number">1</span>, relaCol + smallSize, relaRow, relaCol + smallSize, smallSize);<br>&#125;<br><span class="hljs-comment">//if在左下区域</span><br><span class="hljs-keyword">if</span> (speCol &lt; relaCol + smallSize <span class="hljs-keyword">and</span> speRow &gt;= relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow + smallSize, relaCol, smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在左下区域的右上角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow + smallSize ][relaCol + smallSize - <span class="hljs-number">1</span>] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize, relaCol + smallSize - <span class="hljs-number">1</span>, relaRow + smallSize, relaCol, smallSize);<br>&#125;<br><span class="hljs-comment">//if在右下区域</span><br><span class="hljs-keyword">if</span> (speCol &gt;= relaCol + smallSize <span class="hljs-keyword">and</span> speRow &gt;= relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow + smallSize, relaCol + smallSize, smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在右下区域的左上角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow + smallSize][relaCol + smallSize ] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize, relaCol + smallSize, relaRow + smallSize, relaCol + smallSize, smallSize);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input size(),x,y:&quot;</span>;<br>cin &gt;&gt; size &gt;&gt; x &gt;&gt; y;<br>size = <span class="hljs-number">1</span> &lt;&lt; size;<br><span class="hljs-built_in">ChessBoard</span>(x, y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++)<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>) &lt;&lt; Board[i][j];<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环日程"><a href="#循环日程" class="headerlink" title="循环日程"></a>循环日程</h3><blockquote><p>n&#x3D;2<sup>k</sup>个选手，在n-1天内彼此都比赛一次，求日程表。</p><p>设表格行代表第i个 选手 行的下标从1开始，列代表天数 下标从0开始 那么日程二维表的第一列（下标为0）用来显示行号，以此来表示选手的编号，从第二列（下标为1）开始，元素值表示选手的对手，下标代表比赛的天数。</p><p>比如S[0][0] 代表第一个选手第0天 第0天没有意义 此时为第一列 不如填入选手的编号1</p><p>S[1][1]代表第二个选手第1天要对阵的人 S[4][6]代表第五个选手 第六天要对阵的人</p><p>为什么说此问题可以用递归解决呢，首先问题规模很小时，当然可以解决，于是第一个性质就满足了，那如何由小问题推出大问题呢？实际上本题的选手数为2的幂，因此选手规模只能成2倍的增长，而对于两倍的增长，这个二维表数据是可以复用的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 101</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> k;<br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> a[MAX][MAX];<span class="hljs-comment">//存放比赛日程表（行列下标为0的元素不用）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Plan</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,j,n,t,temp;<br>n=<span class="hljs-number">2</span>;<span class="hljs-comment">//n从2^1=2开始</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;   <span class="hljs-comment">//求解2个选手比赛日程,得到左上角元素</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>; a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (t=<span class="hljs-number">1</span>;t&lt;k;t++)<span class="hljs-comment">//迭代处理,依次处理2^2(t=1)…,2^k(t=k-1)个选手</span><br>&#123;<br>temp=n;<span class="hljs-comment">//temp=2^t</span><br>n=n*<span class="hljs-number">2</span>; <span class="hljs-comment">//n=2^(t+1)</span><br><span class="hljs-keyword">for</span> (i=temp+<span class="hljs-number">1</span>;i&lt;=n;i++ )<span class="hljs-comment">//填左下角元素</span><br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j&lt;=temp; j++)<br>a[i][j]=a[i-temp][j]+temp; <span class="hljs-comment">//左下角元素和左上角元素的对应关系</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=temp; i++)<span class="hljs-comment">//填右上角元素</span><br><span class="hljs-keyword">for</span> (j=temp+<span class="hljs-number">1</span>; j&lt;=n; j++)<br>a[i][j]=a[i+temp][(j+temp)% n];<br><span class="hljs-keyword">for</span> (i=temp+<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-comment">//填右下角元素</span><br><span class="hljs-keyword">for</span> (j=temp+<span class="hljs-number">1</span>; j&lt;=n; j++)<br>a[i][j]=a[i-temp][j-temp];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>k=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;k;<span class="hljs-comment">//n等于2的k次方即n=2^k</span><br><span class="hljs-built_in">Plan</span>(k);<span class="hljs-comment">//产生n个选手的比赛日程表</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-comment">//输出比赛日程表</span><br>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d&quot;</span>,a[i][j]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><blockquote><p>用dp最好 但还是介绍一下DC吧</p></blockquote><p>分析：对于一个序列，将它分为左右两边，那么那段最大连续子序列要么在纯左侧，要么在纯右侧，要么就横跨左右两侧，对于横跨左右两侧的情况，只需要从中点开始，往左右两侧蔓延判断即可。这是宏观上的划分。具体而言，真正能一口气确定要不要选择某个元素是在只有一个元素时，元素&gt;0就选择，否则就不选，当序列稍微有点长，就要开始斟酌了，但这是计算机需要考虑的，因为每一次递归，都要在divided的序列中求这三种情况，疯狂套娃，直到能轻而易举地conquer，最终再合并，就能conquer最终的大问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br><span class="hljs-keyword">return</span> c &gt; (a &gt; b ? a : b) ? c : (a &gt; b ? a : b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxSubSeq</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leftSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">rightSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">midSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">maxMid_leftSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">maxMid_rightSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">if</span> (low == high)<br>&#123;<br><span class="hljs-keyword">if</span> (a[low] &gt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> a[low];<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> mid = ( low + high )/ <span class="hljs-number">2</span>;<br>leftSum = <span class="hljs-built_in">MaxSubSeq</span>(a, low, mid );<br>rightSum = <span class="hljs-built_in">MaxSubSeq</span>(a, mid + <span class="hljs-number">1</span>, high);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mid_leftSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">mid_rightSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//i=mid 往左侧蔓延</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &gt;= low; i--)<br>&#123;<br>mid_leftSum += a[i];<br><span class="hljs-keyword">if</span> (mid_leftSum &gt; maxMid_leftSum)<br>maxMid_leftSum = mid_leftSum;<br>&#125;<br><span class="hljs-comment">//i=mid+1 往右侧蔓延</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid+<span class="hljs-number">1</span>; i &lt;= high; i++) &#123;<br>mid_rightSum += a[i];<br><span class="hljs-keyword">if</span> (mid_rightSum &gt; maxMid_rightSum)<br>maxMid_rightSum = mid_rightSum;<br>&#125;<br>midSum = maxMid_leftSum + maxMid_rightSum;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max3</span>(leftSum, rightSum, midSum);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a[] = &#123; <span class="hljs-number">-2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">13</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">-2</span> &#125;,n=<span class="hljs-number">6</span>;<br>cout &lt;&lt; <span class="hljs-built_in">MaxSubSeq</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><blockquote><p>求两个二进制的数的乘积（这两个二进制数很长很大）</p><p>分析：将两个二进制数分为两段。记这两个二进制数分别为A,B则要求A*B 可以把A的高n&#x2F;2位取出，记为a1，低n&#x2F;2位取出，记为a2，因此A&#x3D;a1*2<sup>n&#x2F;2</sup>+a2,同理B&#x3D;b1*2<sup>n&#x2F;2</sup>+b2,因此A*B&#x3D;(a1*2<sup>n&#x2F;2</sup>+a2)*(b1*2<sup>n&#x2F;2</sup>+b2)&#x3D;a1*b1*2<sup>n</sup>+(a1*b2+a2*b1)*2<sup>n&#x2F;2</sup>+a2*b2。</p><p>思路：</p><ol><li>初始化A B的字符串 并将字符串转为整数数组。</li><li>递归将两个数组分别拆为前后两段，代表高位和低位。出口：数组长度为1，此时可以计算出结果并返回给上一层。回归处理：将得到的四个结果转为10进制并做分析中的计算A*B&#x3D;(a1*2<sup>n&#x2F;2</sup>+a2)*(b1*2<sup>n&#x2F;2</sup>+b2)&#x3D;a1*b1*2<sup>n</sup>+(a1*b2+a2*b1)*2<sup>n&#x2F;2</sup>+a2*b2；再将该结果转换为2进制。层层返回，最终得到一个二进制的结果。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求解大整数乘法的算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 2000<span class="hljs-comment">//最多的位数</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Left</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> B[],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//取A的左边（高位）n/2位</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<br>B[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i=n/<span class="hljs-number">2</span>;i&lt;=n;i++)<br>B[i-n/<span class="hljs-number">2</span>]=A[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Right</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> B[],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//取A的右边（低位）n/2位</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<br>B[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)<br>B[i]=A[i];<br>B[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">Trans2to10</span><span class="hljs-params">(<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//二进制数转换成十进制数</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> s=A[<span class="hljs-number">0</span>],x=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;MAXN;i++)<br>&#123;x=<span class="hljs-number">2</span>*x;<br>s+=A[i]*x;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Trans10to2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//将十进数转换成二进制数</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x&gt;<span class="hljs-number">0</span>)<br>&#123;A[j]=x%<span class="hljs-number">2</span>;j++;<br>x=x/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (i=j;i&lt;MAXN;i++)<br>A[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//从高位到低位输出二进制数A</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=MAXN<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,A[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MULT</span><span class="hljs-params">(<span class="hljs-type">int</span> X[],<span class="hljs-type">int</span> Y[],<span class="hljs-type">int</span> Z[],<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//求Z=X*Y</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> e,e1,e2,e3,e4;<br><span class="hljs-type">int</span> A[MAXN],B[MAXN],C[MAXN],D[MAXN];<br><span class="hljs-type">int</span> m1[MAXN],m2[MAXN],m3[MAXN],m4[MAXN];<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<span class="hljs-comment">//Z初始化为0</span><br>Z[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<span class="hljs-comment">//递归出口</span><br>&#123;<span class="hljs-keyword">if</span> (X[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span> &amp;&amp; Y[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)Z[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> Z[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<span class="hljs-built_in">Left</span>(X,A,n);<span class="hljs-comment">//A取X的左边n/2位</span><br><span class="hljs-built_in">Right</span>(X,B,n);<span class="hljs-comment">//B取X的右边n/2位;</span><br><span class="hljs-built_in">Left</span>(Y,C,n);<span class="hljs-comment">//C取Y的左边n/2位;</span><br><span class="hljs-built_in">Right</span>(Y,D,n);<span class="hljs-comment">//D取Y的右边n/2位;</span><br><span class="hljs-built_in">MULT</span>(A,C,m1,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m1=AC</span><br><span class="hljs-built_in">MULT</span>(A,D,m2,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m2=AD</span><br><span class="hljs-built_in">MULT</span>(B,C,m3,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m3=BC</span><br><span class="hljs-built_in">MULT</span>(B,D,m4,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m4=DB</span><br>e1=<span class="hljs-built_in">Trans2to10</span>(m1);<span class="hljs-comment">//将m1转换成十进制数e1</span><br>e2=<span class="hljs-built_in">Trans2to10</span>(m2);<span class="hljs-comment">//将m2转换成十进制数e2</span><br>e3=<span class="hljs-built_in">Trans2to10</span>(m3);<span class="hljs-comment">//将m3转换成十进制数e3</span><br>e4=<span class="hljs-built_in">Trans2to10</span>(m4);<span class="hljs-comment">//将m4转换成十进制数e4</span><br>e=e1*(<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n)+(e2+e3)*(<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n/<span class="hljs-number">2</span>)+e4;<br><span class="hljs-built_in">Trans10to2</span>(e,Z);<span class="hljs-comment">//将e转换成二进制数Z</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//将字符串a转换为整数数组A</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>A[i]=<span class="hljs-built_in">int</span>(a[n<span class="hljs-number">-1</span>-i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">for</span> (i=n;i&lt;MAXN;i++)<br>A[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">long</span> e;<br><span class="hljs-type">char</span> a[]=<span class="hljs-string">&quot;10101100&quot;</span>;<span class="hljs-comment">//两个参与运算的二进制数</span><br><span class="hljs-type">char</span> b[]=<span class="hljs-string">&quot;10010011&quot;</span>;<br><span class="hljs-type">int</span> X[MAXN],Y[MAXN],Z[MAXN];<br><span class="hljs-type">int</span> n=<span class="hljs-number">8</span>;<br><span class="hljs-built_in">trans</span>(a,n,X);<span class="hljs-comment">//将a转换成整数数组X</span><br><span class="hljs-built_in">trans</span>(b,n,Y);<span class="hljs-comment">//将b转换成整数数组Y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;X:&quot;</span>); <span class="hljs-built_in">disp</span>(X);<span class="hljs-comment">//输出X</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Y:&quot;</span>); <span class="hljs-built_in">disp</span>(Y);<span class="hljs-comment">//输出Y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Z=X*Y\n&quot;</span>);<br><span class="hljs-built_in">MULT</span>(X,Y,Z,n);<span class="hljs-comment">//求Z=X*Y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Z:&quot;</span>); <span class="hljs-built_in">disp</span>(Z);<span class="hljs-comment">//输出Z</span><br>e=<span class="hljs-built_in">Trans2to10</span>(Z);<span class="hljs-comment">//将Z转换成十进制数e</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Z对应的十进制数:%ld\n&quot;</span>,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;验证正确性:\n&quot;</span>);<br><span class="hljs-type">long</span> x,y,z;<br>x=<span class="hljs-built_in">Trans2to10</span>(X);<span class="hljs-comment">//将X转换成十进制数x</span><br>y=<span class="hljs-built_in">Trans2to10</span>(Y);<span class="hljs-comment">//将X转换成十进制数y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;X对应的十进制数x:%ld\n&quot;</span>,x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Y对应的十进制数y:%ld\n&quot;</span>,y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z=x*y\n&quot;</span>);<br>z=x*y;<span class="hljs-comment">//求z=x*y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果z:%d\n&quot;</span>,z);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思路：</p><blockquote><p>宏观划分（在这里不需要思考太多具体实现）</p><p>递归出口（问题在什么地步可以轻而易举地解决）</p><p>问题合并（大问题是怎样由小问题得到的）</p></blockquote><p>这三大步分别从大问题 小问题 和大问题与小问题之间的联系 着手考虑，好美的思想，有点哲学惹…</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>分治</tag>
      
      <tag>DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Backtrack</title>
    <link href="/2023/11/22/Backtrace/"/>
    <url>/2023/11/22/Backtrace/</url>
    
    <content type="html"><![CDATA[<h1 id="Backtrack"><a href="#Backtrack" class="headerlink" title="Backtrack"></a>Backtrack</h1><blockquote><p>后悔药，时光机…没有什么最优解，只是遍历了所有时空才确定了你。</p></blockquote><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="递归和非递归"><a href="#递归和非递归" class="headerlink" title="递归和非递归"></a>递归和非递归</h3><p>回溯法可由递归和非递归方式实现，根据问题性质是排列还是集合，也可以抽象出对应的模板。<br>非递归回溯需要设计额外的数据结构来保存节点。</p><h3 id="排列与子集"><a href="#排列与子集" class="headerlink" title="排列与子集"></a>排列与子集</h3><p>问题的解空间树有两种类型。若问题为从含n个元素的集合S中找出符合某约束的元素的集合，此为<strong>子集树</strong>，比如求子集问题；若问题为从含n个元素的集合S从，找出满足约束的n个元素的排列，此为<strong>排列树</strong>，比如求全排列问题。</p><h4 id="幂集问题"><a href="#幂集问题" class="headerlink" title="幂集问题"></a>幂集问题</h4><p>分析：设定一个数组bool choose[n]表示这n个对应的元素是否被选了，因此对于n个元素，从第一个元素开始，若选中了，则置choose[i]&#x3D;1;直到处理完最后一个元素，输出这组结果，然后回溯上一层…</p><p>建模：</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/21/b6461ba45eeeb71f.png"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//now：当前处理的元素 last：数组末尾元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">bool</span> c[],<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now &gt;= last) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&#123; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; last; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (c[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt; a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>c[now] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(a, c, now + <span class="hljs-number">1</span>, last);<br>c[now] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(a, c, now + <span class="hljs-number">1</span>, last);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input array length:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-type">bool</span>* choose = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;input array elements:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; array[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(array,choose,<span class="hljs-number">0</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><p>分析：从数组首元素开始处理，让他与自己交换位置，然后处理交换位置后的元素，让他与自己交换…最终处理到最后一个元素，由于是与自身交换位置，此时的序列不会有任何改变，因为没有后继元素了，则输出该序列然后回溯到上一层，处理倒数第二的元素，这次让他与倒数第一的元素交换位置（而非自身），此时进入下一层，处理末元素，又得到一组结果，然后再回溯到上上层…</p><p>建模：</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/21/3ef8173d66043f60.png"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//now：当前处理的元素 last：数组末尾元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now == last)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; last; i++)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//在这里回溯了</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt; last; i++)<br>&#123;<br><span class="hljs-built_in">swap</span>(a[now], a[i]);<br><span class="hljs-built_in">dfs</span>(a, now + <span class="hljs-number">1</span>, last);<br><span class="hljs-built_in">swap</span>(a[now], a[i]);<span class="hljs-comment">//当回到当前层，还需要换回，保证是当前处理的元素与后续元素分别交换。再进入下一次循环。</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input array length:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input array elements:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; array[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(array, <span class="hljs-number">0</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>比较：</p><p>排列树的决策是交换，恢复是换回，子集树的决策是选择是否，恢复是做出另一选择。另外，问题也有维度之分，多维问题，除了dfs本身的层数外，在主要决策处也会有循环试探：N皇后，任务分配。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>为了提高回溯法的时间效率，常常要考虑剪枝，进一步涉及到左子树的剪枝和右子树的剪枝：<br>对于右子树的剪枝，一般还要额外设置一个函数参数rightIndex。<br>左子树：一般是无法满足的条件：比如背包问题中剩余重量不够用。<br>右子树：一般是不用判断，一定满足的条件：比如背包问题中即使后续全选也不会超重。<br>对于复杂问题，还要专门写出一个剪枝函数prune：比如活动安排问题中的剪枝函数：</p><h3 id="回溯和深度遍历"><a href="#回溯和深度遍历" class="headerlink" title="回溯和深度遍历"></a>回溯和深度遍历</h3><p>可以简略地认为<code>backtrace=dfs with pruning.</code>他们本来就很暧昧~</p><h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p> 可以抽象为子集问题，回溯于：是否选择某物品。</p><blockquote><p>分析：约束在于总重，优化在于价值。决策将会影响重量和价值，只需要遍历所有的决策组合，约束和优化在最后一层判断。将决策与约束和优化分离后就会清晰很多。感觉不如dp…效率。但是思想也很美~</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> W = <span class="hljs-number">6</span>;<br><span class="hljs-comment">//下标为0不考虑，便于叙述 第N个背包和数组下标</span><br><span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">//最优选择方案和最大价值</span><br><span class="hljs-type">bool</span> choose[n+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> maxValue=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//layer:解集树层次，即正在第LAYER个物品。</span><br><span class="hljs-comment">//nowChoose现在的选择方案</span><br><span class="hljs-comment">//nowWeight现在的总重量 nowValue现在的总价值</span><br><span class="hljs-comment">//leftWeights:剩下的背包的重量，用于剪枝.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">bool</span> nowChoose[], <span class="hljs-type">int</span> nowWeight, <span class="hljs-type">int</span> nowValue,<span class="hljs-type">int</span> leftWeights)</span> </span>&#123;<br><span class="hljs-comment">//n个物品，对每个物品依次进行抉择，最多讨论n层。n层后定结论</span><br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-keyword">if</span> (nowWeight == W <span class="hljs-keyword">and</span> nowValue &gt; maxValue) &#123;<br>maxValue = nowValue;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>choose[i] = nowChoose[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//当前总重量加上此物品的重量若&gt;最大能容纳的重量,则不能选这个物品！直接跳过</span><br>nowChoose[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (nowWeight+w[layer]&lt;=W) <br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>, nowChoose, nowWeight + w[layer], nowValue + v[layer],leftWeights-w[layer]);<br><span class="hljs-comment">//实际上想表达：若剩下的所有物品的总重量与当前重量的和都要小于最大能容纳的重量，</span><br><span class="hljs-comment">//那为了最大价值，自然是希望狂拿的，反正也不会超重.就不会再考虑不拿的情况了.</span><br>nowChoose[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (nowWeight+leftWeights &gt;= W) <br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>, nowChoose, nowWeight, nowValue,leftWeights-w[layer]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> nowChoose[n + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(nowChoose, <span class="hljs-literal">false</span>, n + <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> leftWeight = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>leftWeight += w[i];<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, nowChoose, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,leftWeight);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;choose tactic:&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (choose[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;object&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; value: &quot;</span> &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot; weight: &quot;</span> &lt;&lt; w[i];<br>&#125;<br>cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;maxValue:&quot;</span> &lt;&lt; maxValue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="装载和复杂装载"><a href="#装载和复杂装载" class="headerlink" title="装载和复杂装载"></a>装载和复杂装载</h3><blockquote><p>一般装载问题：n个集装箱要装入载重为W的轮船，每个箱子重量：w<sub>i</sub> 求最佳装载方案。</p><p>分析：每个货物选或不选。不如背包问题。。。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> limitedWeight = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[N + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-type">int</span> maxWeight = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> choose[N + <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">bool</span> c[],<span class="hljs-type">int</span> nowWeight,<span class="hljs-type">int</span> leftWeight)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; N) &#123;<br><span class="hljs-keyword">if</span> (nowWeight &gt; maxWeight &amp;&amp; nowWeight&lt;=limitedWeight) &#123;<br>maxWeight = nowWeight;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>choose[i] = c[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>c[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (nowWeight + w[layer] &lt;= limitedWeight) <br><span class="hljs-built_in">dfs</span>(layer+<span class="hljs-number">1</span>,c,nowWeight+w[layer],leftWeight-w[layer]);<br>c[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (nowWeight+leftWeight&gt;limitedWeight) <br><span class="hljs-built_in">dfs</span>(layer+<span class="hljs-number">1</span>,c,nowWeight,leftWeight-w[layer]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> nowChoose[N+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(nowChoose, <span class="hljs-literal">false</span>, N+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, N+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> leftWeight = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>leftWeight += w[i];<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,nowChoose,<span class="hljs-number">0</span>,leftWeight);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) <br><span class="hljs-keyword">if</span>(choose[i])<br>cout &lt;&lt; <span class="hljs-string">&quot;\nobject &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; selected,weight:&quot;</span> &lt;&lt; w[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;\nEngross: &quot;</span> &lt;&lt; maxWeight;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>复杂装载问题：若有两艘船，找出方案使得所有货物能被运走。在一般装载问题的基础上，先只考虑承重大的那艘船，记为船A，尽可能多地装载，对于没有选中的货物默认装载在第二艘船，记为船B，最终再判断船B能否承受剩余的货物，若能则方案可行，否则没有任何方案能够做到带走这些货物。难点在于证明这个思路的正确性：</p><p>反证法：假如能够运走所有货物，但船A却不是最佳方案（承重尽可能最大）。</p><p>货物总重不变，记最终方案中：船A装载货物总重为L<sub>a</sub>，船B为L<sub>b</sub>，L<sub>a</sub>+L<sub>b</sub>&#x3D;&#x3D;&#x3D;Sum(W<sub>i</sub>) ,如果方案行得通，说明船B能承受L<sub>b</sub>，那对于比L<sub>b</sub>更小的它自然也能承受，而此时完全可以把货物调度到船A上。</p><p>有了思路后实现就很简单了，在原来的基础上修饰一下就好了。我就不写了，欣赏下书上的写法吧！(#^_^#)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 20<span class="hljs-comment">//最多集装箱个数</span></span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> w[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">40</span> &#125;;<span class="hljs-comment">//各集装箱重量,不用下标0的元素</span><br><span class="hljs-type">int</span>n = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> c1 = <span class="hljs-number">50</span>, c2 = <span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> maxw = <span class="hljs-number">0</span>;<span class="hljs-comment">//存放第一艘轮船最优解的总重量</span><br><span class="hljs-type">int</span> x[MAXN];<span class="hljs-comment">//存放第一艘轮船最优解向量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> tw, <span class="hljs-type">int</span> rw, <span class="hljs-type">int</span> op[], <span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//求第一艘轮船的最优解</span><br>&#123;<br><span class="hljs-keyword">if</span> (i &gt; n)<span class="hljs-comment">//找到一个叶子结点</span><br>&#123;<br><span class="hljs-keyword">if</span> (tw &lt;= c1 &amp;&amp; tw &gt; maxw)<br>&#123;<br>maxw = tw;<span class="hljs-comment">//找到一个满足条件的更优解,保存它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-comment">//复制最优解</span><br>x[j] = op[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//尚未找完所有集装箱</span><br>&#123;<br>op[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//选取第i个集装箱</span><br><span class="hljs-keyword">if</span> (tw + w[i] &lt;= c1)<span class="hljs-comment">//左孩子结点剪枝：装载满足条件的集装箱</span><br>dfs(tw + w[i], rw - w[i], op, i + <span class="hljs-number">1</span>);<br>op[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//不选取第i个集装箱,回溯</span><br><span class="hljs-keyword">if</span> (tw + rw &gt; c1)<span class="hljs-comment">//右孩子结点剪枝</span><br>dfs(tw, rw - w[i], op, i + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dispasolution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//输出一个解</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (x[j] == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t将第%d个集装箱装上第一艘轮船\n&quot;</span>, j);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t将第%d个集装箱装上第二艘轮船\n&quot;</span>, j);<br><br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span><span class="hljs-comment">//求解复杂装载问题</span><br>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//累计第一艘轮船装完后剩余的集装箱重量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (x[j] == <span class="hljs-number">0</span>)<br>sum += w[j];<br><span class="hljs-keyword">if</span> (sum &lt;= c2)<span class="hljs-comment">//第二艘轮船可以装完</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//第二艘轮船不能装完</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> op[MAXN];<span class="hljs-comment">//存放临时解</span><br><span class="hljs-built_in">memset</span>(op, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(op));<br><span class="hljs-type">int</span> rw = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>rw += w[i];<br>dfs(<span class="hljs-number">0</span>, rw, op, <span class="hljs-number">1</span>);<span class="hljs-comment">//求第一艘轮船的最优解</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果\n&quot;</span>);<br><span class="hljs-keyword">if</span> (solve())<span class="hljs-comment">//输出结果</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    最优方案\n&quot;</span>);<br>dispasolution(n);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    没有合适的装载方案\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p>典中典。抽象为子集问题。回溯在于某坐标是否放置了皇后，难点在于建模，这个问题只有在第一次见的时候会觉得无从下手。</p><blockquote><p>分析：问题建模，用一维数组就可以描述棋盘，下标是行，元素值为列，下标+元素值确定一个坐标。用二维数组也可以，但是不简洁而且浪费空间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">total</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;No.&quot;</span> &lt;&lt; ++total&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (chess[i] != j)<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&quot;O&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlace</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//同对角线的处理:|x2-x1|==|y2-y1|!!!! 千万不要写成了|x1-y1|==|x2-y2|!!!</span><br><span class="hljs-comment">//后者在正对角线（\，捺）成立是最恶心的，对左对角线不成立！！！！！</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++)<br><span class="hljs-keyword">if</span> (chess[i]==y || (<span class="hljs-built_in">abs</span>(i-x)==<span class="hljs-built_in">abs</span>(chess[i]-y)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> layer, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n)<br><span class="hljs-built_in">display</span>(chess,n);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;n;i++ )<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">canPlace</span>(chess, n, layer - <span class="hljs-number">1</span>, i))<br>&#123;<br>chess[layer - <span class="hljs-number">1</span>] = i;<br><span class="hljs-built_in">dfs</span>(chess, layer + <span class="hljs-number">1</span>, n);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input N:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-comment">//一维数组作为棋盘，下标为行，元素值为列</span><br><span class="hljs-type">int</span>* chess = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-built_in">dfs</span>(chess,<span class="hljs-number">1</span>,n);<br>cout &lt;&lt; <span class="hljs-string">&quot;Engross:&quot;</span> &lt;&lt; total&lt;&lt;<span class="hljs-string">&quot; solutions&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Sum100"><a href="#Sum100" class="headerlink" title="Sum100"></a>Sum100</h3><blockquote><p>设计一个算法在1,2,3..9(顺序不能变)数字之间插入 + 或 - 或什么也不插，使得计算结果为100，并输出所有方案。</p><p>分析：输出时机：处理完9且所得结果为100。决策：+ - 空。回溯点：处理完9但结果不为100.<br>三选一的子集问题抽象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">9</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span> op[],<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> preAdd,<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> layer)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer == N)<br>&#123;<br><span class="hljs-keyword">if</span> (sum == <span class="hljs-number">100</span>)<br>&#123;<br>cout &lt;&lt; a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++) &#123;<br><span class="hljs-keyword">if</span> (op[j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>cout &lt;&lt; op[j];<br>cout &lt;&lt; a[j];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot; = 100\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>op[layer] = <span class="hljs-string">&#x27;+&#x27;</span>;<br>sum += a[layer];<br><span class="hljs-built_in">dfs</span>(op, sum, a[layer], a, layer + <span class="hljs-number">1</span>);<br>sum -= a[layer];<span class="hljs-comment">//恢复状态 回溯处理</span><br>op[layer] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>sum -= a[layer];<br><span class="hljs-built_in">dfs</span>(op, sum, -a[layer], a, layer + <span class="hljs-number">1</span>);<br>sum += a[layer];<span class="hljs-comment">//恢复状态 回溯处理</span><br>op[layer] = <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">//重点：怎么使得：-5_6=》-56 而5_6=》56 </span><br><span class="hljs-comment">//因此需要获取前面的值 为正：pre*10+now 为负：pre*10-now 同时 还要考虑对sum的影响 毕竟替换了一组值</span><br><span class="hljs-comment">//可以通过先减去preAdd，处理后形成新的preAdd，再加给sum即可</span><br>sum -= preAdd;<br><span class="hljs-type">int</span> newAdd=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (preAdd &gt; <span class="hljs-number">0</span>)<br>&#123;<br>newAdd = preAdd * <span class="hljs-number">10</span> + a[layer];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>newAdd = preAdd * <span class="hljs-number">10</span> - a[layer];<br>&#125;<br>sum += newAdd;<br><span class="hljs-built_in">dfs</span>(op, sum, newAdd, a, layer + <span class="hljs-number">1</span>);<br>sum -= newAdd;<span class="hljs-comment">//此时的恢复也需要引起重视</span><br>sum += preAdd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//要插入的运算符或者空操作可以用N-1长度数组存起来</span><br><span class="hljs-type">char</span> op[N];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>a[i] = i + <span class="hljs-number">1</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;result:\n&quot;</span>;<br><span class="hljs-comment">//从2开始处理，第一个要处理的操作符也是1和2之间的。</span><br><span class="hljs-built_in">dfs</span>(op, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">0</span>], a, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h3><blockquote><p>经典子集问题，比01背包还简单</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> aimSum = <span class="hljs-number">31</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">24</span>,<span class="hljs-number">7</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">bool</span> choose[],<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> nowSum,<span class="hljs-type">int</span> leftSum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-keyword">if</span> (nowSum == aimSum)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&#123;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (choose[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (nowSum+a[layer]&lt;=aimSum) &#123;<br>choose[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(choose,layer+<span class="hljs-number">1</span>,nowSum+a[layer],leftSum-a[layer]);<br>&#125;<br><span class="hljs-comment">//也就是说，如果当前处理的元素不选的话，且以后就算全选也达不到要求，那么就必须选！对于不选的方案，剪掉！</span><br><span class="hljs-comment">//注意！！就算不选，leftSum也要减，不选就是错过了，错过了就错过了。。至少在当前世界回不来了，~回溯触发平行时空O(∩_∩)O哈哈~~</span><br><span class="hljs-keyword">if</span> (nowSum+leftSum&gt;=aimSum) &#123;<br>choose[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(choose, layer + <span class="hljs-number">1</span>, nowSum, leftSum-a[layer]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> choose[n+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)<br>sum += a[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;tactics:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(choose, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h3><blockquote><p>n个任务n个人，人和任务的分配只能是1对1的，每个人处理每个任务花费不同，求出最优分配方案。</p><p>分析：可抽象为子集型问题。用二维数组存储任务对应的处理人的开销，再设1个一维bool数组存储任务是否分配了，1个一维数组people，下标为人员编号，元素值为任务编号。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> cost[N + <span class="hljs-number">1</span>][N + <span class="hljs-number">1</span>] = &#123;<br>&#123;<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> minCost = <span class="hljs-number">99999</span>;<br><span class="hljs-type">bool</span> work[N + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> peopleWithTask[N + <span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//layer表示处理的人员编号</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> nowCost,<span class="hljs-type">int</span> tactic[])</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; N) &#123;<br><span class="hljs-keyword">if</span> (nowCost &lt; minCost)<br>&#123;<br>minCost = nowCost;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N + <span class="hljs-number">1</span>; ++i)<br>peopleWithTask[i] = tactic[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//依次考虑任务1-N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i) &#123;<br><span class="hljs-keyword">if</span> (!work[i]) &#123;<br>work[i] = <span class="hljs-literal">true</span>;<br>tactic[layer] = i;<br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>,nowCost+cost[layer][i],tactic);<br>work[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//决策影响了work 和 tactic ，因此都要恢复。</span><br>tactic[layer] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//注意：如果这里把nowCost+=cost[][]后，才传入参数，则后面也需要恢复。</span><br><span class="hljs-comment">//这里直接把nowCost+cost[][]作为参数，则不用回复。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//最优解初始化</span><br><span class="hljs-built_in">memset</span>(work, <span class="hljs-literal">false</span>, N + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(peopleWithTask, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//临时解声明和初始化</span><br><span class="hljs-type">int</span> nowCost = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> nowPeopleWithTask[N + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(nowPeopleWithTask, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,nowCost,nowPeopleWithTask);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;allocation strategy：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>cout &lt;&lt; <span class="hljs-string">&quot;\ntask: &quot;</span> &lt;&lt; i &lt;&lt; <br><span class="hljs-string">&quot; allocated to peopel &quot;</span> &lt;&lt; peopleWithTask[i] &lt;&lt; <br><span class="hljs-string">&quot; costs for: &quot;</span> &lt;&lt; cost[i][peopleWithTask[i]];<br>cout &lt;&lt; <span class="hljs-string">&quot;\nEngross:&quot;</span> &lt;&lt; minCost;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="涂色"><a href="#涂色" class="headerlink" title="涂色"></a>涂色</h3><blockquote></blockquote><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><h3 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h3><blockquote><p>n个活动，每个活动有各自的开始时间和结束时间，活动串行，求最优安排方案——使得能安排最多数量的活动。即求出活动的排列。约束是排列合理（满足串行），优化是排列的数量尽可能多。感觉不如贪心…</p><p>分析：在主要决策体中，考虑活动layer—N，分别将layer与其后的活动交换位置，然后判断是否兼容，若兼容则选取更新兼容时间，进入下一层…当回溯到本层，换回位置，执行恢复。</p><p>慢到爆炸!对于活动安排问题还是去考虑贪心吧!!!</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Activity</span> &#123;<br><span class="hljs-type">int</span> begin;<br><span class="hljs-type">int</span> end;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">12</span>;<br>Activity activity[n + <span class="hljs-number">1</span>] = &#123; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">19</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">20</span>&#125;,&#123;<span class="hljs-number">10</span>,<span class="hljs-number">15</span>&#125;, &#123;<span class="hljs-number">8</span>,<span class="hljs-number">18</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">12</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">4</span>,<span class="hljs-number">14</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">9</span>&#125; &#125;;<br><span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> bestSequence[n + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-type">int</span> lastEnd = <span class="hljs-number">0</span>;<span class="hljs-comment">//上一个活动的结束时间</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sequence[n+<span class="hljs-number">1</span>]= &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//搜索活动问题最优解</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (i &gt; n)<span class="hljs-comment">//到达叶结点,产生一种调度方案</span><br>&#123;<br><span class="hljs-keyword">if</span> (sum &gt; maxSum)<br>&#123;<br>maxSum = sum;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>bestSequence[k] = sequence[k];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++)<span class="hljs-comment">//没有到达叶结点,考虑i到n的活动</span><br>&#123;<span class="hljs-comment">//第i层结点选择活动x[j]</span><br><span class="hljs-type">int</span> sum1 = sum;<span class="hljs-comment">//保存sum，laste以便回溯</span><br><span class="hljs-type">int</span> laste1 = laste;<br><span class="hljs-keyword">if</span> (activity[sequence[j]].begin &gt;= laste)<span class="hljs-comment">//活动x[j]与前面兼容</span><br>&#123;<br>sum++;<span class="hljs-comment">//兼容活动个数增1</span><br>laste = activity[sequence[j]].end;<span class="hljs-comment">//修改本方案的最后兼容时间</span><br>&#125;<br><span class="hljs-built_in">swap</span>(sequence[i], sequence[j]);<span class="hljs-comment">//排序树问题递归框架:交换x[i],x[j]</span><br><span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<span class="hljs-comment">//排序树问题递归框架:进入下一层</span><br><span class="hljs-built_in">swap</span>(sequence[i], sequence[j]);<span class="hljs-comment">//排序树问题递归框架:交换x[i],x[j]</span><br>sum = sum1;<span class="hljs-comment">//回溯</span><br>laste = laste1;<span class="hljs-comment">//即撤销第i层结点对活动x[j]的选择,以便再选择其他活动</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> nowSequence[n + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>nowSequence[i] = i;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (activity[bestSequence[i]].begin &gt;= end) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n Activity: &quot;</span> &lt;&lt; bestSequence[i] &lt;&lt;<br><span class="hljs-string">&quot; executed began in &quot;</span> &lt;&lt; activity[bestSequence[i]].begin &lt;&lt;<br><span class="hljs-string">&quot; ended in &quot;</span> &lt;&lt; activity[bestSequence[i]].end;<br>end = activity[bestSequence[i]].end;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\nEngross: &quot;</span>&lt;&lt;maxSum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流水线作业调度"><a href="#流水线作业调度" class="headerlink" title="流水线作业调度"></a>流水线作业调度</h3><blockquote><p>n个作业，都要先在机器M1再在M2上进行加工，不同任务在不同机器上加工时间有所不同，确定最佳加工顺序，使得从第一个任务在M1上开始到最后一个任务在M2上结束之间的时间间隔最短。</p><p>分析：可抽象为排列类的问题，求一种作业的排列，使得按这样的排列顺序得到的时间间隔最短。作业在M1上是连续的，只要上一个作业执行完毕后，下一个作业就可以去M1上执行了，但是M2的执行可能需要等待，当作业A在M1执行后，进入M2，作业B接着进入M1执行，可能会有作业B在M1上执行完了，作业A在M2上还在执行，因此M2上的时间不连续，存在<em><strong>等待时间</strong></em>.因此花在M2上的总时间需要利用数组，而M1不用。重点在于处理等待时间。若要等待，则当前作业i在m2上执行结束的时间time<sub>2</sub>[i]为：time<sub>2</sub>[i]&#x3D;time<sub>2</sub>[i-1]+m<sub>2</sub>[i]；若不需要等待,则为：time<sub>2</sub>[i]&#x3D;time<sub>1</sub>[i]+m<sub>2</sub>[i];而真正执行结束的时间应该取二者最大值。即：**time<sub>2</sub>[i]&#x3D;max{ time<sub>2</sub>[i-1]+m<sub>2</sub>[i] , time<sub>1</sub>[i]+m<sub>2</sub>[i] }**。稍微剪枝一下：若当前方案下的作业i的time2已经超过了之前记录的较优解，则可以直接剪掉了。进一步剪枝：记当前处理的作业为i，已知作业i的time<sub>2</sub>，则time<sub>2</sub>就是前i个作业全部执行完毕的时间，再记录他们在m2上花费的总时间iSum和所有作业在m2上的总时间allSum，则确定一个值：time<sub>2</sub>[i]+allSum-iSum.从i往后确定的每一种方案（叶节点）的最终完成时间一定大于等于该值。因此当确定出该值&gt;目前的bestTime就可以知道，接下来的所有叶子节点对应的值都不可能为打破当前的bestTime，因此可以直接剪掉。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f<span class="hljs-comment">//最大整数∞//最多的作业数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<span class="hljs-comment">//作业数</span><br><span class="hljs-comment">//int m1[n+1] = &#123; 0,5,12,4,8 &#125;;//M1上的执行时间,不用下标0的元素</span><br><span class="hljs-comment">//int m2[n+1] = &#123; 0,6,2,14,7 &#125;;//M2上的执行时间,不用下标0的元素</span><br><br><span class="hljs-comment">//验证升级后的剪枝函数重新设计用例，升级后的剪枝函数能够滤掉大于当前best的值</span><br><span class="hljs-comment">//但是不巧，上一组用例的依次求出的best正好都是递减的，42-36-34-33 因此不能过滤</span><br><span class="hljs-comment">//如果交换42 36 的位置就可以使得42被滤掉 因此根据方案挂了一下用例的顺序，发现成功了。</span><br><span class="hljs-type">int</span> m1[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span> &#125;;<br><span class="hljs-type">int</span> m2[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> bestTime;<span class="hljs-comment">//存放最优调度时间</span><br><span class="hljs-type">int</span> time1;<span class="hljs-comment">//M1的执行时间</span><br><span class="hljs-type">int</span> time2[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//M2的执行时间</span><br><span class="hljs-type">int</span> x[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//当前调度方案</span><br><span class="hljs-type">int</span> bestx[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//存放当前作业最佳调度</span><br><br><span class="hljs-type">int</span> allM2Sum = <span class="hljs-number">6</span> + <span class="hljs-number">2</span> + <span class="hljs-number">14</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span><span class="hljs-comment">//交换x和y</span><br>&#123;<br><span class="hljs-type">int</span> tmp = x;<br>x = y; y = tmp;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">disparr</span><span class="hljs-params">(<span class="hljs-type">int</span> x[])</span><span class="hljs-comment">//输出数组的元素</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x[i]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bound</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-type">int</span> iM2Sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>iM2Sum += m2[x[j]];<br><span class="hljs-keyword">return</span> time2[i] + allM2Sum - iM2Sum;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//从第i层开始搜索</span><br>&#123;<br><span class="hljs-keyword">if</span> (i &gt; n)<span class="hljs-comment">//到达叶结点,产生一种调度方案</span><br>&#123;<br><span class="hljs-keyword">if</span> (time2[n] &lt; bestTime)<span class="hljs-comment">//找到更优解</span><br>&#123;<br>bestTime = time2[n];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   一个解: bestf=%d&quot;</span>, bestTime);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 调度方案: &quot;</span>); disparr(x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, time2: &quot;</span>); disparr(time2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-comment">//复制解向量</span><br>bestx[j] = x[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++)<span class="hljs-comment">//没有到达叶结点,考虑i到n的作业</span><br>&#123;<br>time1 += m1[x[j]];<span class="hljs-comment">//在第i层选择执行作业x[j],在M1上执行完的时间</span><br>time2[i] = max(time1, time2[i - <span class="hljs-number">1</span>]) + m2[x[j]];<br><span class="hljs-comment">//if (time2[i] &lt; bestTime)//初步剪枝:仅仅扩展当前总时间小于bestf的结点</span><br>swap(x[i], x[j]);<br><span class="hljs-keyword">if</span>(bound(i)&lt;=bestTime)<span class="hljs-comment">//下界函数剪枝</span><br>&#123;<br><br>dfs(i + <span class="hljs-number">1</span>);<br><br>&#125;<span class="hljs-comment">//关于下界函数剪枝：他需要实时的x数组方案。因此当使用这种方式剪枝时，swap应该放在if外面。</span><br>swap(x[i], x[j]);<br>time1 -= m1[x[j]];<span class="hljs-comment">//回溯，即撤销第i层对作业x[j]的选择,以便再选择其他作业</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>time1 = <span class="hljs-number">0</span>;<br>bestTime = INF;<br><span class="hljs-built_in">memset</span>(time2, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(time2));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)  <span class="hljs-comment">//设置初始调度为作业1,2,…,n的顺序</span><br>x[k] = k;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解过程:\n&quot;</span>);<br>dfs(<span class="hljs-number">1</span>);<span class="hljs-comment">//从作业1开始搜索</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    最少时间: %d&quot;</span>, bestTime);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 最优调度方案: &quot;</span>);<br>disparr(bestx); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="见解"><a href="#见解" class="headerlink" title="见解"></a>见解</h2><p>在设计dfs时关于回溯恢复的考虑：如果将数据作为函数参数，则可以自动恢复，若不作为参数，而是全局变量，则要手动恢复。</p><h2 id="非递归回溯"><a href="#非递归回溯" class="headerlink" title="非递归回溯"></a>非递归回溯</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>回溯</tag>
      
      <tag>backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb基础实例1</title>
    <link href="/2023/11/20/JavaWebInstance/"/>
    <url>/2023/11/20/JavaWebInstance/</url>
    
    <content type="html"><![CDATA[<h1 id="员工部门管理系统——后端"><a href="#员工部门管理系统——后端" class="headerlink" title="员工部门管理系统——后端"></a>员工部门管理系统——后端</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>创建一个spring项目，添加4个依赖：spring web，mybatis framework，mysql driver，lombok。</li><li>数据库配置文件：application.properties:数据库连接经典四件套 和 两个经典mybatis优化配置 log和camelCase</li><li>MVC代码框架：<ol><li>pojo：Emp，Dept，Result</li><li>controller：@restController @autowired class:EmpController DeptController</li><li>service：@service interface:EmpService DepService class:EmpServiceImp DeptServiceImp</li><li>mapper：@mapper interface</li><li>mapper.XML：执行动态SQL必不可少的文件</li></ol></li><li>其他：<ol><li>@Slf4j 用于类中日志操作</li><li>RequestMapping(“&#x2F;api”):设置统一父路径</li><li>@GetMapping @DeleteMapping @PostMapping @PutMapping 约束数据交流方法</li><li>@data @allArgxxx @noArgxxx </li><li>动态SQL的相关知识点：各种标签的使用和处理</li></ol></li><li>注：代码初步框架如上，但在开发过程中，为了实现需求，还会增加其他的类和依赖和配置文件。</li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>实现员工-部门的小型后台管理系统：</p><blockquote><ol><li>实现员工和部门的增删查改；</li><li>登录校验和异常处理。</li></ol></blockquote><p>具体分析：</p><ol><li>为了完成员工和部门的增删查改。<strong>动态SQL</strong>是必须的，因此在上述代码框架中还要增加相应的XML文件完成动态SQL。员工的属性有头像，因此涉及到<strong>文件的上传</strong>，可以考虑用本地存储或阿里云OSS，若为阿里云OSS还必须创建aliOSSUtil类，两种方法都要创建一个uploadController来完成上传文件的控制。<strong>分页查询</strong>也是必要的，因此需要创建一个PageBean类存储返回的数据和数据条目数。</li><li>为了完成登录校验，可以利用JWT和拦截器，因此需要一个jwt的工具类专门来生成和转换jwt，需要一个登录拦截器类和拦截器的注册类，而登录操作也可以创建一个loginController。为了完成异常处理，定义一个全局异常处理类。</li><li>为了完成上述功能，除了定义额外的类，还需要必要的依赖和配置文件。而这些都是在具体的开发过程中慢慢完善的。在本阶段先分析到这一步。</li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>考虑到需要返回信息给前端，因此可以设置一个返回结果类，封装返回码，状态和数据，数据直接用最泛的Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码，1 代表成功; 0 代表失败</span><br>    <span class="hljs-keyword">private</span> String msg;  <span class="hljs-comment">//响应信息 描述字符串</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//返回的数据</span><br><br>    <span class="hljs-comment">//增删改 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,data);<br>    &#125;<br>    <span class="hljs-comment">//失败响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,msg,<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由开发过程的分析：依次从controller,service interface,service class,mapping interface(or with XML)完成业务的实现。</p><h3 id="简短的增删查改（部门增删查改）"><a href="#简短的增删查改（部门增删查改）" class="headerlink" title="简短的增删查改（部门增删查改）"></a>简短的增删查改（部门增删查改）</h3><p>对于简短的增删查改，可以行云流水地实现在mapper层，不必写在xml中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">deptController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> deptService deptService;<br><br>    <span class="hljs-comment">//getMapping,对于get请求的映射 等价于---@RequestMapping(value = &quot;/depts&quot; , method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptList</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;查询所有部门数据&quot;</span>);<br>        List&lt;Dept&gt; deptList=deptService.deptList();<br>        <span class="hljs-keyword">return</span> Result.success(deptList);<br>    &#125;<br><br>    <span class="hljs-comment">//获取路径参数 pathVariable注解</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptDel</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;删除部门，id：&quot;</span>+id);<br>        deptService.deptDel(id);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptIns</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;添加部门:&quot;</span>+dept.getName());<br>        deptService.deptIns(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptMod</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;修改部门:&quot;</span>+dept.getId());<br>        deptService.deptMod(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个函数对应一种业务，从controller开始，层层定义，实现。具体实现中值得注意的地方有：</p><blockquote><ol><li>@RequestBody</li><li>@RequestMapping</li><li>Result.success()和Result.success(object)</li><li>特殊属性记得每次都更新：updateTime</li></ol></blockquote><p>当设计较为复杂的业务时：分页查询，动态sql，文件处理。可以按以下策略进行：</p><h3 id="动态增删查改（员工增删查改）"><a href="#动态增删查改（员工增删查改）" class="headerlink" title="动态增删查改（员工增删查改）"></a>动态增删查改（员工增删查改）</h3><p>对于“查”，不仅是动态的，而且是分页的。当数据很多的时候，总不能够全都塞在页面吧，因此要设计分页的机制。前端向后端提供页码和每页的大小。</p><p>后端根据页码和每页的大小，算出每页显示的元素的范围，用select limit完成操作。同时，前端尝尝还需要统计总的数据量给用户，因此需要用到sql中的count函数。后端将具体的信息和总的数据数返回给前端，这样一看，需要返回两种数据了，因此考虑专门设计一个类来返回这些数据。于是PageBean类由此诞生，当然，它属于pojo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageBean</span> &#123;<br><span class="hljs-comment">//    List&lt;Emp&gt; empList;</span><br>   <span class="hljs-comment">/* 这里不要用EmpList，因为将来所有的分页查询都会用到这个类，不能在这里限定泛型*/</span><br>    <span class="hljs-keyword">private</span> List rows;<br>    <span class="hljs-keyword">private</span> Long total;<br>&#125;<br></code></pre></td></tr></table></figure><p>那后端还需要获取到前端传过来的参数：页码，每页大小，并且考虑实际运用，还需要设定默认值从第一页开始默认页码为xx，这些业务的实现需要用到：</p><blockquote><p>@RequestParam(defaulValue&#x3D;“xxx”)</p></blockquote><p>再接着思考，查询时添加条件是完全必要的，动态添加条件更是重要，因此考虑动态sql，因此，为了一次实现，万金油的利用，如果可以的话，将所有表属性作为参数执行动态SQL将会是一劳永逸的。当然还是得结合实际情况，要是根本不可能去根据某些属性来查询，那就确实没必要编写含有它的动态SQL了。因此可以设计出如下的controller代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里是根据分页，姓名，性别，入职日期几个属性完成的条件查询</span><br><span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectEmpFilter</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span><br><span class="hljs-params">                                  String name, Short gender,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span><br>    &#123;<br>        log.info(<span class="hljs-string">&quot;条件查询对应的员工&quot;</span>);<br>        PageBean pageBean=empService.selectEmpFilter(page,pageSize,name,gender,begin,end);<br>        <span class="hljs-keyword">return</span> Result.success(pageBean);<br>    &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;ids&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delEmp</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer[] ids)</span>&#123;<br>        empService.delEmp(ids);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br></code></pre></td></tr></table></figure><p>对应的XML实现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.instance.mapper.empMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterRows&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.instance.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>            <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                    name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                    and gender = #&#123;gender&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                    and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>            limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<br>--             order by update_time desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>        select count(*) from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                and gender = #&#123;gender&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delEmp&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的几个点：</p><blockquote><ol><li><p>name like concat (‘%’,#{name},’%’) ：利用concat 既能实现拼接又能防止sql注入！</p></li><li><p>name !&#x3D;null and name!&#x3D;‘’ 这里是空的引号，千万不要加空格，否则会出现很<del>傻逼</del>的错误：NumberFormatException: For input string:“xx”&lt;-这里是你输入的name，他认为你输入了number；</p></li><li><p>最重要的还得是动态sql到底是如何实现的，那几个关键字一定要学会使用<foreach> <where> <if>……</p></li><li><p>还有一点就是XML建立时，确定对应的函数的那几个对应，一定也要记住；</p></li><li><p>对于日期的处理，可以使用@DateTimeFormat(pattern&#x3D;“yyyy-MM-dd”)来规范，前端不按照这个格式传，就会返回对应的提示警告。</p></li></ol></blockquote><h3 id="文件上传（带头像的员工的增改）"><a href="#文件上传（带头像的员工的增改）" class="headerlink" title="文件上传（带头像的员工的增改）"></a>文件上传（带头像的员工的增改）</h3><p>上传文件，由于文件与其他一般数据不同，需要在前段端和后端都进行额外处理。</p><p>前端：form表格中 method&#x3D;“post” enctype&#x3D;“multipart&#x2F;form-data” input中type&#x3D;‘file’ name&#x3D;‘xxx(设为image)’</p><p>设置好这些后，前端通过post方法传给后端的body中就会包含一般数据和类型为MultipartFile的文件，名称为：xxx（image），后端接受时应保持名称的一致，若是非要不同，可以采用：@RequestParam(“image”) MultipartFile file)来映射名称。</p><p>为了实现文件上传，不如将其考虑为单独的一个controller层，因此设置：uploadController类，然后在这个类中编写相应的代码。</p><p>至此，后端可以接受到前端传来的文件数据，但若不将其存储下来，他将是ephemeral的，存放在本地，数据量少尚可如此，倘若数据量大了就不现实也不安全，可以考虑阿里云的oos服务。</p><blockquote><p>为文件上传专门定义一个接口，在添加或修改员工头像时调用并自动回显，这并不与添加或修改操作本身冲突，因为在选择文件的那瞬间就调用了upload接口，而另外的是另外的接口&#x2F;emps &#x2F;emps&#x2F;update</p></blockquote><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><p>先创建一个文件夹专门存放这些数据，在这里就已经提前想到了，可能会有同名文件的存在，可以通过uuid来解决这个问题。为了存放文件，必须知道（获取）文件的名称，大小，内容，输入流，和存储具体的方法。MultipartFile 常见方法中包括了这些： </p><blockquote><ul><li>String  getOriginalFilename();  &#x2F;&#x2F;获取原始文件名</li><li>void  transferTo(File dest);     &#x2F;&#x2F;将接收的文件转存到磁盘文件中</li><li>long  getSize();     &#x2F;&#x2F;获取文件的大小，单位：字节</li><li>byte[]  getBytes();    &#x2F;&#x2F;获取文件内容的字节数组</li><li>InputStream  getInputStream();    &#x2F;&#x2F;获取接收到的文件内容的输入流</li></ul></blockquote><p>还要考虑到文件大小，上传一个较大的文件(超出1M)时会报错，因为springBoot默认最大单个大小为1MB。</p><p>为了扩大一点，需要在application.properties中添加配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#配置单个文件最大上传大小</span><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-comment">#配置单个请求最大上传大小(一次请求可以上传多个文件)</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">100MB</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);<br>        <span class="hljs-comment">//获取原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>        <span class="hljs-comment">//构建新的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">extname</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<span class="hljs-comment">//文件扩展名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extname;<span class="hljs-comment">//随机名+文件扩展名</span><br>        <span class="hljs-comment">//将文件存储在服务器的磁盘目录</span><br>        image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/images/&quot;</span>+newFileName));<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可以进一步完成新增员工和修改员工的功能。</p><p>修改员工的实现：为了增强用户体验，在前端点击修改员工时，表格中应默认提供目前的员工信息，也就是要先返回一次按id的查询，然后再进行一次update操作，因此为了完成这一功能实际上要完成两部分，后端分别写与这些功能对应的接口即可，分别的调用由前端完成。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span><br>                username = #&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null and password != &#x27;&#x27;&quot;</span>&gt;</span><br>                password = #&#123;password&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>                name = #&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender = #&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null and image != &#x27;&#x27;&quot;</span>&gt;</span><br>                image = #&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job = #&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate = #&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id = #&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time = #&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;在empServiceImp中还应设置updateTime，对于这一点一定要注意，只要涉及改动就要默认更新updateTime，添加员工时还需要注意设置creteTime。</p><h4 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h4><p>可以创建一个util类，当然，不要忘记@component。</p><p>要提前购买和开通oss服务，创建一个bucket，这里有四个关键信息需要保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>; ---&gt;对应着外网访问的endpoint<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后再根据官方给出的示例程序，修改这四个信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;web-framework01&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);<br>        ossClient.putObject(bucketName, fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>若在项目中每涉及到一个第三方技术服务，就将其参数硬编码，那参数变化时要动源码，这是要避免的。难以寻找而且很不优雅。</p><h4 id="参数配置化"><a href="#参数配置化" class="headerlink" title="参数配置化"></a>参数配置化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#自定义的阿里云OSS配置信息</span><br><span class="hljs-attr">aliyun.oss.endpoint</span>=<span class="hljs-string">https://oss-cn-wuhan-lr.aliyuncs.com</span><br><span class="hljs-attr">aliyun.oss.accessKeyId</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.accessKeySecret</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.bucketName</span>=<span class="hljs-string">springbear-instance1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeyId;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br> <br> <span class="hljs-comment">//省略其他代码...</span><br> &#125; <br></code></pre></td></tr></table></figure><h4 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-attr">server.address</span>=<span class="hljs-string">127.0.0.1</span><br>=<span class="hljs-attr">&gt;</span><br><span class="hljs-attr">server</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">port</span>: <span class="hljs-string">8080</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-string">127.0.0.1 #注意数据和属性之间的空格！！</span><br></code></pre></td></tr></table></figure><p>可以看到配置同样的数据信息，yml格式的数据有以下特点：</p><ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心，重数据轻格式</li></ul><p>yml配置文件的基本语法：</p><blockquote><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul></blockquote><p>yml文件中常见的数据格式：</p><p>对象&#x2F;Map集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>数组&#x2F;List&#x2F;Set集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hobby:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">java</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">game</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">sport</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/tlias</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span><br>      <br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">aliyun:</span><br>  <span class="hljs-attr">oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">https://oss-cn-hangzhou.aliyuncs.com</span><br>    <span class="hljs-attr">accessKeyId:</span> <span class="hljs-string">LTAI4GCH1vX6DKqJWxd6nEuW</span><br>    <span class="hljs-attr">accessKeySecret:</span> <span class="hljs-string">yBshYweHOpqDuhCArrVHwIiBKpyqSL</span><br>    <span class="hljs-attr">bucketName:</span> <span class="hljs-string">web-397</span><br></code></pre></td></tr></table></figure><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>对于@value注解，当处理成批的配置文件属性时会很臃肿；可以通过@ConfigurationProperties注解来优化：</p><p>首先要在maven中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>需要创建一个实现类xxxProperties来专门存放这些配置信息，且实体类中的属性名和配置文件当中key的名字必须要一致</p><blockquote><p>比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter &#x2F; setter方法</p></blockquote></li><li><p>需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象</p></li><li><p>在实体类上添加<code>@ConfigurationProperties</code>注解，并通过perfix属性来指定配置参数项的前缀</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AliOSSProperties.java</span><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*阿里云OSS相关配置*/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSProperties</span> &#123;<br>    <span class="hljs-comment">//区域</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-comment">//身份ID</span><br>    <span class="hljs-keyword">private</span> String accessKeyId ;<br>    <span class="hljs-comment">//身份密钥</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret ;<br>    <span class="hljs-comment">//存储空间</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完成的AliOSSUtils工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//当前类对象由Spring创建和管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-comment">//注入配置参数实体类对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AliOSSProperties aliOSSProperties;-----------&gt;把原来的各种属性改成了专门存储属性的类<br>   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),<br>                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());<br>        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span>aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="hljs-string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>还可以通过设置环境变量来完成配置文件的处理。环境变量是在操作系统级别设置的全局变量。它们包含有关操作系统和正在运行的应用程序的信息。应用程序可以读取环境变量以获取配置参数。在大多数操作系统中，可以使用特定的命令来设置和获取环境变量。例如，在Linux和Mac上，可以使用<code>export</code>命令设置环境变量，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">MY_VAR</span>=value<br></code></pre></td></tr></table></figure><p>应用程序可以通过读取<code>MY_VAR</code>环境变量来获取值。</p><blockquote><p>关于配置文件的处理，无非是从程序的可维护性和安全性出发的。<del>非常好程序，这使我的屁股旋转。</del></p></blockquote><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>根据需求：在访问网站时，如果没有登录，则不能进入子路径url，这一点通过&#x3D;&#x3D;过滤器或拦截器&#x3D;&#x3D;来完成，也就是需要对除了&#x2F;login路径外的其他访问，在访问前进行拦截验证，如果已经登录了，则可以完成api的请求，否则不提供服务，为了识别是否登录过了，这一点通过&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;来完成。因此,“登录”不能仅仅只是执行一个查询检验那么简单。</p><h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><p>关于会话、会话跟踪，需要知道：</p><p>&#x3D;&#x3D;会话&#x3D;&#x3D;指的是浏览器与服务器之间的一次连接，我们就称为一次会话。</p><blockquote><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p><ul><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p><code>会话</code>:在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p></li><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p>第2次：访问的是部门管理接口，查询所有部门数据</p></li><li><p>第3次：访问的是员工管理接口，查询员工数据</p></li></ul><p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p></blockquote><p>&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p><blockquote><p>服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我就称为会话跟踪。</p></blockquote><p>使用会话跟踪技术就是要完成在同一个会话中多个请求之间数据的共享。</p><blockquote><p>为什么要共享数据呢？</p><p>由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享</p></blockquote><p>题外话：有没有想过在刷微博或者其他客户端软件时，你所看到的表象是你的账号会显示你所个性化的内容，而别人的账号显示的是别人的个性化内容（关注，粉丝等等等），这都是数据，根据你的ID，这些数据都已存入相应的表中了，根据你的id唯一标识，将这些绑定着id的个性化内容全部连根拔起显示给你。有没有想过为什么网页版会保持登录状态，这个就是会话跟踪技术实现的，他会在一定期限内保留住登录状态。</p><p>可以通过JWT,cookie,session来实现会话跟踪。</p><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>json web token（官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><ul><li><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</p><p>自包含：指的是jwt令牌，看似是一个随机的字符串，但是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</p><p>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</p></blockquote></li></ul><p>JWT的组成： （JWT令牌由三个部分组成，三个部分之间用点来分割）</p><ul><li><p>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”}</p></li><li><p>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”}</p></li><li><p>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。</p><blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，整个jwt令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败。</p></blockquote></li></ul><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>在生成JWT令牌时，会对JSON格式的数据进行一次编码————base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p><p>JWT令牌最典型的应用场景就是登录认证：</p><ol><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。</li><li>前端拿到jwt令牌之后，会将jwt令牌存储(浏览器localStorage)起来。在后续的每一次请求中都会将jwt令牌携带到服务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。</li></ol><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：</p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><p>为此定义一个工具类JWTutil。</p><p>当然，首先要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JWTutil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTutil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String signKey=<span class="hljs-string">&quot;springbear&quot;</span>;<br>    <span class="hljs-comment">//有效期30天</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30L</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genJWT</span><span class="hljs-params">(Map&lt;String,Object&gt; claims)</span>&#123;<br>        String jwt= Jwts.builder()<br>                .addClaims(claims)    <span class="hljs-comment">//自定义消息--有效载荷---有效载荷中存放什么数据也要和前端沟通好。这个项目中是id username 和 name</span><br>                .signWith(SignatureAlgorithm.HS256, signKey)    <span class="hljs-comment">//签名算法</span><br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis()+expire))<br>                .compact();<br>        <span class="hljs-keyword">return</span> jwt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseJWT</span><span class="hljs-params">(String jwt)</span>&#123;<br>        Claims claims=Jwts.parser()<br>                .setSigningKey(signKey)<br>                .parseClaimsJws(jwt)<br>                .getBody();<br>        <span class="hljs-keyword">return</span> claims;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在使用JWT令牌时需要注意：</p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。</li><li>如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。</li></ul><p>因此登录功能的实现又清晰了：登录成功则生成token，执行业务则校验token，若非法，则拦截，合法就放行。</p><p>具体在项目中：前端请求登录，先验证账密是否合法（select），如果登陆成功了，就生成JWT，并将其返回，并且这使得用户在一定时间段内（token有效期间且没有清理浏览器localstorage）不必重复进行登录验证。</p><p>登录功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> empService empService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">loginTry</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span>&#123;<br>        Emp empExist=empService.loginTry(emp);<br>        <span class="hljs-keyword">if</span>(empExist!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            Map&lt;String,Object&gt; claims=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            claims.put(<span class="hljs-string">&quot;id&quot;</span>,empExist.getId());<br>            claims.put(<span class="hljs-string">&quot;username&quot;</span>,empExist.getUsername());<br>            claims.put(<span class="hljs-string">&quot;name&quot;</span>,empExist.getName());<br>            <span class="hljs-comment">//假如登录成功，生成token（一个能被唯一转化的字符串）返回给前端，前端将会获取它并存储。</span><br>            <span class="hljs-comment">//在此后的操作，前端都会携带这个token来进行操作，只要token还在有效期，就能够放行，否则被拦截器拦截。</span><br>            String token=JWTutil.genJWT(claims);<br>            <span class="hljs-keyword">return</span> Result.success(token);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>cookie是客户端会话跟踪技术，存储在客户端浏览器中。用cookie来跟踪会话，可以在浏览器第一次发起服务器请求时，在服务器端来设置一个cookie。</p><p>比如第一次请求了登录接口，登录接口执行完成之后，就可以设置一个cookie，在cookie中就可以来存储用户相关的数据信息。比如在cookie中存储当前登录用户的用户名，ID。</p><p>服务器端给客户端响应数据时会<strong>自动</strong>将cookie响应给浏览器，浏览器接收到此cookie后，会<strong>自动</strong>将cookie的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的cookie<strong>自动</strong>地携带到服务端。</p><p>接下来服务端就可以获取到cookie的值。因此只需要判断这个cookie的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在，就说明客户端之前已经登录完成了。这样就可以基于cookie在同一次会话的不同请求之间来共享数据。</p><p>3个自动：</p><ul><li>服务器<strong>自动</strong>将cookie响应给浏览器。</li><li>浏览器接收到响应回来的数据之后，<strong>自动</strong>将cookie存储在浏览器本地。</li><li>在后续的请求当中，浏览器会<strong>自动</strong>将cookie携带到服务器端。</li></ul><p><strong>为什么这一切都是自动化进行的？</strong></p><p>因为cookie是HTTP协议中所支持的技术，而各大浏览器厂商都支持了这一标准。协议官方给我们提供了一个响应头和请求头：</p><ul><li>响应头 Set-Cookie ：设置Cookie数据</li><li>请求头 Cookie：携带Cookie数据</li></ul><p><strong>优缺点</strong></p><ul><li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带都由浏览器自动进行，无需手动操作）</li><li>缺点：<ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>服务器端会话跟踪技术，存储在服务器端的。Session就是基于Cookie来实现的</p><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案也就失效了。</p></blockquote><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>什么是拦截器？</p><ul><li>是一种动态拦截方法调用的机制，类似于过滤器。</li><li>拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。</li></ul><p>拦截器的作用：</p><ul><li>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。</li></ul><p>在拦截器中通常做一些通用性操作，比如：通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。</p><h5 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h5><p>在注册拦截器时要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>指定要拦截的请求路径，<code>excludePathPatterns</code>指定不拦截的请求路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//拦截器对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//注册自定义拦截器对象</span><br>        registry.addInterceptor(loginCheckInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<span class="hljs-comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<span class="hljs-comment">//设置不拦截的请求路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>基本使用主要包括：定义拦截器，注册拦截器。</p><p>定义拦截器：一个项目中可能有多个拦截器，不妨建立一个拦截器包，对于登录功能中的拦截，定义LoginInterceptor类,(别忘了@component),该类需要实现HandlerInterceptor，并重写其三个方法，特别是prehandle这一方法，他决定着能否放行，因此jwt的验证也在此方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        String token=request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span>(token==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//若存在 则验证合法性</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            JWTutil.parseJWT(token);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            log.info(<span class="hljs-string">&quot;非法token&quot;</span>);<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*分析此实例的流程：</span><br><span class="hljs-comment">* 1. 登录页面不拦截，其他页面拦截，这一点在注册拦截器时控制拦截路径实现。</span><br><span class="hljs-comment">* 2. 其他路径的资源请求，需要携带token(位于请求头中)来若不存在则拒绝并返回相应的信息(json)，若存在则进行验证，合法则放行，否则拒绝并返回相应信息。</span><br><span class="hljs-comment">* 注：为了实现object到json的转换，可以导入阿里的fastjson依赖</span><br><span class="hljs-comment">* 注：返回的erro信息也是有讲究的，不能瞎写，前端需要根据erro中的信息来重定向或者进行其他操作的。比如这里是not_longin,前端获取到就会执行重定向到登录页面</span><br><span class="hljs-comment">* */</span><br></code></pre></td></tr></table></figure><p>注册拦截器：定义一个类WebConfig，该类需要实现webMvcConfigurer，该类中需要重写addInterceptor方法，也是在此类中完成注册拦截器和拦截路径的设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<br>        <span class="hljs-comment">//为除了登录页外的其他页面注册拦截器。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h4><p>再次梳理登录业务：登录时，根据账密判断登录是否成功（select），成功则返回token和成功消息（jwt），否则返回错误信息，在token有效期内，该浏览器中的路径访问不会被阻拦（interceptor放行）。</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/20/b18f88897cc0af29.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>项目编写到这里，以为已经OK了？？实际上忽略了异常处理这一点，因此下次在设计项目时，可以提前考虑。</p><p>当添加部门或者员工时，如果客户端输入的重名了，而数据库又不能完成插入语句，如果没有异常处理，那么前后端将无法完成相应的错误操作，而用户也最好能够得到对应的解释或者哪怕只是简短的提示，也可以通过异常处理来实现，捕获异常后，后端向前端返回额外的消息，前端再经过处理提示给用户。</p><p>异常处理很简单，在每一处可能会出现异常的地方都try catch显然太杂乱臃肿。因此可以定义一个类，专门处理异常，即：全局异常处理器。</p><ol><li><p>定义全局异常处理器非常简单，定义一个类，为此类加上@RestControllerAdvice，加上这个注解就代表定义了一个全局异常处理器。</p></li><li><p>在类中定义一个方法来捕获异常，此方法需要加注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定要捕获异常的类型。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">//处理异常</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span> <span class="hljs-comment">//指定能够处理的异常类型</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception e)</span>&#123;<br>        e.printStackTrace();<span class="hljs-comment">//打印堆栈中的异常信息</span><br>        <span class="hljs-comment">//捕获到异常之后，响应一个标准的Result</span><br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;对不起,操作失败,请联系管理员&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</p><p>处理异常的方法返回值会转换为json后再响应给前端</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>实例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Mybatis</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue构建</title>
    <link href="/2023/11/20/VueStart/"/>
    <url>/2023/11/20/VueStart/</url>
    
    <content type="html"><![CDATA[<h1 id="Learning-Vue"><a href="#Learning-Vue" class="headerlink" title="Learning Vue"></a>Learning Vue</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>准备工作分为 大部分：1.初始化项目；2.安装其他依赖和插件；3.自动导入优化和联想</p></blockquote><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>进入文件夹，npm init vue@latest –npm install –进入VScode npm run dev</p><h3 id="安装依赖和插件"><a href="#安装依赖和插件" class="headerlink" title="安装依赖和插件"></a>安装依赖和插件</h3><p>npm i axios–npm i element-plus –save – npm i @element-plus&#x2F;icon-vue<br>npm install -D unplugin-vue-components unplugin-icons unplugin-auto-import :<br>对于ICON还需要注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementPlusIconsVue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@element-plus/icons-vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><span class="hljs-comment">//注册所有ICON图标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, component] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">ElementPlusIconsVue</span>)) &#123;<br>    app.<span class="hljs-title function_">component</span>(key, component)<br>&#125;<br></code></pre></td></tr></table></figure><p>注册完毕后，后续使用自动导入，因此不必再html页上作全局导入</p><h3 id="自动导入和联想"><a href="#自动导入和联想" class="headerlink" title="自动导入和联想"></a>自动导入和联想</h3><p>自动导入<strong>ele的组件和icon，vue的重要对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vite.config.js</span><br><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Icons</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">IconsResolver</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/resolver&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-keyword">const</span> pathSrc = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-comment">// Auto import functions from Vue, e.g. ref, reactive, toRef...</span><br>      <span class="hljs-comment">// 自动导入 Vue 相关函数，如：ref, reactive, toRef 等</span><br>      <span class="hljs-attr">imports</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>],<br><br>      <span class="hljs-comment">// Auto import functions from Element Plus, e.g. ElMessage, ElMessageBox... (with style)</span><br>      <span class="hljs-comment">// 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式)</span><br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br><br>        <span class="hljs-comment">// Auto import icon components</span><br>        <span class="hljs-comment">// 自动导入图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">prefix</span>: <span class="hljs-string">&#x27;Icon&#x27;</span>,<br>        &#125;),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;auto-imports.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-comment">// Auto register icon components</span><br>        <span class="hljs-comment">// 自动注册图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">enabledCollections</span>: [<span class="hljs-string">&#x27;ep&#x27;</span>],<br>        &#125;),<br>        <span class="hljs-comment">// Auto register Element Plus components</span><br>        <span class="hljs-comment">// 自动导入 Element Plus 组件</span><br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;components.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Icons</span>(&#123;<br>      <span class="hljs-attr">autoInstall</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br><br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: pathSrc<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h2><p>分为界面部分和逻辑部分，逻辑部分主要是axios的调用等</p><blockquote><p>界面部分：</p><ul><li>登录前页面：组件:暂无</li></ul><ol><li>登录</li><li>注册</li></ol><ul><li>登录后页面：组件:导航栏 footer</li></ul><ol><li>主页（信息编辑页） </li><li>事务页</li></ol></blockquote><p>###界面设计<br>在进行页面设计前，需要重写<em><strong>全局样式</strong></em>：global.css并导入到main.js中<br>一般要修改的有：app html body三个部分 p,m&#x3D;0;display:flex;height&#x3D;100vh等<br>否则将会出现页面混乱如无法控制布局，无法铺上背景等诸多问题<br>###登录界面设计<br>####mode1：单一卡片风</p><blockquote><p>1.外部容器存放背景图和内部容器</p><blockquote><p>2.卡片容器：通常包括卡片头header存放logo或欢迎语</p><blockquote><p>3.表单:主体部分</p></blockquote><ul><li>uid</li><li>psw</li><li>recap</li><li>login_btn</li><li>about&amp;register&amp;findPsw<br>4.说明：常常需要考虑居中和靠左靠右的布局问题：<br>居中：父元素display:flex;align-item:center;justify_content:center;<br>靠左靠右：父元素display:flex;justify_content:flex_end;靠右的子元素：margin-left:auto</li></ul></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus布局</title>
    <link href="/2023/11/20/Layout/"/>
    <url>/2023/11/20/Layout/</url>
    
    <content type="html"><![CDATA[<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><blockquote><p>先介绍布局思路，再介绍布局组件化</p></blockquote><h2 id="布局思路"><a href="#布局思路" class="headerlink" title="布局思路"></a>布局思路</h2><p>最重要的是关于el-container的理解：<br>el-container：当包含header或footer时会垂直排放子元素，否则水平，再利用多个container嵌套可以实现自己想要的布局：<br>比如我想要h a m式的布局head aside main</p><p>考虑container包括一个header和一个小的container<br>这样header和小container垂直<br>然后小container内包含aside和main aside和main水平</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>很多时候都是主要区域变化，导航区不变，因此很有必要在主要区域添加二级路由，将其他部分封装成组件比如LayoutHead LayoutAside，在ep中，由于container的性质已经规定好了（如上） 因此即使封装，也仍要在最外层写上container结构，然后对于具体的内容进行封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">//使用ep，为了工程化，目前可以封装成这样，在主界面还是要考虑编写最基本的框架，即嵌套的container，container的具体内容可以封装</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/home/components/LayoutHead.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutAside</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LayoutAside.vue&#x27;</span>;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutHead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutHead</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutAside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutAside</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 二级路由 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 设计思路：此处为localhost：3000/home，因此在路由home中设置children，然后在home.vue中对应的地方设置router-view --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-main</span>&gt;</span>    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如代码所示，即使把header封装成了layoutheader，但封装的是内容，外部的container没有封装进去，因此还要写上，即使封装进去了也不会实现，因为当使用组件时，在外部，他已经不具备container的性质了。也就要求在进行开发的时候，先确定好布局，写好容器排版，再将主要内容封装成组件并写在对应的位置。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus复习</title>
    <link href="/2023/11/20/EP_Use/"/>
    <url>/2023/11/20/EP_Use/</url>
    
    <content type="html"><![CDATA[<h1 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h1><h2 id="菜单（导航栏）"><a href="#菜单（导航栏）" class="headerlink" title="菜单（导航栏）"></a>菜单（导航栏）</h2><blockquote><p>Menu可以设计为导航栏，无论左侧还是顶部，放在对应的容器即可，下一次考虑导航栏的设计，可以采用此思路，设计好布局后，将menu组件放入对应的地方即可，这一次的设计不熟悉EP的组件，因此导航栏的设计并没有规划，导致走了不少弯路，自己也做了一些无用功。</p></blockquote><h3 id="菜单的使用技巧"><a href="#菜单的使用技巧" class="headerlink" title="菜单的使用技巧"></a>菜单的使用技巧</h3><blockquote><p>包括默认打开，折叠菜单，子菜单，菜单项组，打开方式（更多可以参见官网的API 此处给出一些常用的）（注意API的使用所能支持的模式）</p></blockquote><p>默认打开菜单：default-active；default-openeds<br>折叠菜单：collapse（vertical only）collapse-transition<br>子菜单（组件）：el-sub-menu<br>菜单项组（组件）：el-menu-item-group<br>打开方式：menu-trigger（horizontal only）：string(hover &#x2F; click)</p><blockquote><p>又发现了当折叠后，弹出子菜单选项的时间默认值有点慢，显得很卡不丝滑，因此更改响应时间是很有必要的<br>子菜单响应时间：show-timeout hide-timeout100ms不错</p></blockquote><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><blockquote><p>今天想要修改按钮的宽度，但ep并没有给出width属性，因此要么用style改，要么用vue控制style改，当然选择动态性的后者：<br>于是需要知道vue如何绑定style：</p></blockquote><blockquote><p>今天想通过行为更改按钮ICON 嘻嘻用v-if 代码如下</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;switchSize&quot;</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;&#123;width:Sidewidth&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Fold</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Expand</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>v-bind：style&#x3D;“{width：xxxx}”</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/2023/11/20/DP_TEXT/"/>
    <url>/2023/11/20/DP_TEXT/</url>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><blockquote><ol><li>dp数组设计和初始化 </li><li>状态转移方程设计 </li><li>举例并反推</li></ol></blockquote><span id="more"></span><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote><p>整数N分解成不超过K的自然数的和，求拆分方案的个数：</p></blockquote><p>分析：设有F(N,K)表示最终结果。容易知道：<code>F(1,x)=1 and F(x,1)=1</code><br>当N&lt;K 时：<code>F(N,K)=F(N,N)</code><br>当N&#x3D;K 时：可以考虑将整数就分解为他本身这一种方案 和 F(N,K-1) 有：<code>F(N,K)=1+F(N,K-1)</code><br>当N&gt;K 时：可以分类讨论拆分的数中是否包含K，若包含：则其余的数的和必然为:N-K 现在只需要考虑N-K如何拆分即可，故有：F(N-K,K)；若不包含：则拆分可以转变为：F(N,K-1) 有：<code>F(N,K)=F(N,K-1)+F(N-K,K)</code><br>因此：<img src="https://s3.bmp.ovh/imgs/2023/11/21/aa143084b1426144.png"><br>设DP[n][k]为答案。因此源程序如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">1</span>)<br>dp[i][j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; j)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - j][j];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j)<br>dp[i][j] = <span class="hljs-number">1</span> + dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i][i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>;<br>cin &gt;&gt; n&gt;&gt; k;<br><span class="hljs-built_in">solution</span>(n, k);<br>cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大连续子序列和问题"><a href="#最大连续子序列和问题" class="headerlink" title="最大连续子序列和问题"></a>最大连续子序列和问题</h2><blockquote><p>一段数字序列 求其中的最大连续和子序列</p></blockquote><p>分析：问题分成两部分：求值，构建具体的序列。<br>设dp[N]为包括Sequence[N-1]往前的最大连续子序列和。<br>关键在于找状态转移方程：<code>dp[N]=max&#123;dp[N-1]+Sequence[N-1],Sequence[N-1]&#125;</code><br>Sequence[N-1]为序列数组末尾元素。<br>且一定有边界条件：<code>dp[0]=0</code>,没有所谓的前0个元素，是从1开始确定的，这里只是个主观规定。</p><p>通过dp很容易求出最大连续子序列和，但是要考虑如何通过这个结果构造出具体的子序列.</p><blockquote><p><em><strong>从抽象入手总是困难，不妨设置一些用例来帮助分析，写算法就是如此，这样的用例可能无法覆盖所有的情况，所有就有了一个叫做debug的工作来完善你的算法思想。</strong></em></p></blockquote><p>设-2 11 -4 13 -5 -2<br>则dp[1]&#x3D;max{0-2，-2}&#x3D;-2；<br>dp[2]&#x3D;max{-2+11,11}&#x3D;11;<br>dp[3]&#x3D;max{11-4,-4}&#x3D;7;<br>dp[4]&#x3D;max{7+13,13}&#x3D;20;<br>dp[5]&#x3D;max{20-5,-5}&#x3D;15;<br>dp[6]&#x3D;max{15-2,-2}&#x3D;13.</p><p>最大的DP为20，最大子序列为11 -4 13。根据这个例子：若dp一开始为负数，则后来一旦出现正数，那么那个负数就不会再计入在最大子序列中，因此那个负数就是临界处。每一次dp的负数，都是对连续子序列的一次重新选择。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span>* s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>dp[i] = <span class="hljs-built_in">max</span>( dp[i - <span class="hljs-number">1</span>] + s[i],s[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> dpMax=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (dp[i] &gt; dp[dpMax])<br>dpMax = i;<span class="hljs-comment">//记录其下标</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大连续子序列和为:&quot;</span> &lt;&lt; dp[dpMax];<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = dpMax; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (dp[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>start = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;子序列为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start+<span class="hljs-number">1</span>; i &lt;= dpMax; ++i)<br>cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-built_in">solution</span>(S,n);<br><span class="hljs-built_in">display</span>(S,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：连续最长数字串：读入一个字符串str，求出str中连续最长的数字串的长度。<br>如：abasjdbkjan1212ksnksn1221213213123；的连续最长数字串为1221213213123。<br>来源：P295</p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><blockquote><p>两个序列A B，求他们的最长的公共子序列C</p></blockquote><p>设A&#x3D;(a0,a1…am-1) B&#x3D;(b0,b1…bn-1) C&#x3D;(c0,c1…cz-1)<br>若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;am-1 C此时为a0..am-2 和 b0..bn-1的最长公共子序列<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;bm-1 C此时为a0..am-1 和 b0..bn-2的最长公共子序列<br>因此对于am-1!&#x3D;bn-1的case C最终应是两种情况的最大值。<br>设dp[i][j]为a0..ai-1 与 b0..bj-1的最长公共子序列长度<br>则有<br><code>dp[i][j]=0   i=j=0 dp[i][j]=1+d[i-1][j-1]  ai-1=bj-1 dp[i][j]=max&#123;dp[i][j-1],dp[i-1][j]&#125; ai-1!=bj-1</code><br>这里又要涉及两个问题：求长度和求具体的序列。<br>考虑何时会使得公共序列中的元素+1?就是若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1,因此关键在于找到dp[i][j]，此时的i j能做出实质性的改变，也即跳过那些非公共元素，非公共元素不会影响dp[][]的值，因此对于相同行和列相邻且相同的dp[][]直接跳过，那些元素不是公共元素。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//边界初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//状态转换</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++) &#123;<br><span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>vector &lt;<span class="hljs-type">char</span>&gt; aimStr;<br><span class="hljs-type">int</span> k = dp[m][n];<br><span class="hljs-type">int</span> i = m;<br><span class="hljs-type">int</span> j = n;<br><span class="hljs-keyword">while</span> (k&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][j] == dp[i - <span class="hljs-number">1</span>][j])<br>--i;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i][j] == dp[i][j - <span class="hljs-number">1</span>])<br>--j;<br><span class="hljs-keyword">else</span><br>&#123;<br>aimStr.<span class="hljs-built_in">push_back</span>(a[i - <span class="hljs-number">1</span>]);<br>--i; --j; --k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;长度为：&quot;</span> &lt;&lt; dp[m][n];<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;序列为:&quot;</span>&lt;&lt;endl;<br>vector &lt;<span class="hljs-type">char</span>&gt;::reverse_iterator rit;<br><span class="hljs-keyword">for</span> (rit = aimStr.<span class="hljs-built_in">rbegin</span>(); rit != aimStr.<span class="hljs-built_in">rend</span>(); ++rit)<br>cout &lt;&lt; *rit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input m,n&quot;</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string A&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string B&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br><span class="hljs-built_in">display</span>(A,B,m,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：求两个字符串A B的最长公共连续子串<br>来源P302</p></blockquote><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>字面意思 注意:不必连续</p></blockquote><p>到现在已经写了三个问题了，不难发现dp是一种思想，最关键在于状态的设置及其转换，分类讨论的思想也举足轻重。<br>假定有序列：1 2 3 0 1 5 2 3 4<br>结果是：0 1 2 3 4（不必连续，跳过5）<br>首先要知道最长长度，其次是去构造。<br><strong>设dp[i]为序列中以s[i]之前的最长递增子序列</strong><br>则有<br><strong>dp[i]&#x3D;1 and dp[i]&#x3D;max{dp[i],dp[j]+1},a[i]&gt;a[j] 0&lt;&#x3D;i&lt;&#x3D;n-1 0&lt;&#x3D;j&lt;&#x3D;i-1</strong><br>明显需要用到以外层循环定界的二重循环<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>&amp; ans)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>dp[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (s[i] &gt; s[j])<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>ans = <span class="hljs-built_in">max</span>(ans,dp[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">solution</span>(S, n,ans);<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列编辑问题"><a href="#序列编辑问题" class="headerlink" title="序列编辑问题"></a>序列编辑问题</h2><blockquote><p>将A串编辑成B串的最小步数，操作方法有：删字符 插字符 换字符</p></blockquote><p><strong>设dp[i][j]为将A串的前i个元素编辑成B串的前j个元素所用的最少步数</strong><br>分析:若A[i-1]&#x3D;B[j-1] 则不必理会 <strong>dp[i][j]&#x3D;dp[i-1][j-1]</strong>;<br>若A[i-1]!&#x3D;B[j-1] 则可以通过三种方式完成：<br>1.将A[i-1]换成B[i-1]：dp[i][j]&#x3D;1+dp[i-1][j-1];<br>2.插入B[j-1]：dp[i][j]&#x3D;1+dp[i][j-1];<br>3.删除A[i-1]：dp[i][j]&#x3D;1+dp[i-1][j];<br>最终的结果是去这三种不同操作的最小值：<strong>dp[i][j]&#x3D;1+min{dp[i-1][j-1],dp[i][j-1],dp[i-1][j]}</strong><br>同时还有边界条件：当A为空时，则插入B.length次,当B为空时，则删除B.length次<br><strong>dp[x][0]&#x3D;x,dp[0][x]&#x3D;x</strong></p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* A, <span class="hljs-type">char</span>* B, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[<span class="hljs-number">0</span>][i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] == B[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>, n=<span class="hljs-number">0</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input A\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input B\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;min edit step: &quot;</span> &lt;&lt;dp[m][n] ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><blockquote><p>n种物品 每种物品都有其重量和价值 每种物品只有一个 在限定总重W下尽可能获得最大的价值。</p></blockquote><p>给物品标上序号：x1…xn x为1则是拿走该物品，为0则不拿走<br>设dp[i][j]表示当容量为j时，物品1-i装入背包的最高价值。<br>dp[i][0]&#x3D;0 dp[0][j]&#x3D;0 dp[i][j]&#x3D;max{dp[i-1][j-w[i]]+v[i],dp[i-1][j]}<br>问题的解为dp[n][W];<br>设n&#x3D;5 W&#x3D;10 w[5]&#x3D;{2,2,6,5,4} v[5]&#x3D;{6,3,5,4,6} 下标从1开始<br>dp[1][1]:1个物品1个重量：   重量不够 只能不选                     价值：0<br>dp[1][2]:1个物品2个重量：   重量足够 决策max{dp[0][0]+6,dp[0][2]} 价值：6<br>dp[1][3]:1个物品3个重量：   重量足够 决策max{dp[0][1]+6,dp[0][3]} 价值：6<br>dp[1][4]:1个物品4个重量：   重量足够 决策max{dp[0][2]+6,dp[0][4]} 价值：6<br>dp[1][5]:1个物品5个重量：   重量足够 决策max{dp[0][3]+6,dp[0][5]} 价值：6<br>dp[1][6]:1个物品6个重量：   重量足够 决策max{dp[0][4]+6,dp[0][6]} 价值：6<br>dp[1][7]:1个物品7个重量：   重量足够 决策max{dp[0][5]+6,dp[0][7]} 价值：6<br>dp[1][8]:1个物品8个重量：   重量足够 决策max{dp[0][6]+6,dp[0][8]} 价值：6<br>dp[1][9]:1个物品9个重量：   重量足够 决策max{dp[0][7]+6,dp[0][9]} 价值：6<br>dp[1][10]:1个物品10个重量： 重量足够 决策max{dp[0][8]+6,dp[0][10]} 价值：6</p><p>dp[2][1]:2个物品1个重量：   重量不够 只能不选                      价值：0<br>dp[2][2]:2个物品2个重量：   重量足够 决策max{dp[1][0]+3,dp[1][2]}  价值：6<br>dp[2][3]:2个物品3个重量：   重量足够 决策max{dp[1][1]+3,dp[1][3]}  价值：6<br>dp[2][4]:2个物品4个重量：   重量足够 决策max{dp[1][2]+3,dp[1][4]}  价值：9<br>dp[2][5]:2个物品5个重量：   重量足够 决策max{dp[1][3]+3,dp[1][5]}  价值：9<br>dp[2][6]:2个物品6个重量：   重量足够 决策max{dp[1][4]+3,dp[1][6]}  价值：9<br>dp[2][7]:2个物品7个重量：   重量足够 决策max{dp[1][5]+3,dp[1][7]}  价值：9<br>dp[2][8]:2个物品8个重量：   重量足够 决策max{dp[1][6]+3,dp[1][8]}  价值：9<br>dp[2][9]:2个物品9个重量：   重量足够 决策max{dp[1][7]+3,dp[1][9]}  价值：9<br>dp[2][10]:2个物品10个重量：   重量足够 决策max{dp[1][8]+3,dp[1][10]}  价值：9<br>dp[3][1]:3个物品1个重量：   重量不够 只能不选                      价值：0</p><p>跟着dp设计分析一遍发现：还真是~ 验证一下最终结果?dp[5][10]&#x3D;max{dp[4][10],dp[4][10-w[4]]+v[4]}…以此类推</p><blockquote><p>01背包问题，只要记住dp的设计即可。其他只要你验证就发现是对的，也不难，但是麻烦，只要牢记这样子做是对的，就这样做即可。都是前辈们铺好了的路。<br>另一个值得考虑的问题是，如何构造出具体的方案，每个dp总是这样，通过设计dp数组和递推方程给出结果，但具体的方案，一般是通过dp的设计思路并结合最终结果<strong>反推</strong>得到的：<br>源程序：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W=<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//下标为0的不用 不然不便于展现清晰的思路</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">bool</span> x[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-literal">false</span> &#125;;<span class="hljs-comment">//表示编号为下标的背包有没有被选 0就是选了 1就是没选 便于输出方案</span><br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Knap01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//先写边界条件，发现其他dp也都是如此</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=W;i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//然后由递推方程构建dp各项</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-comment">//leftWeight为可用的重量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> leftWeight = <span class="hljs-number">1</span>; leftWeight &lt;= W; leftWeight++)<br>&#123;<br><span class="hljs-keyword">if</span> (leftWeight &lt; w[i])<span class="hljs-comment">//可用重量小于当前物品重量 则不可选</span><br>dp[i][leftWeight] = dp[i - <span class="hljs-number">1</span>][leftWeight];<br><span class="hljs-keyword">else</span><br>&#123;<br>dp[i][leftWeight] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][leftWeight],dp[i<span class="hljs-number">-1</span>][leftWeight-w[i]]+v[i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//已经求出了dp各项，现要根据dp项构造出选择方案；根据之前的分析发现：如果因为决策没选择和因为重量不够而不选择，他们的结构都一样</span><br><span class="hljs-comment">//他们的递推式都一样，因为原因不重要，重要的是你到底选没有选择。因此，只要你没有选择，我就要使用对应的递推方程；</span><br><span class="hljs-comment">//反过来说，要是你满足某个递推方程，那么你就一定没被选，再进一步，如果你不满足那个递推式，那你就一定被选了。</span><br><span class="hljs-comment">//循环的边界情况都已经考虑好了，因此只要记住即可</span><br><span class="hljs-type">int</span> i = n;<br><span class="hljs-type">int</span> leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] != dp[i - <span class="hljs-number">1</span>][leftWeight])<br>&#123;<br>x[i] = <span class="hljs-literal">true</span>;<br>leftWeight -= w[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>x[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>i--;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Knap01</span>();<br><span class="hljs-built_in">choose</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;选择的物品编号：\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (x[i] == <span class="hljs-number">1</span>)<br>cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n总价值为：&quot;</span> &lt;&lt; dp[n][W];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><blockquote><p>在01背包的基础上:那些物品每样都有无穷多个。求此时的最大价值选法。<br>真·多重背包问题将在AcWing部分解决。</p></blockquote><p>分析：在01的问题上增设一个属性：物品的数量，dp还是那个dp，dp[i][j]：在重量为j的情况下选择1-i号物品的最大收益，但此时还要增加另一个变量fk[i][j]表示dp[i][j]下i物品选择的数量。</p><p>dp[i][j]&#x3D;max{dp[i-1][j-k<em>w[i]]+k</em>v[i],dp[i-1][j]},第一项也是关于K的最大值函数。<br>设：n&#x3D;3 W&#x3D;7 w[4]&#x3D;{0,3,4,2} v[4]&#x3D;{0,4,5,3}<br>dp[0][x]&#x3D;dp[x][0]&#x3D;0<br>dp[1][1]&#x3D;0 dp[1][2]&#x3D;0 dp[1][3]&#x3D;4(k&#x3D;1) dp[1][4]&#x3D;4(k&#x3D;1) dp[1][5]&#x3D;4(k&#x3D;1) d[1][6]&#x3D;8(k&#x3D;2) dp[1][7]&#x3D;8(k&#x3D;2)</p><p>dp[2][1]&#x3D;0 dp[2][2]&#x3D;0 dp[2][3]&#x3D;4 dp[2][4]&#x3D;max{dp[1][3],dp[1][4-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][5]&#x3D;max{dp[1][5],dp[1][5-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][6]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0) dp[2][7]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0)…</p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> fk[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= W; i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//背包序号dp的i</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> leftWeight=<span class="hljs-number">1</span>;leftWeight&lt;=W;leftWeight++)<span class="hljs-comment">//剩余重量dp的j</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * w[i] &lt;= leftWeight; k++)<span class="hljs-comment">//数量fk的值</span><br>&#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] &lt; dp[i - <span class="hljs-number">1</span>][leftWeight - k * w[i]] + k * v[i])<span class="hljs-comment">//找出最大值对应的K</span><br>&#123;<br>dp[i][leftWeight] = dp[i<span class="hljs-number">-1</span>][leftWeight-k*w[i]]+k*v[i];<br>fk[i][leftWeight] = k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大价值是：&quot;</span> &lt;&lt; dp[n][W];<br><span class="hljs-keyword">return</span> dp[n][W];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i = n, leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;物品&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;拿走了&quot;</span> &lt;&lt; fk[i][leftWeight] &lt;&lt; <span class="hljs-string">&quot;件数&quot;</span>;<br>leftWeight -= fk[i][leftWeight] * w[i];<br>--i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">initial</span>();<br><span class="hljs-built_in">MaxValue</span>();<br><span class="hljs-built_in">choose</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h2><blockquote><p>将有限的资源分配给有限的使用者，使得总收益最大。是完全背包问题的变式</p></blockquote><h2 id="会议安排"><a href="#会议安排" class="headerlink" title="会议安排"></a>会议安排</h2><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><blockquote><p>dp数组项在构建时，往往只会利用前几项，或者说，某一项只会在构建出其后几项被利用，如果最终的结果只要求最终项，那么很多项在被利用后是可以抛弃的，这部分空间完全是浪费了，因此设置滚动数组压缩存储空间。一般是通过取模运算完成。</p></blockquote><p>举例：斐波那列数列的dp数组 <strong>元素依赖跨度</strong>为3 设置dp[3]<br>于是dp[i%3]&#x3D;dp[(i-2)%3]+dp[(i-1)%3]<br>01Knap 元素依赖跨度为第一维的i 跨度为2 设置dp[2][j]<br>前者的值只有0,1 可以考虑取模但很傻，可以考虑用初始x&#x3D;0；之后x&#x3D;1-x；代替取模运算，核心不变，就是通过手段将数组存储空间压缩为其元素依赖跨度即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis基础</title>
    <link href="/2023/11/20/MyBatis/"/>
    <url>/2023/11/20/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h3><p>创建spring项目，添加项目依赖，选择SQL大选项，选择里面的mybatis framework和mysql driver</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>在application.properties中添加数据库四大件和必要的配置：日志显示和自动处理命名风格</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">zyq2004zyq</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatisstudy</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mybatis log:mybatislog-impl std</span><br><span class="hljs-attr">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#camel :mybatis naming map</span><br><span class="hljs-attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>安装mybatisX插件</p><h3 id="structure"><a href="#structure" class="headerlink" title="structure"></a>structure</h3><p>根据分层解耦，创建mapper包，并创建mapper接口添加mapper注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span><br></code></pre></td></tr></table></figure><p>创建实体类以及其所在的包pojo，可以利用lombok方便生成其构造方法 getter setter tostring等基本方法,使用前需要在pom.xml中添加依赖,其实也可以不这么做，直接在创建项目时就勾选开发依赖lombok，其实这两种方法没什么本质区别，熟练后直接在创建的时候添加就好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>在mybatis中，主要以两种形式完成与数据库的信息交换，一种是映射注释的风格，另一种是XML文件的风格。对于简单的SQL语句，直接用映射的形式，对于复杂的SQL语句更建议用XML的形式</p></blockquote><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>每种SQL语句都有其对应的注释。在mapper接口中添加public方法，对这个方法添加相应的注释，注释后的括号就是要执行的sql语句。</p><p>更多细节：为了方便在设计时不必取别名，必须始终严格遵守pojo类的属性与数据库中表的属性相同，下划线式转驼峰即可。因此对于涉及到多个属性的SQL语句，可以直接用对象的形式封存，mybatis自动完成了存取，你只需要保持一切都能对应上即可。</p><ol><li><p>通过参数进行SQL语句的执行是必不可少的，比如删除某个id为xx的数据。因此这里涉及到传参，通过#{id}实现即可。另外还有￥{}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//#&#123;&#125;预编译 换成？ 用于参数传递</span><br><span class="hljs-comment">//$&#123;&#125; 直接拼接 存在sql注入问题 表名和列表动态设置时使用</span><br><span class="hljs-meta">@Delete(&quot;delete from emp where id=#&#123;id  &#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行某些sql语句后，时常需要返回他的主键，进行更进一步的sql操作，<em><strong>主键返回</strong></em>：需要用到option注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主键返回</span><br><span class="hljs-comment">//useGeneratedKeys获取生成的属性 赋予给keyProperty属性</span><br><span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br><span class="hljs-meta">@Insert(&quot;insert into emp(username,name,gender,image,job,entrydate,dept_id,create_time,update_time)&quot;+</span><br><span class="hljs-meta">        &quot;values(#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert2</span><span class="hljs-params">(Emp emp)</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询语句是有返回值的，只要为上述函数定义返回对应的类型即可，对于查询语句，一般是pojo类的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from emp&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//above is in test</span><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMappingSelect</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Emp&gt; empList=empMapper.select();<br>        System.out.println(empList);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果整个项目都这样写，特别是当SQL语句较复杂时，将不利于维护和编写，因此XML风格的写法是很重要的，而且XML风格能针对一些issue提供有效的solution。</p><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h3><p>在resource文件夹中新建与mapper相同名称路径的目录，建立时记得要&#x3D;&#x3D;<strong>用斜杠</strong>&#x3D;&#x3D;来一次性建立目录，不能用点，然后在此文件夹中创建与mapper接口相同名称的&#x3D;&#x3D;xml&#x3D;&#x3D;文件。然后写入基本的配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mbbasic.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sb&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mbbasic.pojo.Emp&quot;</span>&gt;</span><br>    select * from emp<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用时，需要用mapper标签中的namespace属性来标记出对应的mapper接口路径，路径&#x3D;&#x3D;包括接口本身&#x3D;&#x3D;，并且，在执行对应的SQL语句时，需要在sql标签中的id属性设置与mapper接口中方法的同名，只有这样让程序才能能精准定位。对于又返回结果集的select语句，还需要添加resultType标签，并往里写入返回结果集基本元素的pojo类路径，&#x3D;&#x3D;包括类本身&#x3D;&#x3D;。</p><p>总结：有四大要素：</p><ol><li><p>xml文件名和文件路径与mapper接口和mapper包路径对应；</p></li><li><p>mapper标签namespace属性与mapper接口路径对应；</p></li><li><p>sql语句id与mapper接口方法对应；</p></li><li><p>对于查询语句，resultType与pojo类路径对应。</p></li></ol><h3 id="CommonSQL"><a href="#CommonSQL" class="headerlink" title="CommonSQL"></a>CommonSQL</h3><p>对于一般SQL，就是所有属性都能一一对应的比较死板的SQL。这样的SQL很基础，更多用到的是动态SQL，考虑一种情况，当你需要select实体集合时，你编写了sql语句，sql语句中的属性，有时是基于表项属性中的1个，2个，3个…而且还不知道是哪几个，要么你写很多组查询方法，这太麻烦了，肯定不回去考虑，要么你一次性写出基于多个属性的查询，但实际在用的时候你还是可能只基于其中的某一个或多个属性来查询，因此多余的属性将会以null参数的形式传入，这样你将无法得到你想要的结果。查询如此，更新等语句更是如此，要是有一种机制能够帮助你完成类似java中的不定参数函数的功能就会很方便：这就是动态SQL。</p><h3 id="DynamicSQL"><a href="#DynamicSQL" class="headerlink" title="DynamicSQL"></a>DynamicSQL</h3><p>动态SQL对以上issue的solution是提供更多封装好了功能的标签，你只要学会去使用，将思维深度转换为广度，将脑力转换为记忆，以此助人登阶，何其浪漫~</p><p>mybatis提供的标签：<if> <foreach> <where> <set> &#x2F; <sql> <include>分别适用于不同场景，前组是‘关键字’，后两者是‘函数‘。</p><p>更方便的是，在mapper接口的方法的参数中，可以十分笼统地编写形参！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span>;<br>    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Emp emp)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Emp emp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>必须多练才能牢固记忆。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;条件表达式&quot;</span>&gt;</span><br>   要拼接的sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;集合名称&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;集合遍历出来的元素/项&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;每一次遍历使用的分隔符&quot;</span> </span><br><span class="hljs-tag">         <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;遍历开始前拼接的片段&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><br>------------------------------<br>实现delete from emp where id in (1,2,3);<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--删除操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>------------------------------<br>实现不会出现and(单属性查询是不会出现and了 中间间隔的情况也会导致多余and的出现)或者where(select *是没有where字句的)干扰的查询<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR<br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- if做为where标签的子元素 --&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                 and gender = #&#123;gender&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>------------------------------<br>实现不会有逗号干扰的update操作，用set标签替换set语句<br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-comment">&lt;!-- 使用set标签，代替update语句中的set关键字 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>                username=#&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                name=#&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender=#&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span><br>                image=#&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job=#&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate=#&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id=#&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time=#&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>&gt;</span><br> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br><br>---------------------------------<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>            and gender = #&#123;gender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>            and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2023/11/19/VueTrick/"/>
    <url>/2023/11/19/VueTrick/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="属性传值"><a href="#属性传值" class="headerlink" title="属性传值"></a>属性传值</h2><ol><li><p>涉及很多属性的传值时：设计对象并使用v-bind。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const post = &#123;<br>  id: 1,<br>  title: &#x27;My Journey with Vue&#x27;<br>&#125;<br>&lt;BlogPost v-bind=&quot;post&quot; /&gt;<br>//等价于<br>&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p>属性默认值：一般类型：default: xxx 数组或对象类型：default(<em>rawProps</em>) {return {message: ‘hello’,xxx:’xxxx’…}}</p><p>如果声明了 <code>default</code> 值，那么在 prop 的值被解析为 <code>undefined</code> 时，无论 prop 是未被传递还是显式指明的 <code>undefined</code>，都会改为 <code>default</code> 值(即default会抹除undefined)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-comment">// 基础类型检查</span><br>  <span class="hljs-comment">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br>  <span class="hljs-comment">// 多种可能的类型</span><br>  <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>  <span class="hljs-comment">// 必传，且为 String 类型</span><br>  <span class="hljs-attr">propC</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// Number 类型的默认值</span><br>  <span class="hljs-attr">propD</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  <span class="hljs-comment">// 对象类型的默认值</span><br>  <span class="hljs-attr">propE</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>    <span class="hljs-comment">// 对象或数组的默认值</span><br>    <span class="hljs-comment">// 必须从一个工厂函数返回。</span><br>    <span class="hljs-comment">// 该函数接收组件所接收到的原始 prop 作为参数。</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params">rawProps</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 自定义类型校验函数</span><br>  <span class="hljs-attr">propF</span>: &#123;<br>    <span class="hljs-title function_">validator</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-comment">// The value must match one of these strings</span><br>      <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 函数类型的默认值</span><br>  <span class="hljs-attr">propG</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,<br>    <span class="hljs-comment">// 不像对象或数组的默认，这不是一个</span><br>    <span class="hljs-comment">// 工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">propH</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">MyClass</span><span class="hljs-comment">//可以为自定义的类</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>关于Boolean的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">String</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>规范化：子组件不该直接去改prop.attribute 虽然无法通过这种方式更改父组件中的值，因为单项数据流，但是为了规范，实在要去修改传入的值可以通过计算属性，或者定义响应式变量，初值取自该属性值，以后对这个响应式变量做修改即可。特别是对于&#x3D;&#x3D;数组和对象这样的引用类型&#x3D;&#x3D;，子组件是可以更改并影响到父组件的，而且很难以被发现。对于传入的数组或对象属性更要注意！</p></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li><p>在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p></li><li><p>事件校验：要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <code>emit</code> 的内容，返回一个布尔值来表明事件是否合法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits(&#123;<br>  // 没有校验<br>  click: null,<br><br>  // 校验 submit 事件<br>  submit: (&#123; email, password &#125;) =&gt; &#123;<br>    if (email &amp;&amp; password) &#123;<br>      return true<br>    &#125; else &#123;<br>      console.warn(&#x27;Invalid submit event payload!&#x27;)<br>      return false<br>    &#125;<br>  &#125;<br>&#125;)<br><br>function submitForm(email, password) &#123;<br>  emit(&#x27;submit&#x27;, &#123; email, password &#125;)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ol><li><p>绑定组件：</p></li><li><p>组件内部需要做两件事：</p><ol><li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li><li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>多个v-model：为组件中的不同属性分别绑定，首先要起别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])// 改！<br>defineEmits([&#x27;update:title&#x27;])// 改！<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot; //绑定别名！<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;//update这里也改！<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use:<br>&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt; //绑定title即可<br></code></pre></td></tr></table></figure><p>基于此，设置多个别名并绑定即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  firstName: String,<br>  lastName: String<br>&#125;)<br><br>defineEmits([&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;firstName&quot;<br>    @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;lastName&quot;<br>    @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use<br>&lt;UserName<br>  v-model:first-name=&quot;first&quot;<br>  v-model:last-name=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>4.自定义修饰：</p></li></ol><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><ol><li><p>插槽位于父组件作用域，只能访问父组件中的数据而不能访问子组件中的数据</p></li><li><p>子组件的插槽中&#x2F;<slot>&#x2F;<slot>可以写入数据作为默认值</p></li><li><p>多插槽，为每个插槽起名即可：添加name属性，如不添加则默认名称：default</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件<br>&lt;BaseLayout&gt;<br>  &lt;template v-slot:header&gt;  --&gt;&lt;template #header&gt;具名插槽简写<br>    &lt;!-- header 插槽的内容放这里 --&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br>----------------------------------<br>子组件<br>&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><p>默认情况下，如1.所说，但是有时想要实现属性的传递，在slot标签中绑定属性即可，在父组件使用这个子组件时 在子组件标签处绑定V-SLOT&#x3D;‘properties’ 然后再利用 但目前我还没有想到适合的使用场景，感觉关系很混乱，而且实在要实现其实完全可以用其他更规范的方式。</p></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol><li><p>当父组件想子组件传递数据，常常会用到prop，考虑一颗很高的组件树，如果想要父组件为深层的子组件传递某个值，用prop太难了，为了避免逐级透传，使用提供注入的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, provide &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>provide(&#x27;key&#x27;, count) //注入属性key 值为count 响应式<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>应用层能为所有组件&#x3D;&#x3D;提供&#x3D;&#x3D;：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;)<br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&#x27;hello!&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>为子组件&#x3D;&#x3D;注入&#x3D;&#x3D;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; inject,ref &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>count = inject(&#x27;count&#x27;,99999)-----99999是默认值，当父组件没有提供属性值时，采用这个<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>原则：<strong>尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>，提高内聚性，易于维护。</p></li><li><p>Symbol:大型的应用，包含非常多的依赖提供，或者编写提供给其他开发者使用的组件库，最好使用 Symbol 来作为注入名以避免潜在的冲突。</p><p>先在一个单独的js文件中导出这些注入名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//in symbols.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectionKey = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-comment">//in provident</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-title function_">provide</span>(myInjectionKey, &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">  要提供的数据</span><br><span class="hljs-comment">*/</span> &#125;);<br><span class="hljs-comment">//in injection</span><br><span class="hljs-comment">// 注入方组件</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(myInjectionKey)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/19/hello-world/"/>
    <url>/2023/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2023-11-19 12:00</p><p>Hello World…</p><blockquote><p>Lawyers, I suppose, were children once.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
