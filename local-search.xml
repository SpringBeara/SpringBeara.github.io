<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回溯基础</title>
    <link href="/2023/11/21/Backtrace/"/>
    <url>/2023/11/21/Backtrace/</url>
    
    <content type="html"><![CDATA[<h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="递归和非递归"><a href="#递归和非递归" class="headerlink" title="递归和非递归"></a>递归和非递归</h3><p>回溯法可由递归和非递归方式实现，递归法能抽象出如下的模板：<br>根据问题性质是排列还是集合，也可以抽象出对应的模板。<br>而非递归回溯需要设计额外的数据结构来保存节点。</p><h3 id="排列与子集"><a href="#排列与子集" class="headerlink" title="排列与子集"></a>排列与子集</h3><p>问题的解空间树有两种类型。若问题为从含n个元素的集合S中找出符合某约束的元素的集合，此为<strong>子集树<strong>，比如求子集问题；若问题为从含n个元素的集合S从，找出满足约束的n个元素的排列，此为<strong>排列树<strong>，比如求全排列问题。</p><h4 id="幂集问题："><a href="#幂集问题：" class="headerlink" title="幂集问题："></a>幂集问题：</h4><p>分析：设定一个数组bool choose[n]表示这n个对应的元素是否被选了，因此对于n个元素，从第一个元素开始，若选中了，则置choose[i]&#x3D;1;直到处理完最后一个元素，输出这组结果，然后回溯上一层…</p><p>建模：</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/21/b6461ba45eeeb71f.png"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//now：当前处理的元素 last：数组末尾元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">bool</span> c[],<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now &gt;= last) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&#123; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; last; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (c[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt; a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>c[now] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(a, c, now + <span class="hljs-number">1</span>, last);<br>c[now] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(a, c, now + <span class="hljs-number">1</span>, last);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input array length:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-type">bool</span>* choose = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;input array elements:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; array[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(array,choose,<span class="hljs-number">0</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><p>子集树问题模板：</p><h4 id="全排列问题："><a href="#全排列问题：" class="headerlink" title="全排列问题："></a>全排列问题：</h4><p>分析：从数组首元素开始处理，让他与自己交换位置，然后处理交换位置后的元素，让他与自己交换…最终处理到最后一个元素，由于是与自身交换位置，此时的序列不会有任何改变，因为没有后继元素了，则输出该序列然后回溯到上一层，处理倒数第二的元素，这次让他与倒数第一的元素交换位置（而非自身），此时进入下一层，处理末元素，又得到一组结果，然后再回溯到上上层…</p><p>建模：</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/21/3ef8173d66043f60.png"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//now：当前处理的元素 last：数组末尾元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now == last)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; last; i++)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//在这里回溯了</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt; last; i++)<br>&#123;<br><span class="hljs-built_in">swap</span>(a[now], a[i]);<br><span class="hljs-built_in">dfs</span>(a, now + <span class="hljs-number">1</span>, last);<br><span class="hljs-built_in">swap</span>(a[now], a[i]);<span class="hljs-comment">//当回到当前层，还需要换回，保证是当前处理的元素与后续元素分别交换。再进入下一次循环。</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input array length:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input array elements:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; array[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(array, <span class="hljs-number">0</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>排列树问题模板：</p><p>比较：</p><p>排列树在循环中递归，子集树直接递归。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>为了提高回溯法的时间效率，常常要考虑剪枝，进一步涉及到左子树的剪枝和右子树的剪枝：<br>对于右子树的剪枝，一般还要额外设置一个函数参数rightIndex。<br>左子树：一般是无法满足的条件：比如背包问题中剩余重量不够用。<br>右子树：一般是不用判断，一定满足的条件：比如背包问题中即使后续全选也不会超重。<br>对于复杂问题，还要专门写出一个剪枝函数prune：比如活动安排问题中的剪枝函数：</p><h3 id="回溯和深度遍历"><a href="#回溯和深度遍历" class="headerlink" title="回溯和深度遍历"></a>回溯和深度遍历</h3><p>回溯问题的两大抽象：排列和子集其实就是纯dfs。而其他的回溯问题都能通过这两种抽象进行转换再处理。因此回溯本身和DFS是很暧昧的。</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p> 是子集问题的抽象，回溯于：是否选择某物品。</p><blockquote><p>分析：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> W = <span class="hljs-number">6</span>;<br><span class="hljs-comment">//下标为0不考虑，便于叙述 第N个背包和数组下标</span><br><span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">//最优选择方案和最大价值</span><br><span class="hljs-type">bool</span> choose[n+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> maxValue=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//layer:解集树层次，即正在第LAYER个物品。</span><br><span class="hljs-comment">//nowChoose现在的选择方案</span><br><span class="hljs-comment">//nowWeight现在的总重量 nowValue现在的总价值</span><br><span class="hljs-comment">//leftWeights:剩下的背包的重量，用于剪枝.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">bool</span> nowChoose[], <span class="hljs-type">int</span> nowWeight, <span class="hljs-type">int</span> nowValue,<span class="hljs-type">int</span> leftWeights)</span> </span>&#123;<br><span class="hljs-comment">//n个物品，对每个物品依次进行抉择，最多讨论n层。n层后定结论</span><br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-keyword">if</span> (nowWeight == W <span class="hljs-keyword">and</span> nowValue &gt; maxValue) &#123;<br>maxValue = nowValue;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>choose[i] = nowChoose[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//当前总重量加上此物品的重量若&gt;最大能容纳的重量,则不能选这个物品！直接跳过</span><br><span class="hljs-keyword">if</span> (nowWeight+w[layer]&lt;=W) &#123;<br>nowChoose[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>, nowChoose, nowWeight + w[layer], nowValue + v[layer],leftWeights-w[layer]);<br>&#125;<br><span class="hljs-comment">//实际上想表达：若剩下的所有物品的总重量与当前重量的和都要小于最大能容纳的重量，</span><br><span class="hljs-comment">//那为了最大价值，自然是希望狂拿的，反正也不会超重.就不会再考虑不拿的情况了.</span><br><span class="hljs-keyword">if</span> (nowWeight+leftWeights&gt;=W) &#123;<br>nowChoose[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>, nowChoose, nowWeight, nowValue,leftWeights-w[layer]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> nowChoose[n + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(nowChoose, <span class="hljs-literal">false</span>, n + <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, nowChoose, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,W);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;choose tactic:&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (choose[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;object&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; value: &quot;</span> &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot; weight: &quot;</span> &lt;&lt; w[i];<br>&#125;<br>cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;maxValue:&quot;</span> &lt;&lt; maxValue;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="装载和复杂装载"><a href="#装载和复杂装载" class="headerlink" title="装载和复杂装载"></a>装载和复杂装载</h2><blockquote><p>一般装载问题：<br>复杂装载问题：</p></blockquote><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>典中典。子集问题的抽象。回溯在于某坐标是否放置了皇后。</p><blockquote><p>分析：问题建模，用二维数组描述棋盘，用另一个二维数组描述某坐标是否放置了皇后。设计一个函数表示某坐标是否能否放置皇后，能放就放，不能放就回溯，直到放完所有皇后，此时输出一组解。同时统计有多少解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">total</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;No.&quot;</span> &lt;&lt; ++total&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (chess[i] != j)<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&quot;O&quot;</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlace</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;x=0\n&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br><span class="hljs-comment">//同对角线的处理:|x2-x1|==|y2-y1|!!!! 千万不要写成了|x1-y1|==|x2-y2|!!!</span><br><span class="hljs-comment">//后者在正对角线（\，捺）成立是最恶心的，对左对角线不成立！！！！！</span><br><span class="hljs-keyword">if</span> (chess[i]==y || (<span class="hljs-built_in">abs</span>(i-x)==<span class="hljs-built_in">abs</span>(chess[i]-y)))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> layer, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n)<br><span class="hljs-built_in">display</span>(chess,n);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;n;i++ )<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">canPlace</span>(chess, n, layer - <span class="hljs-number">1</span>, i))<br>&#123;<br>chess[layer - <span class="hljs-number">1</span>] = i;<br><span class="hljs-built_in">dfs</span>(chess, layer + <span class="hljs-number">1</span>, n);<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input N:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-comment">//一维数组作为棋盘，下标为行，元素值为列</span><br><span class="hljs-type">int</span>* chess = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-built_in">dfs</span>(chess,<span class="hljs-number">1</span>,n);<br>cout &lt;&lt; <span class="hljs-string">&quot;Engross:&quot;</span> &lt;&lt; total&lt;&lt;<span class="hljs-string">&quot; solutions&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Sum100"><a href="#Sum100" class="headerlink" title="Sum100"></a>Sum100</h2><blockquote><p>设计一个算法在1,2,3..9(顺序不能变)数字之间插入 + 或 - 或什么也不插，使得计算结果为100，并输出所有方案。</p><p>分析：输出时机：处理完9且所得结果为100。决策：+ - 空。回溯点：处理完9但结果不为100.<br>三选一的子集问题抽象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">9</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span> op[],<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> preAdd,<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> layer)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer == N)<br>&#123;<br><span class="hljs-keyword">if</span> (sum == <span class="hljs-number">100</span>)<br>&#123;<br>cout &lt;&lt; a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++) &#123;<br><span class="hljs-keyword">if</span> (op[j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>cout &lt;&lt; op[j];<br>cout &lt;&lt; a[j];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot; = 100\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>op[layer] = <span class="hljs-string">&#x27;+&#x27;</span>;<br>sum += a[layer];<br><span class="hljs-built_in">dfs</span>(op, sum, a[layer], a, layer + <span class="hljs-number">1</span>);<br>sum -= a[layer];<span class="hljs-comment">//恢复状态 回溯处理</span><br>op[layer] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>sum -= a[layer];<br><span class="hljs-built_in">dfs</span>(op, sum, -a[layer], a, layer + <span class="hljs-number">1</span>);<br>sum += a[layer];<span class="hljs-comment">//恢复状态 回溯处理</span><br>op[layer] = <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">//重点：怎么使得：-5_6=》-56 而5_6=》56 </span><br><span class="hljs-comment">//因此需要获取前面的值 为正：pre*10+now 为负：pre*10-now 同时 还要考虑对sum的影响 毕竟替换了一组值</span><br><span class="hljs-comment">//可以通过先减去preAdd，处理后形成新的preAdd，再加给sum即可</span><br>sum -= preAdd;<br><span class="hljs-type">int</span> newAdd=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (preAdd &gt; <span class="hljs-number">0</span>)<br>&#123;<br>newAdd = preAdd * <span class="hljs-number">10</span> + a[layer];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>newAdd = preAdd * <span class="hljs-number">10</span> - a[layer];<br>&#125;<br>sum += newAdd;<br><span class="hljs-built_in">dfs</span>(op, sum, newAdd, a, layer + <span class="hljs-number">1</span>);<br>sum -= newAdd;<span class="hljs-comment">//此时的恢复也需要引起重视</span><br>sum += preAdd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//要插入的运算符或者空操作可以用N-1长度数组存起来</span><br><span class="hljs-type">char</span> op[N];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>a[i] = i + <span class="hljs-number">1</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;result:\n&quot;</span>;<br><span class="hljs-comment">//从2开始处理，第一个要处理的操作符也是1和2之间的。</span><br><span class="hljs-built_in">dfs</span>(op, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">0</span>], a, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h2><blockquote><p>经典子集问题，比01背包还简单</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> aimSum = <span class="hljs-number">31</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">24</span>,<span class="hljs-number">7</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">bool</span> choose[],<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> nowSum,<span class="hljs-type">int</span> leftSum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-keyword">if</span> (nowSum == aimSum)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&#123;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (choose[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (nowSum+a[layer]&lt;=aimSum) &#123;<br>choose[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(choose,layer+<span class="hljs-number">1</span>,nowSum+a[layer],leftSum-a[layer]);<br>&#125;<br><span class="hljs-comment">//也就是说，如果当前处理的元素不选的话，且以后就算全选也达不到要求，那么就必须选！对于不选的方案，剪掉！</span><br><span class="hljs-comment">//注意！！就算不选，leftSum也要减，不选就是错过了，错过了就错过了。。至少在当前世界回不来了，~回溯触发平行时空O(∩_∩)O哈哈~~</span><br><span class="hljs-keyword">if</span> (nowSum+leftSum&gt;=aimSum) &#123;<br>choose[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(choose, layer + <span class="hljs-number">1</span>, nowSum, leftSum-a[layer]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> choose[n+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)<br>sum += a[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;tactics:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(choose, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h2><blockquote></blockquote><h2 id="涂色"><a href="#涂色" class="headerlink" title="涂色"></a>涂色</h2><blockquote></blockquote><h2 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h2><blockquote></blockquote><h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>回溯</tag>
      
      <tag>backtrace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb基础实例1</title>
    <link href="/2023/11/20/JavaWebInstance/"/>
    <url>/2023/11/20/JavaWebInstance/</url>
    
    <content type="html"><![CDATA[<h1 id="员工部门管理系统——后端"><a href="#员工部门管理系统——后端" class="headerlink" title="员工部门管理系统——后端"></a>员工部门管理系统——后端</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>创建一个spring项目，添加4个依赖：spring web，mybatis framework，mysql driver，lombok。</li><li>数据库配置文件：application.properties:数据库连接经典四件套 和 两个经典mybatis优化配置 log和camelCase</li><li>MVC代码框架：<ol><li>pojo：Emp，Dept，Result</li><li>controller：@restController @autowired class:EmpController DeptController</li><li>service：@service interface:EmpService DepService class:EmpServiceImp DeptServiceImp</li><li>mapper：@mapper interface</li><li>mapper.XML：执行动态SQL必不可少的文件</li></ol></li><li>其他：<ol><li>@Slf4j 用于类中日志操作</li><li>RequestMapping(“&#x2F;api”):设置统一父路径</li><li>@GetMapping @DeleteMapping @PostMapping @PutMapping 约束数据交流方法</li><li>@data @allArgxxx @noArgxxx </li><li>动态SQL的相关知识点：各种标签的使用和处理</li></ol></li><li>注：代码初步框架如上，但在开发过程中，为了实现需求，还会增加其他的类和依赖和配置文件。</li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>实现员工-部门的小型后台管理系统：</p><blockquote><ol><li>实现员工和部门的增删查改；</li><li>登录校验和异常处理。</li></ol></blockquote><p>具体分析：</p><ol><li>为了完成员工和部门的增删查改。<strong>动态SQL</strong>是必须的，因此在上述代码框架中还要增加相应的XML文件完成动态SQL。员工的属性有头像，因此涉及到<strong>文件的上传</strong>，可以考虑用本地存储或阿里云OSS，若为阿里云OSS还必须创建aliOSSUtil类，两种方法都要创建一个uploadController来完成上传文件的控制。<strong>分页查询</strong>也是必要的，因此需要创建一个PageBean类存储返回的数据和数据条目数。</li><li>为了完成登录校验，可以利用JWT和拦截器，因此需要一个jwt的工具类专门来生成和转换jwt，需要一个登录拦截器类和拦截器的注册类，而登录操作也可以创建一个loginController。为了完成异常处理，定义一个全局异常处理类。</li><li>为了完成上述功能，除了定义额外的类，还需要必要的依赖和配置文件。而这些都是在具体的开发过程中慢慢完善的。在本阶段先分析到这一步。</li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>考虑到需要返回信息给前端，因此可以设置一个返回结果类，封装返回码，状态和数据，数据直接用最泛的Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码，1 代表成功; 0 代表失败</span><br>    <span class="hljs-keyword">private</span> String msg;  <span class="hljs-comment">//响应信息 描述字符串</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//返回的数据</span><br><br>    <span class="hljs-comment">//增删改 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,data);<br>    &#125;<br>    <span class="hljs-comment">//失败响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,msg,<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由开发过程的分析：依次从controller,service interface,service class,mapping interface(or with XML)完成业务的实现。</p><h3 id="简短的增删查改（部门增删查改）"><a href="#简短的增删查改（部门增删查改）" class="headerlink" title="简短的增删查改（部门增删查改）"></a>简短的增删查改（部门增删查改）</h3><p>对于简短的增删查改，可以行云流水地实现在mapper层，不必写在xml中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">deptController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> deptService deptService;<br><br>    <span class="hljs-comment">//getMapping,对于get请求的映射 等价于---@RequestMapping(value = &quot;/depts&quot; , method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptList</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;查询所有部门数据&quot;</span>);<br>        List&lt;Dept&gt; deptList=deptService.deptList();<br>        <span class="hljs-keyword">return</span> Result.success(deptList);<br>    &#125;<br><br>    <span class="hljs-comment">//获取路径参数 pathVariable注解</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptDel</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;删除部门，id：&quot;</span>+id);<br>        deptService.deptDel(id);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptIns</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;添加部门:&quot;</span>+dept.getName());<br>        deptService.deptIns(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptMod</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;修改部门:&quot;</span>+dept.getId());<br>        deptService.deptMod(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个函数对应一种业务，从controller开始，层层定义，实现。具体实现中值得注意的地方有：</p><blockquote><ol><li>@RequestBody</li><li>@RequestMapping</li><li>Result.success()和Result.success(object)</li><li>特殊属性记得每次都更新：updateTime</li></ol></blockquote><p>当设计较为复杂的业务时：分页查询，动态sql，文件处理。可以按以下策略进行：</p><h3 id="动态增删查改（员工增删查改）"><a href="#动态增删查改（员工增删查改）" class="headerlink" title="动态增删查改（员工增删查改）"></a>动态增删查改（员工增删查改）</h3><p>对于“查”，不仅是动态的，而且是分页的。当数据很多的时候，总不能够全都塞在页面吧，因此要设计分页的机制。前端向后端提供页码和每页的大小。</p><p>后端根据页码和每页的大小，算出每页显示的元素的范围，用select limit完成操作。同时，前端尝尝还需要统计总的数据量给用户，因此需要用到sql中的count函数。后端将具体的信息和总的数据数返回给前端，这样一看，需要返回两种数据了，因此考虑专门设计一个类来返回这些数据。于是PageBean类由此诞生，当然，它属于pojo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageBean</span> &#123;<br><span class="hljs-comment">//    List&lt;Emp&gt; empList;</span><br>   <span class="hljs-comment">/* 这里不要用EmpList，因为将来所有的分页查询都会用到这个类，不能在这里限定泛型*/</span><br>    <span class="hljs-keyword">private</span> List rows;<br>    <span class="hljs-keyword">private</span> Long total;<br>&#125;<br></code></pre></td></tr></table></figure><p>那后端还需要获取到前端传过来的参数：页码，每页大小，并且考虑实际运用，还需要设定默认值从第一页开始默认页码为xx，这些业务的实现需要用到：</p><blockquote><p>@RequestParam(defaulValue&#x3D;“xxx”)</p></blockquote><p>再接着思考，查询时添加条件是完全必要的，动态添加条件更是重要，因此考虑动态sql，因此，为了一次实现，万金油的利用，如果可以的话，将所有表属性作为参数执行动态SQL将会是一劳永逸的。当然还是得结合实际情况，要是根本不可能去根据某些属性来查询，那就确实没必要编写含有它的动态SQL了。因此可以设计出如下的controller代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里是根据分页，姓名，性别，入职日期几个属性完成的条件查询</span><br><span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectEmpFilter</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span><br><span class="hljs-params">                                  String name, Short gender,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span><br>    &#123;<br>        log.info(<span class="hljs-string">&quot;条件查询对应的员工&quot;</span>);<br>        PageBean pageBean=empService.selectEmpFilter(page,pageSize,name,gender,begin,end);<br>        <span class="hljs-keyword">return</span> Result.success(pageBean);<br>    &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;ids&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delEmp</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer[] ids)</span>&#123;<br>        empService.delEmp(ids);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br></code></pre></td></tr></table></figure><p>对应的XML实现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.instance.mapper.empMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterRows&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.instance.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>            <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                    name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                    and gender = #&#123;gender&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                    and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>            limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<br>--             order by update_time desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>        select count(*) from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                and gender = #&#123;gender&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delEmp&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的几个点：</p><blockquote><ol><li><p>name like concat (‘%’,#{name},’%’) ：利用concat 既能实现拼接又能防止sql注入！</p></li><li><p>name !&#x3D;null and name!&#x3D;‘’ 这里是空的引号，千万不要加空格，否则会出现很<del>傻逼</del>的错误：NumberFormatException: For input string:“xx”&lt;-这里是你输入的name，他认为你输入了number；</p></li><li><p>最重要的还得是动态sql到底是如何实现的，那几个关键字一定要学会使用<foreach> <where> <if>……</p></li><li><p>还有一点就是XML建立时，确定对应的函数的那几个对应，一定也要记住；</p></li><li><p>对于日期的处理，可以使用@DateTimeFormat(pattern&#x3D;“yyyy-MM-dd”)来规范，前端不按照这个格式传，就会返回对应的提示警告。</p></li></ol></blockquote><h3 id="文件上传（带头像的员工的增改）"><a href="#文件上传（带头像的员工的增改）" class="headerlink" title="文件上传（带头像的员工的增改）"></a>文件上传（带头像的员工的增改）</h3><p>上传文件，由于文件与其他一般数据不同，需要在前段端和后端都进行额外处理。</p><p>前端：form表格中 method&#x3D;“post” enctype&#x3D;“multipart&#x2F;form-data” input中type&#x3D;‘file’ name&#x3D;‘xxx(设为image)’</p><p>设置好这些后，前端通过post方法传给后端的body中就会包含一般数据和类型为MultipartFile的文件，名称为：xxx（image），后端接受时应保持名称的一致，若是非要不同，可以采用：@RequestParam(“image”) MultipartFile file)来映射名称。</p><p>为了实现文件上传，不如将其考虑为单独的一个controller层，因此设置：uploadController类，然后在这个类中编写相应的代码。</p><p>至此，后端可以接受到前端传来的文件数据，但若不将其存储下来，他将是ephemeral的，存放在本地，数据量少尚可如此，倘若数据量大了就不现实也不安全，可以考虑阿里云的oos服务。</p><blockquote><p>为文件上传专门定义一个接口，在添加或修改员工头像时调用并自动回显，这并不与添加或修改操作本身冲突，因为在选择文件的那瞬间就调用了upload接口，而另外的是另外的接口&#x2F;emps &#x2F;emps&#x2F;update</p></blockquote><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><p>先创建一个文件夹专门存放这些数据，在这里就已经提前想到了，可能会有同名文件的存在，可以通过uuid来解决这个问题。为了存放文件，必须知道（获取）文件的名称，大小，内容，输入流，和存储具体的方法。MultipartFile 常见方法中包括了这些： </p><blockquote><ul><li>String  getOriginalFilename();  &#x2F;&#x2F;获取原始文件名</li><li>void  transferTo(File dest);     &#x2F;&#x2F;将接收的文件转存到磁盘文件中</li><li>long  getSize();     &#x2F;&#x2F;获取文件的大小，单位：字节</li><li>byte[]  getBytes();    &#x2F;&#x2F;获取文件内容的字节数组</li><li>InputStream  getInputStream();    &#x2F;&#x2F;获取接收到的文件内容的输入流</li></ul></blockquote><p>还要考虑到文件大小，上传一个较大的文件(超出1M)时会报错，因为springBoot默认最大单个大小为1MB。</p><p>为了扩大一点，需要在application.properties中添加配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#配置单个文件最大上传大小</span><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-comment">#配置单个请求最大上传大小(一次请求可以上传多个文件)</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">100MB</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);<br>        <span class="hljs-comment">//获取原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>        <span class="hljs-comment">//构建新的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">extname</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<span class="hljs-comment">//文件扩展名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extname;<span class="hljs-comment">//随机名+文件扩展名</span><br>        <span class="hljs-comment">//将文件存储在服务器的磁盘目录</span><br>        image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/images/&quot;</span>+newFileName));<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可以进一步完成新增员工和修改员工的功能。</p><p>修改员工的实现：为了增强用户体验，在前端点击修改员工时，表格中应默认提供目前的员工信息，也就是要先返回一次按id的查询，然后再进行一次update操作，因此为了完成这一功能实际上要完成两部分，后端分别写与这些功能对应的接口即可，分别的调用由前端完成。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span><br>                username = #&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null and password != &#x27;&#x27;&quot;</span>&gt;</span><br>                password = #&#123;password&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>                name = #&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender = #&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null and image != &#x27;&#x27;&quot;</span>&gt;</span><br>                image = #&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job = #&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate = #&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id = #&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time = #&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;在empServiceImp中还应设置updateTime，对于这一点一定要注意，只要涉及改动就要默认更新updateTime，添加员工时还需要注意设置creteTime。</p><h4 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h4><p>可以创建一个util类，当然，不要忘记@component。</p><p>要提前购买和开通oss服务，创建一个bucket，这里有四个关键信息需要保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>; ---&gt;对应着外网访问的endpoint<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后再根据官方给出的示例程序，修改这四个信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;web-framework01&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);<br>        ossClient.putObject(bucketName, fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>若在项目中每涉及到一个第三方技术服务，就将其参数硬编码，那参数变化时要动源码，这是要避免的。难以寻找而且很不优雅。</p><h4 id="参数配置化"><a href="#参数配置化" class="headerlink" title="参数配置化"></a>参数配置化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#自定义的阿里云OSS配置信息</span><br><span class="hljs-attr">aliyun.oss.endpoint</span>=<span class="hljs-string">https://oss-cn-wuhan-lr.aliyuncs.com</span><br><span class="hljs-attr">aliyun.oss.accessKeyId</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.accessKeySecret</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.bucketName</span>=<span class="hljs-string">springbear-instance1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeyId;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br> <br> <span class="hljs-comment">//省略其他代码...</span><br> &#125; <br></code></pre></td></tr></table></figure><h4 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-attr">server.address</span>=<span class="hljs-string">127.0.0.1</span><br>=<span class="hljs-attr">&gt;</span><br><span class="hljs-attr">server</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">port</span>: <span class="hljs-string">8080</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-string">127.0.0.1 #注意数据和属性之间的空格！！</span><br></code></pre></td></tr></table></figure><p>可以看到配置同样的数据信息，yml格式的数据有以下特点：</p><ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心，重数据轻格式</li></ul><p>yml配置文件的基本语法：</p><blockquote><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul></blockquote><p>yml文件中常见的数据格式：</p><p>对象&#x2F;Map集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>数组&#x2F;List&#x2F;Set集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hobby:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">java</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">game</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">sport</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/tlias</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span><br>      <br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">aliyun:</span><br>  <span class="hljs-attr">oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">https://oss-cn-hangzhou.aliyuncs.com</span><br>    <span class="hljs-attr">accessKeyId:</span> <span class="hljs-string">LTAI4GCH1vX6DKqJWxd6nEuW</span><br>    <span class="hljs-attr">accessKeySecret:</span> <span class="hljs-string">yBshYweHOpqDuhCArrVHwIiBKpyqSL</span><br>    <span class="hljs-attr">bucketName:</span> <span class="hljs-string">web-397</span><br></code></pre></td></tr></table></figure><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>对于@value注解，当处理成批的配置文件属性时会很臃肿；可以通过@ConfigurationProperties注解来优化：</p><p>首先要在maven中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>需要创建一个实现类xxxProperties来专门存放这些配置信息，且实体类中的属性名和配置文件当中key的名字必须要一致</p><blockquote><p>比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter &#x2F; setter方法</p></blockquote></li><li><p>需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象</p></li><li><p>在实体类上添加<code>@ConfigurationProperties</code>注解，并通过perfix属性来指定配置参数项的前缀</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AliOSSProperties.java</span><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*阿里云OSS相关配置*/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSProperties</span> &#123;<br>    <span class="hljs-comment">//区域</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-comment">//身份ID</span><br>    <span class="hljs-keyword">private</span> String accessKeyId ;<br>    <span class="hljs-comment">//身份密钥</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret ;<br>    <span class="hljs-comment">//存储空间</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完成的AliOSSUtils工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//当前类对象由Spring创建和管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-comment">//注入配置参数实体类对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AliOSSProperties aliOSSProperties;-----------&gt;把原来的各种属性改成了专门存储属性的类<br>   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),<br>                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());<br>        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span>aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="hljs-string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>还可以通过设置环境变量来完成配置文件的处理。环境变量是在操作系统级别设置的全局变量。它们包含有关操作系统和正在运行的应用程序的信息。应用程序可以读取环境变量以获取配置参数。在大多数操作系统中，可以使用特定的命令来设置和获取环境变量。例如，在Linux和Mac上，可以使用<code>export</code>命令设置环境变量，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">MY_VAR</span>=value<br></code></pre></td></tr></table></figure><p>应用程序可以通过读取<code>MY_VAR</code>环境变量来获取值。</p><blockquote><p>关于配置文件的处理，无非是从程序的可维护性和安全性出发的。<del>非常好程序，这使我的屁股旋转。</del></p></blockquote><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>根据需求：在访问网站时，如果没有登录，则不能进入子路径url，这一点通过&#x3D;&#x3D;过滤器或拦截器&#x3D;&#x3D;来完成，也就是需要对除了&#x2F;login路径外的其他访问，在访问前进行拦截验证，如果已经登录了，则可以完成api的请求，否则不提供服务，为了识别是否登录过了，这一点通过&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;来完成。因此,“登录”不能仅仅只是执行一个查询检验那么简单。</p><h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><p>关于会话、会话跟踪，需要知道：</p><p>&#x3D;&#x3D;会话&#x3D;&#x3D;指的是浏览器与服务器之间的一次连接，我们就称为一次会话。</p><blockquote><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p><ul><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p><code>会话</code>:在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p></li><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p>第2次：访问的是部门管理接口，查询所有部门数据</p></li><li><p>第3次：访问的是员工管理接口，查询员工数据</p></li></ul><p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p></blockquote><p>&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p><blockquote><p>服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我就称为会话跟踪。</p></blockquote><p>使用会话跟踪技术就是要完成在同一个会话中多个请求之间数据的共享。</p><blockquote><p>为什么要共享数据呢？</p><p>由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享</p></blockquote><p>题外话：有没有想过在刷微博或者其他客户端软件时，你所看到的表象是你的账号会显示你所个性化的内容，而别人的账号显示的是别人的个性化内容（关注，粉丝等等等），这都是数据，根据你的ID，这些数据都已存入相应的表中了，根据你的id唯一标识，将这些绑定着id的个性化内容全部连根拔起显示给你。有没有想过为什么网页版会保持登录状态，这个就是会话跟踪技术实现的，他会在一定期限内保留住登录状态。</p><p>可以通过JWT,cookie,session来实现会话跟踪。</p><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>json web token（官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><ul><li><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</p><p>自包含：指的是jwt令牌，看似是一个随机的字符串，但是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</p><p>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</p></blockquote></li></ul><p>JWT的组成： （JWT令牌由三个部分组成，三个部分之间用点来分割）</p><ul><li><p>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”}</p></li><li><p>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”}</p></li><li><p>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。</p><blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，整个jwt令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败。</p></blockquote></li></ul><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>在生成JWT令牌时，会对JSON格式的数据进行一次编码————base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p><p>JWT令牌最典型的应用场景就是登录认证：</p><ol><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。</li><li>前端拿到jwt令牌之后，会将jwt令牌存储(浏览器localStorage)起来。在后续的每一次请求中都会将jwt令牌携带到服务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。</li></ol><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：</p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><p>为此定义一个工具类JWTutil。</p><p>当然，首先要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JWTutil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTutil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String signKey=<span class="hljs-string">&quot;springbear&quot;</span>;<br>    <span class="hljs-comment">//有效期30天</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30L</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genJWT</span><span class="hljs-params">(Map&lt;String,Object&gt; claims)</span>&#123;<br>        String jwt= Jwts.builder()<br>                .addClaims(claims)    <span class="hljs-comment">//自定义消息--有效载荷---有效载荷中存放什么数据也要和前端沟通好。这个项目中是id username 和 name</span><br>                .signWith(SignatureAlgorithm.HS256, signKey)    <span class="hljs-comment">//签名算法</span><br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis()+expire))<br>                .compact();<br>        <span class="hljs-keyword">return</span> jwt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseJWT</span><span class="hljs-params">(String jwt)</span>&#123;<br>        Claims claims=Jwts.parser()<br>                .setSigningKey(signKey)<br>                .parseClaimsJws(jwt)<br>                .getBody();<br>        <span class="hljs-keyword">return</span> claims;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在使用JWT令牌时需要注意：</p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。</li><li>如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。</li></ul><p>因此登录功能的实现又清晰了：登录成功则生成token，执行业务则校验token，若非法，则拦截，合法就放行。</p><p>具体在项目中：前端请求登录，先验证账密是否合法（select），如果登陆成功了，就生成JWT，并将其返回，并且这使得用户在一定时间段内（token有效期间且没有清理浏览器localstorage）不必重复进行登录验证。</p><p>登录功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> empService empService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">loginTry</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span>&#123;<br>        Emp empExist=empService.loginTry(emp);<br>        <span class="hljs-keyword">if</span>(empExist!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            Map&lt;String,Object&gt; claims=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            claims.put(<span class="hljs-string">&quot;id&quot;</span>,empExist.getId());<br>            claims.put(<span class="hljs-string">&quot;username&quot;</span>,empExist.getUsername());<br>            claims.put(<span class="hljs-string">&quot;name&quot;</span>,empExist.getName());<br>            <span class="hljs-comment">//假如登录成功，生成token（一个能被唯一转化的字符串）返回给前端，前端将会获取它并存储。</span><br>            <span class="hljs-comment">//在此后的操作，前端都会携带这个token来进行操作，只要token还在有效期，就能够放行，否则被拦截器拦截。</span><br>            String token=JWTutil.genJWT(claims);<br>            <span class="hljs-keyword">return</span> Result.success(token);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>cookie是客户端会话跟踪技术，存储在客户端浏览器中。用cookie来跟踪会话，可以在浏览器第一次发起服务器请求时，在服务器端来设置一个cookie。</p><p>比如第一次请求了登录接口，登录接口执行完成之后，就可以设置一个cookie，在cookie中就可以来存储用户相关的数据信息。比如在cookie中存储当前登录用户的用户名，ID。</p><p>服务器端给客户端响应数据时会<strong>自动</strong>将cookie响应给浏览器，浏览器接收到此cookie后，会<strong>自动</strong>将cookie的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的cookie<strong>自动</strong>地携带到服务端。</p><p>接下来服务端就可以获取到cookie的值。因此只需要判断这个cookie的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在，就说明客户端之前已经登录完成了。这样就可以基于cookie在同一次会话的不同请求之间来共享数据。</p><p>3个自动：</p><ul><li>服务器<strong>自动</strong>将cookie响应给浏览器。</li><li>浏览器接收到响应回来的数据之后，<strong>自动</strong>将cookie存储在浏览器本地。</li><li>在后续的请求当中，浏览器会<strong>自动</strong>将cookie携带到服务器端。</li></ul><p><strong>为什么这一切都是自动化进行的？</strong></p><p>因为cookie是HTTP协议中所支持的技术，而各大浏览器厂商都支持了这一标准。协议官方给我们提供了一个响应头和请求头：</p><ul><li>响应头 Set-Cookie ：设置Cookie数据</li><li>请求头 Cookie：携带Cookie数据</li></ul><p><strong>优缺点</strong></p><ul><li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带都由浏览器自动进行，无需手动操作）</li><li>缺点：<ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>服务器端会话跟踪技术，存储在服务器端的。Session就是基于Cookie来实现的</p><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案也就失效了。</p></blockquote><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>什么是拦截器？</p><ul><li>是一种动态拦截方法调用的机制，类似于过滤器。</li><li>拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。</li></ul><p>拦截器的作用：</p><ul><li>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。</li></ul><p>在拦截器中通常做一些通用性操作，比如：通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。</p><h5 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h5><p>在注册拦截器时要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>指定要拦截的请求路径，<code>excludePathPatterns</code>指定不拦截的请求路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//拦截器对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//注册自定义拦截器对象</span><br>        registry.addInterceptor(loginCheckInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<span class="hljs-comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<span class="hljs-comment">//设置不拦截的请求路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>基本使用主要包括：定义拦截器，注册拦截器。</p><p>定义拦截器：一个项目中可能有多个拦截器，不妨建立一个拦截器包，对于登录功能中的拦截，定义LoginInterceptor类,(别忘了@component),该类需要实现HandlerInterceptor，并重写其三个方法，特别是prehandle这一方法，他决定着能否放行，因此jwt的验证也在此方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        String token=request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span>(token==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//若存在 则验证合法性</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            JWTutil.parseJWT(token);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            log.info(<span class="hljs-string">&quot;非法token&quot;</span>);<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*分析此实例的流程：</span><br><span class="hljs-comment">* 1. 登录页面不拦截，其他页面拦截，这一点在注册拦截器时控制拦截路径实现。</span><br><span class="hljs-comment">* 2. 其他路径的资源请求，需要携带token(位于请求头中)来若不存在则拒绝并返回相应的信息(json)，若存在则进行验证，合法则放行，否则拒绝并返回相应信息。</span><br><span class="hljs-comment">* 注：为了实现object到json的转换，可以导入阿里的fastjson依赖</span><br><span class="hljs-comment">* 注：返回的erro信息也是有讲究的，不能瞎写，前端需要根据erro中的信息来重定向或者进行其他操作的。比如这里是not_longin,前端获取到就会执行重定向到登录页面</span><br><span class="hljs-comment">* */</span><br></code></pre></td></tr></table></figure><p>注册拦截器：定义一个类WebConfig，该类需要实现webMvcConfigurer，该类中需要重写addInterceptor方法，也是在此类中完成注册拦截器和拦截路径的设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<br>        <span class="hljs-comment">//为除了登录页外的其他页面注册拦截器。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h4><p>再次梳理登录业务：登录时，根据账密判断登录是否成功（select），成功则返回token和成功消息（jwt），否则返回错误信息，在token有效期内，该浏览器中的路径访问不会被阻拦（interceptor放行）。</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/20/b18f88897cc0af29.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>项目编写到这里，以为已经OK了？？实际上忽略了异常处理这一点，因此下次在设计项目时，可以提前考虑。</p><p>当添加部门或者员工时，如果客户端输入的重名了，而数据库又不能完成插入语句，如果没有异常处理，那么前后端将无法完成相应的错误操作，而用户也最好能够得到对应的解释或者哪怕只是简短的提示，也可以通过异常处理来实现，捕获异常后，后端向前端返回额外的消息，前端再经过处理提示给用户。</p><p>异常处理很简单，在每一处可能会出现异常的地方都try catch显然太杂乱臃肿。因此可以定义一个类，专门处理异常，即：全局异常处理器。</p><ol><li><p>定义全局异常处理器非常简单，定义一个类，为此类加上@RestControllerAdvice，加上这个注解就代表定义了一个全局异常处理器。</p></li><li><p>在类中定义一个方法来捕获异常，此方法需要加注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定要捕获异常的类型。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">//处理异常</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span> <span class="hljs-comment">//指定能够处理的异常类型</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception e)</span>&#123;<br>        e.printStackTrace();<span class="hljs-comment">//打印堆栈中的异常信息</span><br>        <span class="hljs-comment">//捕获到异常之后，响应一个标准的Result</span><br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;对不起,操作失败,请联系管理员&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</p><p>处理异常的方法返回值会转换为json后再响应给前端</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>实例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Mybatis</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue构建</title>
    <link href="/2023/11/20/VueStart/"/>
    <url>/2023/11/20/VueStart/</url>
    
    <content type="html"><![CDATA[<h1 id="Learning-Vue"><a href="#Learning-Vue" class="headerlink" title="Learning Vue"></a>Learning Vue</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>准备工作分为 大部分：1.初始化项目；2.安装其他依赖和插件；3.自动导入优化和联想</p></blockquote><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>进入文件夹，npm init vue@latest –npm install –进入VScode npm run dev</p><h3 id="安装依赖和插件"><a href="#安装依赖和插件" class="headerlink" title="安装依赖和插件"></a>安装依赖和插件</h3><p>npm i axios–npm i element-plus –save – npm i @element-plus&#x2F;icon-vue<br>npm install -D unplugin-vue-components unplugin-icons unplugin-auto-import :<br>对于ICON还需要注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementPlusIconsVue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@element-plus/icons-vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><span class="hljs-comment">//注册所有ICON图标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, component] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">ElementPlusIconsVue</span>)) &#123;<br>    app.<span class="hljs-title function_">component</span>(key, component)<br>&#125;<br></code></pre></td></tr></table></figure><p>注册完毕后，后续使用自动导入，因此不必再html页上作全局导入</p><h3 id="自动导入和联想"><a href="#自动导入和联想" class="headerlink" title="自动导入和联想"></a>自动导入和联想</h3><p>自动导入<strong>ele的组件和icon，vue的重要对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vite.config.js</span><br><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Icons</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">IconsResolver</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/resolver&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-keyword">const</span> pathSrc = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-comment">// Auto import functions from Vue, e.g. ref, reactive, toRef...</span><br>      <span class="hljs-comment">// 自动导入 Vue 相关函数，如：ref, reactive, toRef 等</span><br>      <span class="hljs-attr">imports</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>],<br><br>      <span class="hljs-comment">// Auto import functions from Element Plus, e.g. ElMessage, ElMessageBox... (with style)</span><br>      <span class="hljs-comment">// 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式)</span><br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br><br>        <span class="hljs-comment">// Auto import icon components</span><br>        <span class="hljs-comment">// 自动导入图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">prefix</span>: <span class="hljs-string">&#x27;Icon&#x27;</span>,<br>        &#125;),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;auto-imports.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-comment">// Auto register icon components</span><br>        <span class="hljs-comment">// 自动注册图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">enabledCollections</span>: [<span class="hljs-string">&#x27;ep&#x27;</span>],<br>        &#125;),<br>        <span class="hljs-comment">// Auto register Element Plus components</span><br>        <span class="hljs-comment">// 自动导入 Element Plus 组件</span><br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;components.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Icons</span>(&#123;<br>      <span class="hljs-attr">autoInstall</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br><br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: pathSrc<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h2><p>分为界面部分和逻辑部分，逻辑部分主要是axios的调用等</p><blockquote><p>界面部分：</p><ul><li>登录前页面：组件:暂无</li></ul><ol><li>登录</li><li>注册</li></ol><ul><li>登录后页面：组件:导航栏 footer</li></ul><ol><li>主页（信息编辑页） </li><li>事务页</li></ol></blockquote><p>###界面设计<br>在进行页面设计前，需要重写<em><strong>全局样式</strong></em>：global.css并导入到main.js中<br>一般要修改的有：app html body三个部分 p,m&#x3D;0;display:flex;height&#x3D;100vh等<br>否则将会出现页面混乱如无法控制布局，无法铺上背景等诸多问题<br>###登录界面设计<br>####mode1：单一卡片风</p><blockquote><p>1.外部容器存放背景图和内部容器</p><blockquote><p>2.卡片容器：通常包括卡片头header存放logo或欢迎语</p><blockquote><p>3.表单:主体部分</p></blockquote><ul><li>uid</li><li>psw</li><li>recap</li><li>login_btn</li><li>about&amp;register&amp;findPsw<br>4.说明：常常需要考虑居中和靠左靠右的布局问题：<br>居中：父元素display:flex;align-item:center;justify_content:center;<br>靠左靠右：父元素display:flex;justify_content:flex_end;靠右的子元素：margin-left:auto</li></ul></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus布局</title>
    <link href="/2023/11/20/Layout/"/>
    <url>/2023/11/20/Layout/</url>
    
    <content type="html"><![CDATA[<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><blockquote><p>先介绍布局思路，再介绍布局组件化</p></blockquote><h2 id="布局思路"><a href="#布局思路" class="headerlink" title="布局思路"></a>布局思路</h2><p>最重要的是关于el-container的理解：<br>el-container：当包含header或footer时会垂直排放子元素，否则水平，再利用多个container嵌套可以实现自己想要的布局：<br>比如我想要h a m式的布局head aside main</p><p>考虑container包括一个header和一个小的container<br>这样header和小container垂直<br>然后小container内包含aside和main aside和main水平</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>很多时候都是主要区域变化，导航区不变，因此很有必要在主要区域添加二级路由，将其他部分封装成组件比如LayoutHead LayoutAside，在ep中，由于container的性质已经规定好了（如上） 因此即使封装，也仍要在最外层写上container结构，然后对于具体的内容进行封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">//使用ep，为了工程化，目前可以封装成这样，在主界面还是要考虑编写最基本的框架，即嵌套的container，container的具体内容可以封装</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/home/components/LayoutHead.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutAside</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LayoutAside.vue&#x27;</span>;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutHead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutHead</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutAside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutAside</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 二级路由 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 设计思路：此处为localhost：3000/home，因此在路由home中设置children，然后在home.vue中对应的地方设置router-view --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-main</span>&gt;</span>    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如代码所示，即使把header封装成了layoutheader，但封装的是内容，外部的container没有封装进去，因此还要写上，即使封装进去了也不会实现，因为当使用组件时，在外部，他已经不具备container的性质了。也就要求在进行开发的时候，先确定好布局，写好容器排版，再将主要内容封装成组件并写在对应的位置。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus复习</title>
    <link href="/2023/11/20/EP_Use/"/>
    <url>/2023/11/20/EP_Use/</url>
    
    <content type="html"><![CDATA[<h1 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h1><h2 id="菜单（导航栏）"><a href="#菜单（导航栏）" class="headerlink" title="菜单（导航栏）"></a>菜单（导航栏）</h2><blockquote><p>Menu可以设计为导航栏，无论左侧还是顶部，放在对应的容器即可，下一次考虑导航栏的设计，可以采用此思路，设计好布局后，将menu组件放入对应的地方即可，这一次的设计不熟悉EP的组件，因此导航栏的设计并没有规划，导致走了不少弯路，自己也做了一些无用功。</p></blockquote><h3 id="菜单的使用技巧"><a href="#菜单的使用技巧" class="headerlink" title="菜单的使用技巧"></a>菜单的使用技巧</h3><blockquote><p>包括默认打开，折叠菜单，子菜单，菜单项组，打开方式（更多可以参见官网的API 此处给出一些常用的）（注意API的使用所能支持的模式）</p></blockquote><p>默认打开菜单：default-active；default-openeds<br>折叠菜单：collapse（vertical only）collapse-transition<br>子菜单（组件）：el-sub-menu<br>菜单项组（组件）：el-menu-item-group<br>打开方式：menu-trigger（horizontal only）：string(hover &#x2F; click)</p><blockquote><p>又发现了当折叠后，弹出子菜单选项的时间默认值有点慢，显得很卡不丝滑，因此更改响应时间是很有必要的<br>子菜单响应时间：show-timeout hide-timeout100ms不错</p></blockquote><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><blockquote><p>今天想要修改按钮的宽度，但ep并没有给出width属性，因此要么用style改，要么用vue控制style改，当然选择动态性的后者：<br>于是需要知道vue如何绑定style：</p></blockquote><blockquote><p>今天想通过行为更改按钮ICON 嘻嘻用v-if 代码如下</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;switchSize&quot;</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;&#123;width:Sidewidth&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Fold</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Expand</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>v-bind：style&#x3D;“{width：xxxx}”</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dp基础</title>
    <link href="/2023/11/20/DP_TEXT/"/>
    <url>/2023/11/20/DP_TEXT/</url>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote><p>整数N分解成不超过K的自然数的和，求拆分方案的个数：</p></blockquote><p>分析：设有F(N,K)表示最终结果。容易知道：<code>F(1,x)=1 and F(x,1)=1</code><br>当N&lt;K 时：<code>F(N,K)=F(N,N)</code><br>当N&#x3D;K 时：可以考虑将整数就分解为他本身这一种方案 和 F(N,K-1) 有：<code>F(N,K)=1+F(N,K-1)</code><br>当N&gt;K 时：可以分类讨论拆分的数中是否包含K，若包含：则其余的数的和必然为:N-K 现在只需要考虑N-K如何拆分即可，故有：F(N-K,K)；若不包含：则拆分可以转变为：F(N,K-1) 有：<code>F(N,K)=F(N,K-1)+F(N-K,K)</code><br>因此：<img src="https://s3.bmp.ovh/imgs/2023/11/21/aa143084b1426144.png"><br>设DP[n][k]为答案。因此源程序如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">1</span>)<br>dp[i][j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; j)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - j][j];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j)<br>dp[i][j] = <span class="hljs-number">1</span> + dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i][i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>;<br>cin &gt;&gt; n&gt;&gt; k;<br><span class="hljs-built_in">solution</span>(n, k);<br>cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大连续子序列和问题"><a href="#最大连续子序列和问题" class="headerlink" title="最大连续子序列和问题"></a>最大连续子序列和问题</h2><blockquote><p>一段数字序列 求其中的最大连续和子序列</p></blockquote><p>分析：问题分成两部分：求值，构建具体的序列。<br>设dp[N]为包括Sequence[N-1]往前的最大连续子序列和。<br>关键在于找状态转移方程：<code>dp[N]=max&#123;dp[N-1]+Sequence[N-1],Sequence[N-1]&#125;</code><br>Sequence[N-1]为序列数组末尾元素。<br>且一定有边界条件：<code>dp[0]=0</code>,没有所谓的前0个元素，是从1开始确定的，这里只是个主观规定。</p><p>通过dp很容易求出最大连续子序列和，但是要考虑如何通过这个结果构造出具体的子序列.</p><blockquote><p><em><strong>从抽象入手总是困难，不妨设置一些用例来帮助分析，写算法就是如此，这样的用例可能无法覆盖所有的情况，所有就有了一个叫做debug的工作来完善你的算法思想。</strong></em></p></blockquote><p>设-2 11 -4 13 -5 -2<br>则dp[1]&#x3D;max{0-2，-2}&#x3D;-2；<br>dp[2]&#x3D;max{-2+11,11}&#x3D;11;<br>dp[3]&#x3D;max{11-4,-4}&#x3D;7;<br>dp[4]&#x3D;max{7+13,13}&#x3D;20;<br>dp[5]&#x3D;max{20-5,-5}&#x3D;15;<br>dp[6]&#x3D;max{15-2,-2}&#x3D;13.</p><p>最大的DP为20，最大子序列为11 -4 13。根据这个例子：若dp一开始为负数，则后来一旦出现正数，那么那个负数就不会再计入在最大子序列中，因此那个负数就是临界处。每一次dp的负数，都是对连续子序列的一次重新选择。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span>* s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>dp[i] = <span class="hljs-built_in">max</span>( dp[i - <span class="hljs-number">1</span>] + s[i],s[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> dpMax=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (dp[i] &gt; dp[dpMax])<br>dpMax = i;<span class="hljs-comment">//记录其下标</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大连续子序列和为:&quot;</span> &lt;&lt; dp[dpMax];<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = dpMax; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (dp[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>start = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;子序列为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start+<span class="hljs-number">1</span>; i &lt;= dpMax; ++i)<br>cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-built_in">solution</span>(S,n);<br><span class="hljs-built_in">display</span>(S,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：连续最长数字串：读入一个字符串str，求出str中连续最长的数字串的长度。<br>如：abasjdbkjan1212ksnksn1221213213123；的连续最长数字串为1221213213123。<br>来源：P295</p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><blockquote><p>两个序列A B，求他们的最长的公共子序列C</p></blockquote><p>设A&#x3D;(a0,a1…am-1) B&#x3D;(b0,b1…bn-1) C&#x3D;(c0,c1…cz-1)<br>若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;am-1 C此时为a0..am-2 和 b0..bn-1的最长公共子序列<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;bm-1 C此时为a0..am-1 和 b0..bn-2的最长公共子序列<br>因此对于am-1!&#x3D;bn-1的case C最终应是两种情况的最大值。<br>设dp[i][j]为a0..ai-1 与 b0..bj-1的最长公共子序列长度<br>则有<br><code>dp[i][j]=0   i=j=0 dp[i][j]=1+d[i-1][j-1]  ai-1=bj-1 dp[i][j]=max&#123;dp[i][j-1],dp[i-1][j]&#125; ai-1!=bj-1</code><br>这里又要涉及两个问题：求长度和求具体的序列。<br>考虑何时会使得公共序列中的元素+1?就是若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1,因此关键在于找到dp[i][j]，此时的i j能做出实质性的改变，也即跳过那些非公共元素，非公共元素不会影响dp[][]的值，因此对于相同行和列相邻且相同的dp[][]直接跳过，那些元素不是公共元素。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//边界初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//状态转换</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++) &#123;<br><span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>vector &lt;<span class="hljs-type">char</span>&gt; aimStr;<br><span class="hljs-type">int</span> k = dp[m][n];<br><span class="hljs-type">int</span> i = m;<br><span class="hljs-type">int</span> j = n;<br><span class="hljs-keyword">while</span> (k&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][j] == dp[i - <span class="hljs-number">1</span>][j])<br>--i;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i][j] == dp[i][j - <span class="hljs-number">1</span>])<br>--j;<br><span class="hljs-keyword">else</span><br>&#123;<br>aimStr.<span class="hljs-built_in">push_back</span>(a[i - <span class="hljs-number">1</span>]);<br>--i; --j; --k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;长度为：&quot;</span> &lt;&lt; dp[m][n];<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;序列为:&quot;</span>&lt;&lt;endl;<br>vector &lt;<span class="hljs-type">char</span>&gt;::reverse_iterator rit;<br><span class="hljs-keyword">for</span> (rit = aimStr.<span class="hljs-built_in">rbegin</span>(); rit != aimStr.<span class="hljs-built_in">rend</span>(); ++rit)<br>cout &lt;&lt; *rit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input m,n&quot;</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string A&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string B&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br><span class="hljs-built_in">display</span>(A,B,m,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：求两个字符串A B的最长公共连续子串<br>来源P302</p></blockquote><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>字面意思 注意:不必连续</p></blockquote><p>到现在已经写了三个问题了，不难发现dp是一种思想，最关键在于状态的设置及其转换，分类讨论的思想也举足轻重。<br>假定有序列：1 2 3 0 1 5 2 3 4<br>结果是：0 1 2 3 4（不必连续，跳过5）<br>首先要知道最长长度，其次是去构造。<br><strong>设dp[i]为序列中以s[i]之前的最长递增子序列</strong><br>则有<br><strong>dp[i]&#x3D;1 and dp[i]&#x3D;max{dp[i],dp[j]+1},a[i]&gt;a[j] 0&lt;&#x3D;i&lt;&#x3D;n-1 0&lt;&#x3D;j&lt;&#x3D;i-1</strong><br>明显需要用到以外层循环定界的二重循环<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>&amp; ans)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>dp[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (s[i] &gt; s[j])<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>ans = <span class="hljs-built_in">max</span>(ans,dp[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">solution</span>(S, n,ans);<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列编辑问题"><a href="#序列编辑问题" class="headerlink" title="序列编辑问题"></a>序列编辑问题</h2><blockquote><p>将A串编辑成B串的最小步数，操作方法有：删字符 插字符 换字符</p></blockquote><p><strong>设dp[i][j]为将A串的前i个元素编辑成B串的前j个元素所用的最少步数</strong><br>分析:若A[i-1]&#x3D;B[j-1] 则不必理会 <strong>dp[i][j]&#x3D;dp[i-1][j-1]</strong>;<br>若A[i-1]!&#x3D;B[j-1] 则可以通过三种方式完成：<br>1.将A[i-1]换成B[i-1]：dp[i][j]&#x3D;1+dp[i-1][j-1];<br>2.插入B[j-1]：dp[i][j]&#x3D;1+dp[i][j-1];<br>3.删除A[i-1]：dp[i][j]&#x3D;1+dp[i-1][j];<br>最终的结果是去这三种不同操作的最小值：<strong>dp[i][j]&#x3D;1+min{dp[i-1][j-1],dp[i][j-1],dp[i-1][j]}</strong><br>同时还有边界条件：当A为空时，则插入B.length次,当B为空时，则删除B.length次<br><strong>dp[x][0]&#x3D;x,dp[0][x]&#x3D;x</strong></p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* A, <span class="hljs-type">char</span>* B, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[<span class="hljs-number">0</span>][i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] == B[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>, n=<span class="hljs-number">0</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input A\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input B\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;min edit step: &quot;</span> &lt;&lt;dp[m][n] ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><blockquote><p>n种物品 每种物品都有其重量和价值 每种物品只有一个 在限定总重W下尽可能获得最大的价值。</p></blockquote><p>给物品标上序号：x1…xn x为1则是拿走该物品，为0则不拿走<br>设dp[i][j]表示当容量为j时，物品1-i装入背包的最高价值。<br>dp[i][0]&#x3D;0 dp[0][j]&#x3D;0 dp[i][j]&#x3D;max{dp[i-1][j-w[i]]+v[i],dp[i-1][j]}<br>问题的解为dp[n][W];<br>设n&#x3D;5 W&#x3D;10 w[5]&#x3D;{2,2,6,5,4} v[5]&#x3D;{6,3,5,4,6} 下标从1开始<br>dp[1][1]:1个物品1个重量：   重量不够 只能不选                     价值：0<br>dp[1][2]:1个物品2个重量：   重量足够 决策max{dp[0][0]+6,dp[0][2]} 价值：6<br>dp[1][3]:1个物品3个重量：   重量足够 决策max{dp[0][1]+6,dp[0][3]} 价值：6<br>dp[1][4]:1个物品4个重量：   重量足够 决策max{dp[0][2]+6,dp[0][4]} 价值：6<br>dp[1][5]:1个物品5个重量：   重量足够 决策max{dp[0][3]+6,dp[0][5]} 价值：6<br>dp[1][6]:1个物品6个重量：   重量足够 决策max{dp[0][4]+6,dp[0][6]} 价值：6<br>dp[1][7]:1个物品7个重量：   重量足够 决策max{dp[0][5]+6,dp[0][7]} 价值：6<br>dp[1][8]:1个物品8个重量：   重量足够 决策max{dp[0][6]+6,dp[0][8]} 价值：6<br>dp[1][9]:1个物品9个重量：   重量足够 决策max{dp[0][7]+6,dp[0][9]} 价值：6<br>dp[1][10]:1个物品10个重量： 重量足够 决策max{dp[0][8]+6,dp[0][10]} 价值：6</p><p>dp[2][1]:2个物品1个重量：   重量不够 只能不选                      价值：0<br>dp[2][2]:2个物品2个重量：   重量足够 决策max{dp[1][0]+3,dp[1][2]}  价值：6<br>dp[2][3]:2个物品3个重量：   重量足够 决策max{dp[1][1]+3,dp[1][3]}  价值：6<br>dp[2][4]:2个物品4个重量：   重量足够 决策max{dp[1][2]+3,dp[1][4]}  价值：9<br>dp[2][5]:2个物品5个重量：   重量足够 决策max{dp[1][3]+3,dp[1][5]}  价值：9<br>dp[2][6]:2个物品6个重量：   重量足够 决策max{dp[1][4]+3,dp[1][6]}  价值：9<br>dp[2][7]:2个物品7个重量：   重量足够 决策max{dp[1][5]+3,dp[1][7]}  价值：9<br>dp[2][8]:2个物品8个重量：   重量足够 决策max{dp[1][6]+3,dp[1][8]}  价值：9<br>dp[2][9]:2个物品9个重量：   重量足够 决策max{dp[1][7]+3,dp[1][9]}  价值：9<br>dp[2][10]:2个物品10个重量：   重量足够 决策max{dp[1][8]+3,dp[1][10]}  价值：9<br>dp[3][1]:3个物品1个重量：   重量不够 只能不选                      价值：0</p><p>跟着dp设计分析一遍发现：还真是~ 验证一下最终结果?dp[5][10]&#x3D;max{dp[4][10],dp[4][10-w[4]]+v[4]}…以此类推</p><blockquote><p>01背包问题，只要记住dp的设计即可。其他只要你验证就发现是对的，也不难，但是麻烦，只要牢记这样子做是对的，就这样做即可。都是前辈们铺好了的路。<br>另一个值得考虑的问题是，如何构造出具体的方案，每个dp总是这样，通过设计dp数组和递推方程给出结果，但具体的方案，一般是通过dp的设计思路并结合最终结果<strong>反推</strong>得到的：<br>源程序：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W=<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//下标为0的不用 不然不便于展现清晰的思路</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">bool</span> x[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-literal">false</span> &#125;;<span class="hljs-comment">//表示编号为下标的背包有没有被选 0就是选了 1就是没选 便于输出方案</span><br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Knap01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//先写边界条件，发现其他dp也都是如此</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=W;i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//然后由递推方程构建dp各项</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-comment">//leftWeight为可用的重量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> leftWeight = <span class="hljs-number">1</span>; leftWeight &lt;= W; leftWeight++)<br>&#123;<br><span class="hljs-keyword">if</span> (leftWeight &lt; w[i])<span class="hljs-comment">//可用重量小于当前物品重量 则不可选</span><br>dp[i][leftWeight] = dp[i - <span class="hljs-number">1</span>][leftWeight];<br><span class="hljs-keyword">else</span><br>&#123;<br>dp[i][leftWeight] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][leftWeight],dp[i<span class="hljs-number">-1</span>][leftWeight-w[i]]+v[i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//已经求出了dp各项，现要根据dp项构造出选择方案；根据之前的分析发现：如果因为决策没选择和因为重量不够而不选择，他们的结构都一样</span><br><span class="hljs-comment">//他们的递推式都一样，因为原因不重要，重要的是你到底选没有选择。因此，只要你没有选择，我就要使用对应的递推方程；</span><br><span class="hljs-comment">//反过来说，要是你满足某个递推方程，那么你就一定没被选，再进一步，如果你不满足那个递推式，那你就一定被选了。</span><br><span class="hljs-comment">//循环的边界情况都已经考虑好了，因此只要记住即可</span><br><span class="hljs-type">int</span> i = n;<br><span class="hljs-type">int</span> leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] != dp[i - <span class="hljs-number">1</span>][leftWeight])<br>&#123;<br>x[i] = <span class="hljs-literal">true</span>;<br>leftWeight -= w[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>x[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>i--;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Knap01</span>();<br><span class="hljs-built_in">choose</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;选择的物品编号：\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (x[i] == <span class="hljs-number">1</span>)<br>cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n总价值为：&quot;</span> &lt;&lt; dp[n][W];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><blockquote><p>在01背包的基础上:那些物品每样都有无穷多个。求此时的最大价值选法。<br>真·多重背包问题将在AcWing部分解决。</p></blockquote><p>分析：在01的问题上增设一个属性：物品的数量，dp还是那个dp，dp[i][j]：在重量为j的情况下选择1-i号物品的最大收益，但此时还要增加另一个变量fk[i][j]表示dp[i][j]下i物品选择的数量。</p><p>dp[i][j]&#x3D;max{dp[i-1][j-k<em>w[i]]+k</em>v[i],dp[i-1][j]},第一项也是关于K的最大值函数。<br>设：n&#x3D;3 W&#x3D;7 w[4]&#x3D;{0,3,4,2} v[4]&#x3D;{0,4,5,3}<br>dp[0][x]&#x3D;dp[x][0]&#x3D;0<br>dp[1][1]&#x3D;0 dp[1][2]&#x3D;0 dp[1][3]&#x3D;4(k&#x3D;1) dp[1][4]&#x3D;4(k&#x3D;1) dp[1][5]&#x3D;4(k&#x3D;1) d[1][6]&#x3D;8(k&#x3D;2) dp[1][7]&#x3D;8(k&#x3D;2)</p><p>dp[2][1]&#x3D;0 dp[2][2]&#x3D;0 dp[2][3]&#x3D;4 dp[2][4]&#x3D;max{dp[1][3],dp[1][4-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][5]&#x3D;max{dp[1][5],dp[1][5-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][6]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0) dp[2][7]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0)…</p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> fk[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= W; i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//背包序号dp的i</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> leftWeight=<span class="hljs-number">1</span>;leftWeight&lt;=W;leftWeight++)<span class="hljs-comment">//剩余重量dp的j</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * w[i] &lt;= leftWeight; k++)<span class="hljs-comment">//数量fk的值</span><br>&#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] &lt; dp[i - <span class="hljs-number">1</span>][leftWeight - k * w[i]] + k * v[i])<span class="hljs-comment">//找出最大值对应的K</span><br>&#123;<br>dp[i][leftWeight] = dp[i<span class="hljs-number">-1</span>][leftWeight-k*w[i]]+k*v[i];<br>fk[i][leftWeight] = k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大价值是：&quot;</span> &lt;&lt; dp[n][W];<br><span class="hljs-keyword">return</span> dp[n][W];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i = n, leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;物品&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;拿走了&quot;</span> &lt;&lt; fk[i][leftWeight] &lt;&lt; <span class="hljs-string">&quot;件数&quot;</span>;<br>leftWeight -= fk[i][leftWeight] * w[i];<br>--i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">initial</span>();<br><span class="hljs-built_in">MaxValue</span>();<br><span class="hljs-built_in">choose</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h2><blockquote><p>将有限的资源分配给有限的使用者，使得总收益最大。是完全背包问题的变式</p></blockquote><h2 id="会议安排"><a href="#会议安排" class="headerlink" title="会议安排"></a>会议安排</h2><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><blockquote><p>dp数组项在构建时，往往只会利用前几项，或者说，某一项只会在构建出其后几项被利用，如果最终的结果只要求最终项，那么很多项在被利用后是可以抛弃的，这部分空间完全是浪费了，因此设置滚动数组压缩存储空间。一般是通过取模运算完成。</p></blockquote><p>举例：斐波那列数列的dp数组 <strong>元素依赖跨度</strong>为3 设置dp[3]<br>于是dp[i%3]&#x3D;dp[(i-2)%3]+dp[(i-1)%3]<br>01Knap 元素依赖跨度为第一维的i 跨度为2 设置dp[2][j]<br>前者的值只有0,1 可以考虑取模但很傻，可以考虑用初始x&#x3D;0；之后x&#x3D;1-x；代替取模运算，核心不变，就是通过手段将数组存储空间压缩为其元素依赖跨度即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis基础</title>
    <link href="/2023/11/20/MyBatis/"/>
    <url>/2023/11/20/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h3><p>创建spring项目，添加项目依赖，选择SQL大选项，选择里面的mybatis framework和mysql driver</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>在application.properties中添加数据库四大件和必要的配置：日志显示和自动处理命名风格</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">zyq2004zyq</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatisstudy</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mybatis log:mybatislog-impl std</span><br><span class="hljs-attr">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#camel :mybatis naming map</span><br><span class="hljs-attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>安装mybatisX插件</p><h3 id="structure"><a href="#structure" class="headerlink" title="structure"></a>structure</h3><p>根据分层解耦，创建mapper包，并创建mapper接口添加mapper注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span><br></code></pre></td></tr></table></figure><p>创建实体类以及其所在的包pojo，可以利用lombok方便生成其构造方法 getter setter tostring等基本方法,使用前需要在pom.xml中添加依赖,其实也可以不这么做，直接在创建项目时就勾选开发依赖lombok，其实这两种方法没什么本质区别，熟练后直接在创建的时候添加就好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>在mybatis中，主要以两种形式完成与数据库的信息交换，一种是映射注释的风格，另一种是XML文件的风格。对于简单的SQL语句，直接用映射的形式，对于复杂的SQL语句更建议用XML的形式</p></blockquote><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>每种SQL语句都有其对应的注释。在mapper接口中添加public方法，对这个方法添加相应的注释，注释后的括号就是要执行的sql语句。</p><p>更多细节：为了方便在设计时不必取别名，必须始终严格遵守pojo类的属性与数据库中表的属性相同，下划线式转驼峰即可。因此对于涉及到多个属性的SQL语句，可以直接用对象的形式封存，mybatis自动完成了存取，你只需要保持一切都能对应上即可。</p><ol><li><p>通过参数进行SQL语句的执行是必不可少的，比如删除某个id为xx的数据。因此这里涉及到传参，通过#{id}实现即可。另外还有￥{}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//#&#123;&#125;预编译 换成？ 用于参数传递</span><br><span class="hljs-comment">//$&#123;&#125; 直接拼接 存在sql注入问题 表名和列表动态设置时使用</span><br><span class="hljs-meta">@Delete(&quot;delete from emp where id=#&#123;id  &#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行某些sql语句后，时常需要返回他的主键，进行更进一步的sql操作，<em><strong>主键返回</strong></em>：需要用到option注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主键返回</span><br><span class="hljs-comment">//useGeneratedKeys获取生成的属性 赋予给keyProperty属性</span><br><span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br><span class="hljs-meta">@Insert(&quot;insert into emp(username,name,gender,image,job,entrydate,dept_id,create_time,update_time)&quot;+</span><br><span class="hljs-meta">        &quot;values(#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert2</span><span class="hljs-params">(Emp emp)</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询语句是有返回值的，只要为上述函数定义返回对应的类型即可，对于查询语句，一般是pojo类的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from emp&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//above is in test</span><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMappingSelect</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Emp&gt; empList=empMapper.select();<br>        System.out.println(empList);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果整个项目都这样写，特别是当SQL语句较复杂时，将不利于维护和编写，因此XML风格的写法是很重要的，而且XML风格能针对一些issue提供有效的solution。</p><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h3><p>在resource文件夹中新建与mapper相同名称路径的目录，建立时记得要&#x3D;&#x3D;<strong>用斜杠</strong>&#x3D;&#x3D;来一次性建立目录，不能用点，然后在此文件夹中创建与mapper接口相同名称的&#x3D;&#x3D;xml&#x3D;&#x3D;文件。然后写入基本的配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mbbasic.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sb&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mbbasic.pojo.Emp&quot;</span>&gt;</span><br>    select * from emp<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用时，需要用mapper标签中的namespace属性来标记出对应的mapper接口路径，路径&#x3D;&#x3D;包括接口本身&#x3D;&#x3D;，并且，在执行对应的SQL语句时，需要在sql标签中的id属性设置与mapper接口中方法的同名，只有这样让程序才能能精准定位。对于又返回结果集的select语句，还需要添加resultType标签，并往里写入返回结果集基本元素的pojo类路径，&#x3D;&#x3D;包括类本身&#x3D;&#x3D;。</p><p>总结：有四大要素：</p><ol><li><p>xml文件名和文件路径与mapper接口和mapper包路径对应；</p></li><li><p>mapper标签namespace属性与mapper接口路径对应；</p></li><li><p>sql语句id与mapper接口方法对应；</p></li><li><p>对于查询语句，resultType与pojo类路径对应。</p></li></ol><h3 id="CommonSQL"><a href="#CommonSQL" class="headerlink" title="CommonSQL"></a>CommonSQL</h3><p>对于一般SQL，就是所有属性都能一一对应的比较死板的SQL。这样的SQL很基础，更多用到的是动态SQL，考虑一种情况，当你需要select实体集合时，你编写了sql语句，sql语句中的属性，有时是基于表项属性中的1个，2个，3个…而且还不知道是哪几个，要么你写很多组查询方法，这太麻烦了，肯定不回去考虑，要么你一次性写出基于多个属性的查询，但实际在用的时候你还是可能只基于其中的某一个或多个属性来查询，因此多余的属性将会以null参数的形式传入，这样你将无法得到你想要的结果。查询如此，更新等语句更是如此，要是有一种机制能够帮助你完成类似java中的不定参数函数的功能就会很方便：这就是动态SQL。</p><h3 id="DynamicSQL"><a href="#DynamicSQL" class="headerlink" title="DynamicSQL"></a>DynamicSQL</h3><p>动态SQL对以上issue的solution是提供更多封装好了功能的标签，你只要学会去使用，将思维深度转换为广度，将脑力转换为记忆，以此助人登阶，何其浪漫~</p><p>mybatis提供的标签：<if> <foreach> <where> <set> &#x2F; <sql> <include>分别适用于不同场景，前组是‘关键字’，后两者是‘函数‘。</p><p>更方便的是，在mapper接口的方法的参数中，可以十分笼统地编写形参！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span>;<br>    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Emp emp)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Emp emp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>必须多练才能牢固记忆。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;条件表达式&quot;</span>&gt;</span><br>   要拼接的sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;集合名称&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;集合遍历出来的元素/项&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;每一次遍历使用的分隔符&quot;</span> </span><br><span class="hljs-tag">         <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;遍历开始前拼接的片段&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><br>------------------------------<br>实现delete from emp where id in (1,2,3);<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--删除操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>------------------------------<br>实现不会出现and(单属性查询是不会出现and了 中间间隔的情况也会导致多余and的出现)或者where(select *是没有where字句的)干扰的查询<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR<br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- if做为where标签的子元素 --&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                 and gender = #&#123;gender&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>------------------------------<br>实现不会有逗号干扰的update操作，用set标签替换set语句<br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-comment">&lt;!-- 使用set标签，代替update语句中的set关键字 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>                username=#&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                name=#&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender=#&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span><br>                image=#&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job=#&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate=#&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id=#&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time=#&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>&gt;</span><br> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br><br>---------------------------------<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>            and gender = #&#123;gender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>            and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2023/11/19/VueTrick/"/>
    <url>/2023/11/19/VueTrick/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="属性传值"><a href="#属性传值" class="headerlink" title="属性传值"></a>属性传值</h2><ol><li><p>涉及很多属性的传值时：设计对象并使用v-bind。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const post = &#123;<br>  id: 1,<br>  title: &#x27;My Journey with Vue&#x27;<br>&#125;<br>&lt;BlogPost v-bind=&quot;post&quot; /&gt;<br>//等价于<br>&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p>属性默认值：一般类型：default: xxx 数组或对象类型：default(<em>rawProps</em>) {return {message: ‘hello’,xxx:’xxxx’…}}</p><p>如果声明了 <code>default</code> 值，那么在 prop 的值被解析为 <code>undefined</code> 时，无论 prop 是未被传递还是显式指明的 <code>undefined</code>，都会改为 <code>default</code> 值(即default会抹除undefined)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-comment">// 基础类型检查</span><br>  <span class="hljs-comment">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br>  <span class="hljs-comment">// 多种可能的类型</span><br>  <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>  <span class="hljs-comment">// 必传，且为 String 类型</span><br>  <span class="hljs-attr">propC</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// Number 类型的默认值</span><br>  <span class="hljs-attr">propD</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  <span class="hljs-comment">// 对象类型的默认值</span><br>  <span class="hljs-attr">propE</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>    <span class="hljs-comment">// 对象或数组的默认值</span><br>    <span class="hljs-comment">// 必须从一个工厂函数返回。</span><br>    <span class="hljs-comment">// 该函数接收组件所接收到的原始 prop 作为参数。</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params">rawProps</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 自定义类型校验函数</span><br>  <span class="hljs-attr">propF</span>: &#123;<br>    <span class="hljs-title function_">validator</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-comment">// The value must match one of these strings</span><br>      <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 函数类型的默认值</span><br>  <span class="hljs-attr">propG</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,<br>    <span class="hljs-comment">// 不像对象或数组的默认，这不是一个</span><br>    <span class="hljs-comment">// 工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">propH</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">MyClass</span><span class="hljs-comment">//可以为自定义的类</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>关于Boolean的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">String</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>规范化：子组件不该直接去改prop.attribute 虽然无法通过这种方式更改父组件中的值，因为单项数据流，但是为了规范，实在要去修改传入的值可以通过计算属性，或者定义响应式变量，初值取自该属性值，以后对这个响应式变量做修改即可。特别是对于&#x3D;&#x3D;数组和对象这样的引用类型&#x3D;&#x3D;，子组件是可以更改并影响到父组件的，而且很难以被发现。对于传入的数组或对象属性更要注意！</p></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li><p>在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p></li><li><p>事件校验：要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <code>emit</code> 的内容，返回一个布尔值来表明事件是否合法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits(&#123;<br>  // 没有校验<br>  click: null,<br><br>  // 校验 submit 事件<br>  submit: (&#123; email, password &#125;) =&gt; &#123;<br>    if (email &amp;&amp; password) &#123;<br>      return true<br>    &#125; else &#123;<br>      console.warn(&#x27;Invalid submit event payload!&#x27;)<br>      return false<br>    &#125;<br>  &#125;<br>&#125;)<br><br>function submitForm(email, password) &#123;<br>  emit(&#x27;submit&#x27;, &#123; email, password &#125;)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ol><li><p>绑定组件：</p></li><li><p>组件内部需要做两件事：</p><ol><li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li><li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>多个v-model：为组件中的不同属性分别绑定，首先要起别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])// 改！<br>defineEmits([&#x27;update:title&#x27;])// 改！<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot; //绑定别名！<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;//update这里也改！<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use:<br>&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt; //绑定title即可<br></code></pre></td></tr></table></figure><p>基于此，设置多个别名并绑定即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  firstName: String,<br>  lastName: String<br>&#125;)<br><br>defineEmits([&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;firstName&quot;<br>    @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;lastName&quot;<br>    @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use<br>&lt;UserName<br>  v-model:first-name=&quot;first&quot;<br>  v-model:last-name=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>4.自定义修饰：</p></li></ol><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><ol><li><p>插槽位于父组件作用域，只能访问父组件中的数据而不能访问子组件中的数据</p></li><li><p>子组件的插槽中&#x2F;<slot>&#x2F;<slot>可以写入数据作为默认值</p></li><li><p>多插槽，为每个插槽起名即可：添加name属性，如不添加则默认名称：default</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件<br>&lt;BaseLayout&gt;<br>  &lt;template v-slot:header&gt;  --&gt;&lt;template #header&gt;具名插槽简写<br>    &lt;!-- header 插槽的内容放这里 --&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br>----------------------------------<br>子组件<br>&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><p>默认情况下，如1.所说，但是有时想要实现属性的传递，在slot标签中绑定属性即可，在父组件使用这个子组件时 在子组件标签处绑定V-SLOT&#x3D;‘properties’ 然后再利用 但目前我还没有想到适合的使用场景，感觉关系很混乱，而且实在要实现其实完全可以用其他更规范的方式。</p></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol><li><p>当父组件想子组件传递数据，常常会用到prop，考虑一颗很高的组件树，如果想要父组件为深层的子组件传递某个值，用prop太难了，为了避免逐级透传，使用提供注入的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, provide &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>provide(&#x27;key&#x27;, count) //注入属性key 值为count 响应式<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>应用层能为所有组件&#x3D;&#x3D;提供&#x3D;&#x3D;：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;)<br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&#x27;hello!&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>为子组件&#x3D;&#x3D;注入&#x3D;&#x3D;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; inject,ref &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>count = inject(&#x27;count&#x27;,99999)-----99999是默认值，当父组件没有提供属性值时，采用这个<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>原则：<strong>尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>，提高内聚性，易于维护。</p></li><li><p>Symbol:大型的应用，包含非常多的依赖提供，或者编写提供给其他开发者使用的组件库，最好使用 Symbol 来作为注入名以避免潜在的冲突。</p><p>先在一个单独的js文件中导出这些注入名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//in symbols.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectionKey = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-comment">//in provident</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-title function_">provide</span>(myInjectionKey, &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">  要提供的数据</span><br><span class="hljs-comment">*/</span> &#125;);<br><span class="hljs-comment">//in injection</span><br><span class="hljs-comment">// 注入方组件</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(myInjectionKey)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/19/hello-world/"/>
    <url>/2023/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2023-11-19 12:00</p><p>Hello World…</p><blockquote><p>Lawyers, I suppose, were children once.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
