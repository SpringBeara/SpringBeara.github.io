<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue构建</title>
    <link href="/2023/11/20/VueStart/"/>
    <url>/2023/11/20/VueStart/</url>
    
    <content type="html"><![CDATA[<h1 id="Learning-Vue"><a href="#Learning-Vue" class="headerlink" title="Learning Vue"></a>Learning Vue</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>准备工作分为 大部分：1.初始化项目；2.安装其他依赖和插件；3.自动导入优化和联想</p></blockquote><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>进入文件夹，npm init vue@latest –npm install –进入VScode npm run dev</p><h3 id="安装依赖和插件"><a href="#安装依赖和插件" class="headerlink" title="安装依赖和插件"></a>安装依赖和插件</h3><p>npm i axios–npm i element-plus –save – npm i @element-plus&#x2F;icon-vue<br>npm install -D unplugin-vue-components unplugin-icons unplugin-auto-import :<br>对于ICON还需要注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementPlusIconsVue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@element-plus/icons-vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><span class="hljs-comment">//注册所有ICON图标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, component] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">ElementPlusIconsVue</span>)) &#123;<br>    app.<span class="hljs-title function_">component</span>(key, component)<br>&#125;<br></code></pre></td></tr></table></figure><p>注册完毕后，后续使用自动导入，因此不必再html页上作全局导入</p><h3 id="自动导入和联想"><a href="#自动导入和联想" class="headerlink" title="自动导入和联想"></a>自动导入和联想</h3><p>自动导入<strong>ele的组件和icon，vue的重要对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vite.config.js</span><br><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Icons</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">IconsResolver</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/resolver&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-keyword">const</span> pathSrc = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-comment">// Auto import functions from Vue, e.g. ref, reactive, toRef...</span><br>      <span class="hljs-comment">// 自动导入 Vue 相关函数，如：ref, reactive, toRef 等</span><br>      <span class="hljs-attr">imports</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>],<br><br>      <span class="hljs-comment">// Auto import functions from Element Plus, e.g. ElMessage, ElMessageBox... (with style)</span><br>      <span class="hljs-comment">// 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式)</span><br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br><br>        <span class="hljs-comment">// Auto import icon components</span><br>        <span class="hljs-comment">// 自动导入图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">prefix</span>: <span class="hljs-string">&#x27;Icon&#x27;</span>,<br>        &#125;),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;auto-imports.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-comment">// Auto register icon components</span><br>        <span class="hljs-comment">// 自动注册图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">enabledCollections</span>: [<span class="hljs-string">&#x27;ep&#x27;</span>],<br>        &#125;),<br>        <span class="hljs-comment">// Auto register Element Plus components</span><br>        <span class="hljs-comment">// 自动导入 Element Plus 组件</span><br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;components.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Icons</span>(&#123;<br>      <span class="hljs-attr">autoInstall</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br><br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: pathSrc<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h2><p>分为界面部分和逻辑部分，逻辑部分主要是axios的调用等</p><blockquote><p>界面部分：</p><ul><li>登录前页面：组件:暂无</li></ul><ol><li>登录</li><li>注册</li></ol><ul><li>登录后页面：组件:导航栏 footer</li></ul><ol><li>主页（信息编辑页） </li><li>事务页</li></ol></blockquote><p>###界面设计<br>在进行页面设计前，需要重写<em><strong>全局样式</strong></em>：global.css并导入到main.js中<br>一般要修改的有：app html body三个部分 p,m&#x3D;0;display:flex;height&#x3D;100vh等<br>否则将会出现页面混乱如无法控制布局，无法铺上背景等诸多问题<br>###登录界面设计<br>####mode1：单一卡片风</p><blockquote><p>1.外部容器存放背景图和内部容器</p><blockquote><p>2.卡片容器：通常包括卡片头header存放logo或欢迎语</p><blockquote><p>3.表单:主体部分</p></blockquote><ul><li>uid</li><li>psw</li><li>recap</li><li>login_btn</li><li>about&amp;register&amp;findPsw<br>4.说明：常常需要考虑居中和靠左靠右的布局问题：<br>居中：父元素display:flex;align-item:center;justify_content:center;<br>靠左靠右：父元素display:flex;justify_content:flex_end;靠右的子元素：margin-left:auto</li></ul></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus布局</title>
    <link href="/2023/11/20/Layout/"/>
    <url>/2023/11/20/Layout/</url>
    
    <content type="html"><![CDATA[<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><blockquote><p>先介绍布局思路，再介绍布局组件化</p></blockquote><h2 id="布局思路"><a href="#布局思路" class="headerlink" title="布局思路"></a>布局思路</h2><p>最重要的是关于el-container的理解：<br>el-container：当包含header或footer时会垂直排放子元素，否则水平，再利用多个container嵌套可以实现自己想要的布局：<br>比如我想要h a m式的布局head aside main</p><p>考虑container包括一个header和一个小的container<br>这样header和小container垂直<br>然后小container内包含aside和main aside和main水平</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>很多时候都是主要区域变化，导航区不变，因此很有必要在主要区域添加二级路由，将其他部分封装成组件比如LayoutHead LayoutAside，在ep中，由于container的性质已经规定好了（如上） 因此即使封装，也仍要在最外层写上container结构，然后对于具体的内容进行封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">//使用ep，为了工程化，目前可以封装成这样，在主界面还是要考虑编写最基本的框架，即嵌套的container，container的具体内容可以封装</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/home/components/LayoutHead.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutAside</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LayoutAside.vue&#x27;</span>;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutHead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutHead</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutAside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutAside</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 二级路由 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 设计思路：此处为localhost：3000/home，因此在路由home中设置children，然后在home.vue中对应的地方设置router-view --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-main</span>&gt;</span>    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如代码所示，即使把header封装成了layoutheader，但封装的是内容，外部的container没有封装进去，因此还要写上，即使封装进去了也不会实现，因为当使用组件时，在外部，他已经不具备container的性质了。也就要求在进行开发的时候，先确定好布局，写好容器排版，再将主要内容封装成组件并写在对应的位置。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus复习</title>
    <link href="/2023/11/20/EP_Use/"/>
    <url>/2023/11/20/EP_Use/</url>
    
    <content type="html"><![CDATA[<h1 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h1><h2 id="菜单（导航栏）"><a href="#菜单（导航栏）" class="headerlink" title="菜单（导航栏）"></a>菜单（导航栏）</h2><blockquote><p>Menu可以设计为导航栏，无论左侧还是顶部，放在对应的容器即可，下一次考虑导航栏的设计，可以采用此思路，设计好布局后，将menu组件放入对应的地方即可，这一次的设计不熟悉EP的组件，因此导航栏的设计并没有规划，导致走了不少弯路，自己也做了一些无用功。</p></blockquote><h3 id="菜单的使用技巧"><a href="#菜单的使用技巧" class="headerlink" title="菜单的使用技巧"></a>菜单的使用技巧</h3><blockquote><p>包括默认打开，折叠菜单，子菜单，菜单项组，打开方式（更多可以参见官网的API 此处给出一些常用的）（注意API的使用所能支持的模式）</p></blockquote><p>默认打开菜单：default-active；default-openeds<br>折叠菜单：collapse（vertical only）collapse-transition<br>子菜单（组件）：el-sub-menu<br>菜单项组（组件）：el-menu-item-group<br>打开方式：menu-trigger（horizontal only）：string(hover &#x2F; click)</p><blockquote><p>又发现了当折叠后，弹出子菜单选项的时间默认值有点慢，显得很卡不丝滑，因此更改响应时间是很有必要的<br>子菜单响应时间：show-timeout hide-timeout100ms不错</p></blockquote><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><blockquote><p>今天想要修改按钮的宽度，但ep并没有给出width属性，因此要么用style改，要么用vue控制style改，当然选择动态性的后者：<br>于是需要知道vue如何绑定style：</p></blockquote><blockquote><p>今天想通过行为更改按钮ICON 嘻嘻用v-if 代码如下</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;switchSize&quot;</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;&#123;width:Sidewidth&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Fold</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Expand</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>v-bind：style&#x3D;“{width：xxxx}”</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dp基础</title>
    <link href="/2023/11/20/DP_TEXT/"/>
    <url>/2023/11/20/DP_TEXT/</url>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><blockquote><ul><li>整数拆分问题</li><li>最大连续子序列和</li><li>最长公共子序列</li><li>最长递增子序列</li><li>序列编辑问题</li><li>01背包</li><li>完全背包</li><li>资源分配</li><li>会议安排</li><li>滚动数组</li></ul></blockquote><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote><p>整数N分解成不超过K的自然数的和，求拆分方案的个数：</p></blockquote><p>分析：设有F(N,K)表示最终结果。容易知道：<em><strong>F(1,x)&#x3D;1 and F(x,1)&#x3D;1</strong></em>;<br>当N&lt;K 时：<em><strong>F(N,K)&#x3D;F(N,N)</strong>*<br>当N&#x3D;K 时：可以考虑将整数就分解为他本身这一种方案 和 F(N,K-1) 有：<em><strong>F(N,K)&#x3D;1+F(N,K-1)</strong></em><br>当N&gt;K 时：可以分类讨论拆分的数中是否包含K，若包含：则其余的数的和必然为:N-K 现在只需要考虑N-K如何拆分即可，故有：F(N-K,K)；若不包含：则拆分可以转变为：F(N,K-1) 有：**</em>F(N,K)&#x3D;F(N,K-1)+F(N-K,K)***<br>因此：F(N,K)&#x3D;<br>{<br>1,N&#x3D;1 or K&#x3D;1<br>F(N,N),K&gt;N<br>1+F(N,K-1),K&#x3D;N!&#x3D;1<br>F(N-K,K)+F(N,K-1),K&lt;N<br>}<br>设DP[n][k]为答案。因此源程序如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">1</span>)<br>dp[i][j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; j)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - j][j];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j)<br>dp[i][j] = <span class="hljs-number">1</span> + dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i][i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>;<br>cin &gt;&gt; n&gt;&gt; k;<br><span class="hljs-built_in">solution</span>(n, k);<br>cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大连续子序列和问题"><a href="#最大连续子序列和问题" class="headerlink" title="最大连续子序列和问题"></a>最大连续子序列和问题</h2><blockquote><p>一段数字序列 求其中的最大连续和子序列</p></blockquote><p>分析：问题分成两部分：求值，构建具体的序列。<br><em><strong>设dp[N]为包括Sequence[N-1]往前的最大连续子序列和。</strong></em><br>关键在于找状态转移方程：<em><strong>dp[N]&#x3D;max{dp[N-1]+Sequence[N-1],Sequence[N-1]}</strong></em><br>Sequence[N-1]为序列数组末尾元素。<br>且一定有边界条件：<em><strong>dp[0]&#x3D;0</strong></em>,没有所谓的前0个元素，是从1开始确定的，这里只是个主观规定。</p><p>通过dp很容易求出最大连续子序列和，但是要考虑如何通过这个结果构造出具体的子序列.</p><blockquote><p><strong>从抽象入手总是困难，不妨设置一些用例来帮助分析，写算法就是如此，这样的用例可能无法覆盖所有的情况，所有就有了一个叫做debug的工作来完善你的算法思想。</strong></p></blockquote><p>设-2 11 -4 13 -5 -2<br>则dp[1]&#x3D;max{0-2，-2}&#x3D;-2；<br>dp[2]&#x3D;max{-2+11,11}&#x3D;11;<br>dp[3]&#x3D;max{11-4,-4}&#x3D;7;<br>dp[4]&#x3D;max{7+13,13}&#x3D;20;<br>dp[5]&#x3D;max{20-5,-5}&#x3D;15;<br>dp[6]&#x3D;max{15-2,-2}&#x3D;13.</p><p>最大的DP为20，最大子序列为11 -4 13。根据这个例子：若dp一开始为负数，则后来一旦出现正数，那么那个负数就不会再计入在最大子序列中，因此那个负数就是临界处。<em><strong>每一次dp的负数，都是对连续子序列的一次重新选择</strong></em>。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span>* s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>dp[i] = <span class="hljs-built_in">max</span>( dp[i - <span class="hljs-number">1</span>] + s[i],s[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> dpMax=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (dp[i] &gt; dp[dpMax])<br>dpMax = i;<span class="hljs-comment">//记录其下标</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大连续子序列和为:&quot;</span> &lt;&lt; dp[dpMax];<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = dpMax; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (dp[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>start = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;子序列为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start+<span class="hljs-number">1</span>; i &lt;= dpMax; ++i)<br>cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-built_in">solution</span>(S,n);<br><span class="hljs-built_in">display</span>(S,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：连续最长数字串：读入一个字符串str，求出str中连续最长的数字串的长度。<br>如：abasjdbkjan1212ksnksn1221213213123；的连续最长数字串为1221213213123。<br>来源：P295</p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><blockquote><p>两个序列A B，求他们的最长的公共子序列C</p></blockquote><p>设A&#x3D;(a0,a1…am-1) B&#x3D;(b0,b1…bn-1) C&#x3D;(c0,c1…cz-1)<br>若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;am-1 C此时为a0..am-2 和 b0..bn-1的最长公共子序列<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;bm-1 C此时为a0..am-1 和 b0..bn-2的最长公共子序列<br>因此对于am-1!&#x3D;bn-1的case C最终应是两种情况的最大值。<br><em><strong>设dp[i][j]为a0..ai-1 与 b0..bj-1的最长公共子序列长度</strong></em><br>则有<br><em><strong>dp[i][j]&#x3D;0   i&#x3D;j&#x3D;0</strong></em><br><em><strong>dp[i][j]&#x3D;1+d[i-1][j-1]  ai-1&#x3D;bj-1</strong></em><br><em><strong>dp[i][j]&#x3D;max{dp[i][j-1],dp[i-1][j]} ai-1!&#x3D;bj-1</strong></em><br>这里又要涉及两个问题：求长度和求具体的序列。<br>考虑何时会使得公共序列中的元素+1?就是<em><strong>若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1</strong></em>,因此关键在于找到dp[i][j]，此时的i j能做出实质性的改变，也即跳过那些非公共元素，非公共元素不会影响dp[][]的值，因此对于相同行和列相邻且相同的dp[][]直接跳过，那些元素不是公共元素。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//边界初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//状态转换</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++) &#123;<br><span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>vector &lt;<span class="hljs-type">char</span>&gt; aimStr;<br><span class="hljs-type">int</span> k = dp[m][n];<br><span class="hljs-type">int</span> i = m;<br><span class="hljs-type">int</span> j = n;<br><span class="hljs-keyword">while</span> (k&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][j] == dp[i - <span class="hljs-number">1</span>][j])<br>--i;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i][j] == dp[i][j - <span class="hljs-number">1</span>])<br>--j;<br><span class="hljs-keyword">else</span><br>&#123;<br>aimStr.<span class="hljs-built_in">push_back</span>(a[i - <span class="hljs-number">1</span>]);<br>--i; --j; --k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;长度为：&quot;</span> &lt;&lt; dp[m][n];<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;序列为:&quot;</span>&lt;&lt;endl;<br>vector &lt;<span class="hljs-type">char</span>&gt;::reverse_iterator rit;<br><span class="hljs-keyword">for</span> (rit = aimStr.<span class="hljs-built_in">rbegin</span>(); rit != aimStr.<span class="hljs-built_in">rend</span>(); ++rit)<br>cout &lt;&lt; *rit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input m,n&quot;</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string A&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string B&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br><span class="hljs-built_in">display</span>(A,B,m,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：求两个字符串A B的最长公共连续子串<br>来源P302</p></blockquote><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>字面意思 注意:不必连续</p></blockquote><p>到现在已经写了三个问题了，不难发现dp是一种思想，最关键在于状态的设置及其转换，分类讨论的思想也举足轻重。<br>假定有序列：1 2 3 0 1 5 2 3 4<br>结果是：0 1 2 3 4（不必连续，跳过5）<br>首先要知道最长长度，其次是去构造。<br><em><strong>设dp[i]为序列中以s[i]之前的最长递增子序列</strong></em><br>则有<br><em><strong>dp[i]&#x3D;1 and dp[i]&#x3D;max{dp[i],dp[j]+1},a[i]&gt;a[j] 0&lt;&#x3D;i&lt;&#x3D;n-1 0&lt;&#x3D;j&lt;&#x3D;i-1</strong></em><br>明显需要用到以外层循环定界的二重循环<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>&amp; ans)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>dp[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (s[i] &gt; s[j])<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>ans = <span class="hljs-built_in">max</span>(ans,dp[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">solution</span>(S, n,ans);<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列编辑问题"><a href="#序列编辑问题" class="headerlink" title="序列编辑问题"></a>序列编辑问题</h2><blockquote><p>将A串编辑成B串的最小步数，操作方法有：删字符 插字符 换字符</p></blockquote><p><em><strong>设dp[i][j]为将A串的前i个元素编辑成B串的前j个元素所用的最少步数</strong></em><br>分析:若A[i-1]&#x3D;B[j-1] 则不必理会 <em><strong>dp[i][j]&#x3D;dp[i-1][j-1]</strong></em>;<br>若A[i-1]!&#x3D;B[j-1] 则可以通过三种方式完成：<br>1.将A[i-1]换成B[i-1]：dp[i][j]&#x3D;1+dp[i-1][j-1];<br>2.插入B[j-1]：dp[i][j]&#x3D;1+dp[i][j-1];<br>3.删除A[i-1]：dp[i][j]&#x3D;1+dp[i-1][j];<br>最终的结果是去这三种不同操作的最小值：<em><strong>dp[i][j]&#x3D;1+min{dp[i-1][j-1],dp[i][j-1],dp[i-1][j]}</strong></em><br>同时还有边界条件：当A为空时，则插入B.length次,当B为空时，则删除B.length次<br><em><strong>dp[x][0]&#x3D;x,dp[0][x]&#x3D;x</strong></em></p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* A, <span class="hljs-type">char</span>* B, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[<span class="hljs-number">0</span>][i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] == B[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>, n=<span class="hljs-number">0</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input A\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input B\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;min edit step: &quot;</span> &lt;&lt;dp[m][n] ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><blockquote><p>n种物品 每种物品都有其重量和价值 每种物品只有一个 在限定总重W下尽可能获得最大的价值。</p></blockquote><p>给物品标上序号：x1…xn x为1则是拿走该物品，为0则不拿走<br>设dp[i][j]表示当容量为j时，物品1-i装入背包的最高价值。<br>dp[i][0]&#x3D;0 dp[0][j]&#x3D;0 dp[i][j]&#x3D;max{dp[i-1][j-w[i]]+v[i],dp[i-1][j]}<br>问题的解为dp[n][W];<br>设n&#x3D;5 W&#x3D;10 w[5]&#x3D;{2,2,6,5,4} v[5]&#x3D;{6,3,5,4,6} 下标从1开始<br>dp[1][1]:1个物品1个重量：   重量不够 只能不选                     价值：0<br>dp[1][2]:1个物品2个重量：   重量足够 决策max{dp[0][0]+6,dp[0][2]} 价值：6<br>dp[1][3]:1个物品3个重量：   重量足够 决策max{dp[0][1]+6,dp[0][3]} 价值：6<br>dp[1][4]:1个物品4个重量：   重量足够 决策max{dp[0][2]+6,dp[0][4]} 价值：6<br>dp[1][5]:1个物品5个重量：   重量足够 决策max{dp[0][3]+6,dp[0][5]} 价值：6<br>dp[1][6]:1个物品6个重量：   重量足够 决策max{dp[0][4]+6,dp[0][6]} 价值：6<br>dp[1][7]:1个物品7个重量：   重量足够 决策max{dp[0][5]+6,dp[0][7]} 价值：6<br>dp[1][8]:1个物品8个重量：   重量足够 决策max{dp[0][6]+6,dp[0][8]} 价值：6<br>dp[1][9]:1个物品9个重量：   重量足够 决策max{dp[0][7]+6,dp[0][9]} 价值：6<br>dp[1][10]:1个物品10个重量： 重量足够 决策max{dp[0][8]+6,dp[0][10]} 价值：6</p><p>dp[2][1]:2个物品1个重量：   重量不够 只能不选                      价值：0<br>dp[2][2]:2个物品2个重量：   重量足够 决策max{dp[1][0]+3,dp[1][2]}  价值：6<br>dp[2][3]:2个物品3个重量：   重量足够 决策max{dp[1][1]+3,dp[1][3]}  价值：6<br>dp[2][4]:2个物品4个重量：   重量足够 决策max{dp[1][2]+3,dp[1][4]}  价值：9<br>dp[2][5]:2个物品5个重量：   重量足够 决策max{dp[1][3]+3,dp[1][5]}  价值：9<br>dp[2][6]:2个物品6个重量：   重量足够 决策max{dp[1][4]+3,dp[1][6]}  价值：9<br>dp[2][7]:2个物品7个重量：   重量足够 决策max{dp[1][5]+3,dp[1][7]}  价值：9<br>dp[2][8]:2个物品8个重量：   重量足够 决策max{dp[1][6]+3,dp[1][8]}  价值：9<br>dp[2][9]:2个物品9个重量：   重量足够 决策max{dp[1][7]+3,dp[1][9]}  价值：9<br>dp[2][10]:2个物品10个重量：   重量足够 决策max{dp[1][8]+3,dp[1][10]}  价值：9<br>dp[3][1]:3个物品1个重量：   重量不够 只能不选                      价值：0</p><p>跟着dp设计分析一遍发现：还<del>真</del>是~ 验证一下最终结果?dp[5][10]&#x3D;max{dp[4][10],dp[4][10-w[4]]+v[4]}…以此类推</p><blockquote><p>01背包问题，只要记住dp的设计即可。其他只要你验证就发现是对的，也不难，但是麻烦，只要牢记这样子做是对的，就这样做即可。都是前辈们铺好了的路。<br>另一个值得考虑的问题是，如何构造出具体的方案，每个dp总是这样，通过设计dp数组和递推方程给出结果，但具体的方案，一般是通过dp的设计思路并结合最终结果<em><strong>反推</strong></em>得到的：<br>源程序：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W=<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//下标为0的不用 不然不便于展现清晰的思路</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">bool</span> x[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-literal">false</span> &#125;;<span class="hljs-comment">//表示编号为下标的背包有没有被选 0就是选了 1就是没选 便于输出方案</span><br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Knap01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//先写边界条件，发现其他dp也都是如此</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=W;i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//然后由递推方程构建dp各项</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-comment">//leftWeight为可用的重量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> leftWeight = <span class="hljs-number">1</span>; leftWeight &lt;= W; leftWeight++)<br>&#123;<br><span class="hljs-keyword">if</span> (leftWeight &lt; w[i])<span class="hljs-comment">//可用重量小于当前物品重量 则不可选</span><br>dp[i][leftWeight] = dp[i - <span class="hljs-number">1</span>][leftWeight];<br><span class="hljs-keyword">else</span><br>&#123;<br>dp[i][leftWeight] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][leftWeight],dp[i<span class="hljs-number">-1</span>][leftWeight-w[i]]+v[i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//已经求出了dp各项，现要根据dp项构造出选择方案；根据之前的分析发现：如果因为决策没选择和因为重量不够而不选择，他们的结构都一样</span><br><span class="hljs-comment">//他们的递推式都一样，因为原因不重要，重要的是你到底选没有选择。因此，只要你没有选择，我就要使用对应的递推方程；</span><br><span class="hljs-comment">//反过来说，要是你满足某个递推方程，那么你就一定没被选，再进一步，如果你不满足那个递推式，那你就一定被选了。</span><br><span class="hljs-comment">//循环的边界情况都已经考虑好了，因此只要记住即可</span><br><span class="hljs-type">int</span> i = n;<br><span class="hljs-type">int</span> leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] != dp[i - <span class="hljs-number">1</span>][leftWeight])<br>&#123;<br>x[i] = <span class="hljs-literal">true</span>;<br>leftWeight -= w[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>x[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>i--;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Knap01</span>();<br><span class="hljs-built_in">choose</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;选择的物品编号：\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (x[i] == <span class="hljs-number">1</span>)<br>cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n总价值为：&quot;</span> &lt;&lt; dp[n][W];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><blockquote><p>在01背包的基础上:那些物品每样都有无穷多个。求此时的最大价值选法。<br>真·多重背包问题将在AcWing部分解决。</p></blockquote><p>分析：在01的问题上增设一个属性：物品的数量，dp还是那个dp，dp[i][j]：在重量为j的情况下选择1-i号物品的最大收益，但此时还要增加另一个变量fk[i][j]表示dp[i][j]下i物品选择的数量。</p><p>dp[i][j]&#x3D;max{dp[i-1][j-k<em>w[i]]+k</em>v[i],dp[i-1][j]},第一项也是关于K的最大值函数。<br>设：n&#x3D;3 W&#x3D;7 w[4]&#x3D;{0,3,4,2} v[4]&#x3D;{0,4,5,3}<br>dp[0][x]&#x3D;dp[x][0]&#x3D;0<br>dp[1][1]&#x3D;0 dp[1][2]&#x3D;0 dp[1][3]&#x3D;4(k&#x3D;1) dp[1][4]&#x3D;4(k&#x3D;1) dp[1][5]&#x3D;4(k&#x3D;1) d[1][6]&#x3D;8(k&#x3D;2) dp[1][7]&#x3D;8(k&#x3D;2)</p><p>dp[2][1]&#x3D;0 dp[2][2]&#x3D;0 dp[2][3]&#x3D;4 dp[2][4]&#x3D;max{dp[1][3],dp[1][4-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][5]&#x3D;max{dp[1][5],dp[1][5-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][6]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0) dp[2][7]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0)…</p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> fk[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= W; i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//背包序号dp的i</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> leftWeight=<span class="hljs-number">1</span>;leftWeight&lt;=W;leftWeight++)<span class="hljs-comment">//剩余重量dp的j</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * w[i] &lt;= leftWeight; k++)<span class="hljs-comment">//数量fk的值</span><br>&#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] &lt; dp[i - <span class="hljs-number">1</span>][leftWeight - k * w[i]] + k * v[i])<span class="hljs-comment">//找出最大值对应的K</span><br>&#123;<br>dp[i][leftWeight] = dp[i<span class="hljs-number">-1</span>][leftWeight-k*w[i]]+k*v[i];<br>fk[i][leftWeight] = k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大价值是：&quot;</span> &lt;&lt; dp[n][W];<br><span class="hljs-keyword">return</span> dp[n][W];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i = n, leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;物品&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;拿走了&quot;</span> &lt;&lt; fk[i][leftWeight] &lt;&lt; <span class="hljs-string">&quot;件数&quot;</span>;<br>leftWeight -= fk[i][leftWeight] * w[i];<br>--i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">initial</span>();<br><span class="hljs-built_in">MaxValue</span>();<br><span class="hljs-built_in">choose</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h2><blockquote><p>将有限的资源分配给有限的使用者，使得总收益最大。是完全背包问题的变式</p></blockquote><h2 id="会议安排"><a href="#会议安排" class="headerlink" title="会议安排"></a>会议安排</h2><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><blockquote><p>dp数组项在构建时，往往只会利用前几项，或者说，某一项只会在构建出其后几项被利用，如果最终的结果只要求最终项，那么很多项在被利用后是可以抛弃的，这部分空间完全是浪费了，因此设置滚动数组压缩存储空间。一般是通过取模运算完成。</p></blockquote><p>举例：斐波那列数列的dp数组 <em><strong>元素依赖跨度</strong></em>为3 设置dp[3]<br>于是dp[i%3]&#x3D;dp[(i-2)%3]+dp[(i-1)%3]<br>01Knap 元素依赖跨度为第一维的i 跨度为2 设置dp[2][j]<br>前者的值只有0,1 可以考虑取模但很傻，可以考虑用初始x&#x3D;0；之后x&#x3D;1-x；代替取模运算，核心不变，就是通过手段将数组存储空间压缩为其元素依赖跨度即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis基础</title>
    <link href="/2023/11/20/MyBatis/"/>
    <url>/2023/11/20/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h3><p>创建spring项目，添加项目依赖，选择SQL大选项，选择里面的mybatis framework和mysql driver</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>在application.properties中添加数据库四大件和必要的配置：日志显示和自动处理命名风格</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">zyq2004zyq</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatisstudy</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mybatis log:mybatislog-impl std</span><br><span class="hljs-attr">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#camel :mybatis naming map</span><br><span class="hljs-attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>安装mybatisX插件</p><h3 id="structure"><a href="#structure" class="headerlink" title="structure"></a>structure</h3><p>根据分层解耦，创建mapper包，并创建mapper接口添加mapper注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span><br></code></pre></td></tr></table></figure><p>创建实体类以及其所在的包pojo，可以利用lombok方便生成其构造方法 getter setter tostring等基本方法,使用前需要在pom.xml中添加依赖,其实也可以不这么做，直接在创建项目时就勾选开发依赖lombok，其实这两种方法没什么本质区别，熟练后直接在创建的时候添加就好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>在mybatis中，主要以两种形式完成与数据库的信息交换，一种是映射注释的风格，另一种是XML文件的风格。对于简单的SQL语句，直接用映射的形式，对于复杂的SQL语句更建议用XML的形式</p></blockquote><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>每种SQL语句都有其对应的注释。在mapper接口中添加public方法，对这个方法添加相应的注释，注释后的括号就是要执行的sql语句。</p><p>更多细节：为了方便在设计时不必取别名，必须始终严格遵守pojo类的属性与数据库中表的属性相同，下划线式转驼峰即可。因此对于涉及到多个属性的SQL语句，可以直接用对象的形式封存，mybatis自动完成了存取，你只需要保持一切都能对应上即可。</p><ol><li><p>通过参数进行SQL语句的执行是必不可少的，比如删除某个id为xx的数据。因此这里涉及到传参，通过#{id}实现即可。另外还有￥{}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//#&#123;&#125;预编译 换成？ 用于参数传递</span><br><span class="hljs-comment">//$&#123;&#125; 直接拼接 存在sql注入问题 表名和列表动态设置时使用</span><br><span class="hljs-meta">@Delete(&quot;delete from emp where id=#&#123;id  &#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行某些sql语句后，时常需要返回他的主键，进行更进一步的sql操作，<em><strong>主键返回</strong></em>：需要用到option注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主键返回</span><br><span class="hljs-comment">//useGeneratedKeys获取生成的属性 赋予给keyProperty属性</span><br><span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br><span class="hljs-meta">@Insert(&quot;insert into emp(username,name,gender,image,job,entrydate,dept_id,create_time,update_time)&quot;+</span><br><span class="hljs-meta">        &quot;values(#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert2</span><span class="hljs-params">(Emp emp)</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询语句是有返回值的，只要为上述函数定义返回对应的类型即可，对于查询语句，一般是pojo类的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from emp&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//above is in test</span><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMappingSelect</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Emp&gt; empList=empMapper.select();<br>        System.out.println(empList);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果整个项目都这样写，特别是当SQL语句较复杂时，将不利于维护和编写，因此XML风格的写法是很重要的，而且XML风格能针对一些issue提供有效的solution。</p><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h3><p>在resource文件夹中新建与mapper相同名称路径的目录，建立时记得要&#x3D;&#x3D;<strong>用斜杠</strong>&#x3D;&#x3D;来一次性建立目录，不能用点，然后在此文件夹中创建与mapper接口相同名称的&#x3D;&#x3D;xml&#x3D;&#x3D;文件。然后写入基本的配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mbbasic.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sb&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mbbasic.pojo.Emp&quot;</span>&gt;</span><br>    select * from emp<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用时，需要用mapper标签中的namespace属性来标记出对应的mapper接口路径，路径&#x3D;&#x3D;包括接口本身&#x3D;&#x3D;，并且，在执行对应的SQL语句时，需要在sql标签中的id属性设置与mapper接口中方法的同名，只有这样让程序才能能精准定位。对于又返回结果集的select语句，还需要添加resultType标签，并往里写入返回结果集基本元素的pojo类路径，&#x3D;&#x3D;包括类本身&#x3D;&#x3D;。</p><p>总结：有四大要素：</p><ol><li><p>xml文件名和文件路径与mapper接口和mapper包路径对应；</p></li><li><p>mapper标签namespace属性与mapper接口路径对应；</p></li><li><p>sql语句id与mapper接口方法对应；</p></li><li><p>对于查询语句，resultType与pojo类路径对应。</p></li></ol><h3 id="CommonSQL"><a href="#CommonSQL" class="headerlink" title="CommonSQL"></a>CommonSQL</h3><p>对于一般SQL，就是所有属性都能一一对应的比较死板的SQL。这样的SQL很基础，更多用到的是动态SQL，考虑一种情况，当你需要select实体集合时，你编写了sql语句，sql语句中的属性，有时是基于表项属性中的1个，2个，3个…而且还不知道是哪几个，要么你写很多组查询方法，这太麻烦了，肯定不回去考虑，要么你一次性写出基于多个属性的查询，但实际在用的时候你还是可能只基于其中的某一个或多个属性来查询，因此多余的属性将会以null参数的形式传入，这样你将无法得到你想要的结果。查询如此，更新等语句更是如此，要是有一种机制能够帮助你完成类似java中的不定参数函数的功能就会很方便：这就是动态SQL。</p><h3 id="DynamicSQL"><a href="#DynamicSQL" class="headerlink" title="DynamicSQL"></a>DynamicSQL</h3><p>动态SQL对以上issue的solution是提供更多封装好了功能的标签，你只要学会去使用，将思维深度转换为广度，将脑力转换为记忆，以此助人登阶，何其浪漫~</p><p>mybatis提供的标签：<if> <foreach> <where> <set> &#x2F; <sql> <include>分别适用于不同场景，前组是‘关键字’，后两者是‘函数‘。</p><p>更方便的是，在mapper接口的方法的参数中，可以十分笼统地编写形参！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span>;<br>    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Emp emp)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Emp emp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>必须多练才能牢固记忆。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;条件表达式&quot;</span>&gt;</span><br>   要拼接的sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;集合名称&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;集合遍历出来的元素/项&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;每一次遍历使用的分隔符&quot;</span> </span><br><span class="hljs-tag">         <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;遍历开始前拼接的片段&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><br>------------------------------<br>实现delete from emp where id in (1,2,3);<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--删除操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>------------------------------<br>实现不会出现and(单属性查询是不会出现and了 中间间隔的情况也会导致多余and的出现)或者where(select *是没有where字句的)干扰的查询<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR<br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- if做为where标签的子元素 --&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                 and gender = #&#123;gender&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>------------------------------<br>实现不会有逗号干扰的update操作，用set标签替换set语句<br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-comment">&lt;!-- 使用set标签，代替update语句中的set关键字 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>                username=#&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                name=#&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender=#&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span><br>                image=#&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job=#&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate=#&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id=#&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time=#&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>&gt;</span><br> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br><br>---------------------------------<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>            and gender = #&#123;gender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>            and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2023/11/19/VueTrick/"/>
    <url>/2023/11/19/VueTrick/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="属性传值"><a href="#属性传值" class="headerlink" title="属性传值"></a>属性传值</h2><ol><li><p>涉及很多属性的传值时：设计对象并使用v-bind。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const post = &#123;<br>  id: 1,<br>  title: &#x27;My Journey with Vue&#x27;<br>&#125;<br>&lt;BlogPost v-bind=&quot;post&quot; /&gt;<br>//等价于<br>&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p>属性默认值：一般类型：default: xxx 数组或对象类型：default(<em>rawProps</em>) {return {message: ‘hello’,xxx:’xxxx’…}}</p><p>如果声明了 <code>default</code> 值，那么在 prop 的值被解析为 <code>undefined</code> 时，无论 prop 是未被传递还是显式指明的 <code>undefined</code>，都会改为 <code>default</code> 值(即default会抹除undefined)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-comment">// 基础类型检查</span><br>  <span class="hljs-comment">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br>  <span class="hljs-comment">// 多种可能的类型</span><br>  <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>  <span class="hljs-comment">// 必传，且为 String 类型</span><br>  <span class="hljs-attr">propC</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// Number 类型的默认值</span><br>  <span class="hljs-attr">propD</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  <span class="hljs-comment">// 对象类型的默认值</span><br>  <span class="hljs-attr">propE</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>    <span class="hljs-comment">// 对象或数组的默认值</span><br>    <span class="hljs-comment">// 必须从一个工厂函数返回。</span><br>    <span class="hljs-comment">// 该函数接收组件所接收到的原始 prop 作为参数。</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params">rawProps</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 自定义类型校验函数</span><br>  <span class="hljs-attr">propF</span>: &#123;<br>    <span class="hljs-title function_">validator</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-comment">// The value must match one of these strings</span><br>      <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 函数类型的默认值</span><br>  <span class="hljs-attr">propG</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,<br>    <span class="hljs-comment">// 不像对象或数组的默认，这不是一个</span><br>    <span class="hljs-comment">// 工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">propH</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">MyClass</span><span class="hljs-comment">//可以为自定义的类</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>关于Boolean的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">String</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>规范化：子组件不该直接去改prop.attribute 虽然无法通过这种方式更改父组件中的值，因为单项数据流，但是为了规范，实在要去修改传入的值可以通过计算属性，或者定义响应式变量，初值取自该属性值，以后对这个响应式变量做修改即可。特别是对于&#x3D;&#x3D;数组和对象这样的引用类型&#x3D;&#x3D;，子组件是可以更改并影响到父组件的，而且很难以被发现。对于传入的数组或对象属性更要注意！</p></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li><p>在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p></li><li><p>事件校验：要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <code>emit</code> 的内容，返回一个布尔值来表明事件是否合法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits(&#123;<br>  // 没有校验<br>  click: null,<br><br>  // 校验 submit 事件<br>  submit: (&#123; email, password &#125;) =&gt; &#123;<br>    if (email &amp;&amp; password) &#123;<br>      return true<br>    &#125; else &#123;<br>      console.warn(&#x27;Invalid submit event payload!&#x27;)<br>      return false<br>    &#125;<br>  &#125;<br>&#125;)<br><br>function submitForm(email, password) &#123;<br>  emit(&#x27;submit&#x27;, &#123; email, password &#125;)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ol><li><p>绑定组件：</p></li><li><p>组件内部需要做两件事：</p><ol><li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li><li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>多个v-model：为组件中的不同属性分别绑定，首先要起别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])// 改！<br>defineEmits([&#x27;update:title&#x27;])// 改！<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot; //绑定别名！<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;//update这里也改！<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use:<br>&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt; //绑定title即可<br></code></pre></td></tr></table></figure><p>基于此，设置多个别名并绑定即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  firstName: String,<br>  lastName: String<br>&#125;)<br><br>defineEmits([&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;firstName&quot;<br>    @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;lastName&quot;<br>    @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use<br>&lt;UserName<br>  v-model:first-name=&quot;first&quot;<br>  v-model:last-name=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>4.自定义修饰：</p></li></ol><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><ol><li><p>插槽位于父组件作用域，只能访问父组件中的数据而不能访问子组件中的数据</p></li><li><p>子组件的插槽中&#x2F;<slot>&#x2F;<slot>可以写入数据作为默认值</p></li><li><p>多插槽，为每个插槽起名即可：添加name属性，如不添加则默认名称：default</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件<br>&lt;BaseLayout&gt;<br>  &lt;template v-slot:header&gt;  --&gt;&lt;template #header&gt;具名插槽简写<br>    &lt;!-- header 插槽的内容放这里 --&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br>----------------------------------<br>子组件<br>&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><p>默认情况下，如1.所说，但是有时想要实现属性的传递，在slot标签中绑定属性即可，在父组件使用这个子组件时 在子组件标签处绑定V-SLOT&#x3D;‘properties’ 然后再利用 但目前我还没有想到适合的使用场景，感觉关系很混乱，而且实在要实现其实完全可以用其他更规范的方式。</p></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol><li><p>当父组件想子组件传递数据，常常会用到prop，考虑一颗很高的组件树，如果想要父组件为深层的子组件传递某个值，用prop太难了，为了避免逐级透传，使用提供注入的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, provide &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>provide(&#x27;key&#x27;, count) //注入属性key 值为count 响应式<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>应用层能为所有组件&#x3D;&#x3D;提供&#x3D;&#x3D;：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;)<br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&#x27;hello!&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>为子组件&#x3D;&#x3D;注入&#x3D;&#x3D;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; inject,ref &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>count = inject(&#x27;count&#x27;,99999)-----99999是默认值，当父组件没有提供属性值时，采用这个<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>原则：<strong>尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>，提高内聚性，易于维护。</p></li><li><p>Symbol:大型的应用，包含非常多的依赖提供，或者编写提供给其他开发者使用的组件库，最好使用 Symbol 来作为注入名以避免潜在的冲突。</p><p>先在一个单独的js文件中导出这些注入名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//in symbols.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectionKey = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-comment">//in provident</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-title function_">provide</span>(myInjectionKey, &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">  要提供的数据</span><br><span class="hljs-comment">*/</span> &#125;);<br><span class="hljs-comment">//in injection</span><br><span class="hljs-comment">// 注入方组件</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(myInjectionKey)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/19/hello-world/"/>
    <url>/2023/11/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2023-11-19 12:00</p><p>Hello World…</p><blockquote><p>Lawyers, I suppose, were children once.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
