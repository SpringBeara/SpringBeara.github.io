<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaWeb基础实例1</title>
    <link href="/zyq.github.io/2025/03/04/%E9%A1%B9%E7%9B%AE/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/JavaWebInstance/"/>
    <url>/zyq.github.io/2025/03/04/%E9%A1%B9%E7%9B%AE/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/JavaWebInstance/</url>
    
    <content type="html"><![CDATA[<h1 id="员工部门管理系统——后端"><a href="#员工部门管理系统——后端" class="headerlink" title="员工部门管理系统——后端"></a>员工部门管理系统——后端</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>创建一个spring项目，添加4个依赖：spring web，mybatis framework，mysql driver，lombok。</li><li>数据库配置文件：application.properties:数据库连接经典四件套 和 两个经典mybatis优化配置 log和camelCase</li><li>MVC代码框架：<ol><li>pojo：Emp，Dept，Result</li><li>controller：@restController @autowired class:EmpController DeptController</li><li>service：@service interface:EmpService DepService class:EmpServiceImp DeptServiceImp</li><li>mapper：@mapper interface</li><li>mapper.XML：执行动态SQL必不可少的文件</li></ol></li><li>其他：<ol><li>@Slf4j 用于类中日志操作</li><li>RequestMapping(“&#x2F;api”):设置统一父路径</li><li>@GetMapping @DeleteMapping @PostMapping @PutMapping 约束数据交流方法</li><li>@data @allArgxxx @noArgxxx </li><li>动态SQL的相关知识点：各种标签的使用和处理</li></ol></li><li>注：代码初步框架如上，但在开发过程中，为了实现需求，还会增加其他的类和依赖和配置文件。</li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>实现员工-部门的小型后台管理系统：</p><blockquote><ol><li>实现员工和部门的增删查改；</li><li>登录校验和异常处理。</li></ol></blockquote><p>具体分析：</p><ol><li>为了完成员工和部门的增删查改。<strong>动态SQL</strong>是必须的，因此在上述代码框架中还要增加相应的XML文件完成动态SQL。员工的属性有头像，因此涉及到<strong>文件的上传</strong>，可以考虑用本地存储或阿里云OSS，若为阿里云OSS还必须创建aliOSSUtil类，两种方法都要创建一个uploadController来完成上传文件的控制。<strong>分页查询</strong>也是必要的，因此需要创建一个PageBean类存储返回的数据和数据条目数。</li><li>为了完成登录校验，可以利用JWT和拦截器，因此需要一个jwt的工具类专门来生成和转换jwt，需要一个登录拦截器类和拦截器的注册类，而登录操作也可以创建一个loginController。为了完成异常处理，定义一个全局异常处理类。</li><li>为了完成上述功能，除了定义额外的类，还需要必要的依赖和配置文件。而这些都是在具体的开发过程中慢慢完善的。在本阶段先分析到这一步。</li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>考虑到需要返回信息给前端，因此可以设置一个返回结果类，封装返回码，状态和数据，数据直接用最泛的Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码，1 代表成功; 0 代表失败</span><br>    <span class="hljs-keyword">private</span> String msg;  <span class="hljs-comment">//响应信息 描述字符串</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//返回的数据</span><br><br>    <span class="hljs-comment">//增删改 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,data);<br>    &#125;<br>    <span class="hljs-comment">//失败响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,msg,<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由开发过程的分析：依次从controller,service interface,service class,mapping interface(or with XML)完成业务的实现。</p><h3 id="简短的增删查改（部门增删查改）"><a href="#简短的增删查改（部门增删查改）" class="headerlink" title="简短的增删查改（部门增删查改）"></a>简短的增删查改（部门增删查改）</h3><p>对于简短的增删查改，可以行云流水地实现在mapper层，不必写在xml中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">deptController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> deptService deptService;<br><br>    <span class="hljs-comment">//getMapping,对于get请求的映射 等价于---@RequestMapping(value = &quot;/depts&quot; , method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptList</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;查询所有部门数据&quot;</span>);<br>        List&lt;Dept&gt; deptList=deptService.deptList();<br>        <span class="hljs-keyword">return</span> Result.success(deptList);<br>    &#125;<br><br>    <span class="hljs-comment">//获取路径参数 pathVariable注解</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptDel</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;删除部门，id：&quot;</span>+id);<br>        deptService.deptDel(id);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptIns</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;添加部门:&quot;</span>+dept.getName());<br>        deptService.deptIns(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptMod</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;修改部门:&quot;</span>+dept.getId());<br>        deptService.deptMod(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个函数对应一种业务，从controller开始，层层定义，实现。具体实现中值得注意的地方有：</p><blockquote><ol><li>@RequestBody</li><li>@RequestMapping</li><li>Result.success()和Result.success(object)</li><li>特殊属性记得每次都更新：updateTime</li></ol></blockquote><p>当设计较为复杂的业务时：分页查询，动态sql，文件处理。可以按以下策略进行：</p><h3 id="动态增删查改（员工增删查改）"><a href="#动态增删查改（员工增删查改）" class="headerlink" title="动态增删查改（员工增删查改）"></a>动态增删查改（员工增删查改）</h3><p>对于“查”，不仅是动态的，而且是分页的。当数据很多的时候，总不能够全都塞在页面吧，因此要设计分页的机制。前端向后端提供页码和每页的大小。</p><p>后端根据页码和每页的大小，算出每页显示的元素的范围，用select limit完成操作。同时，前端尝尝还需要统计总的数据量给用户，因此需要用到sql中的count函数。后端将具体的信息和总的数据数返回给前端，这样一看，需要返回两种数据了，因此考虑专门设计一个类来返回这些数据。于是PageBean类由此诞生，当然，它属于pojo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageBean</span> &#123;<br><span class="hljs-comment">//    List&lt;Emp&gt; empList;</span><br>   <span class="hljs-comment">/* 这里不要用EmpList，因为将来所有的分页查询都会用到这个类，不能在这里限定泛型*/</span><br>    <span class="hljs-keyword">private</span> List rows;<br>    <span class="hljs-keyword">private</span> Long total;<br>&#125;<br></code></pre></td></tr></table></figure><p>那后端还需要获取到前端传过来的参数：页码，每页大小，并且考虑实际运用，还需要设定默认值从第一页开始默认页码为xx，这些业务的实现需要用到：</p><blockquote><p>@RequestParam(defaulValue&#x3D;“xxx”)</p></blockquote><p>再接着思考，查询时添加条件是完全必要的，动态添加条件更是重要，因此考虑动态sql，因此，为了一次实现，万金油的利用，如果可以的话，将所有表属性作为参数执行动态SQL将会是一劳永逸的。当然还是得结合实际情况，要是根本不可能去根据某些属性来查询，那就确实没必要编写含有它的动态SQL了。因此可以设计出如下的controller代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里是根据分页，姓名，性别，入职日期几个属性完成的条件查询</span><br><span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectEmpFilter</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span><br><span class="hljs-params">                                  String name, Short gender,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span><br>    &#123;<br>        log.info(<span class="hljs-string">&quot;条件查询对应的员工&quot;</span>);<br>        PageBean pageBean=empService.selectEmpFilter(page,pageSize,name,gender,begin,end);<br>        <span class="hljs-keyword">return</span> Result.success(pageBean);<br>    &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;ids&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delEmp</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer[] ids)</span>&#123;<br>        empService.delEmp(ids);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br></code></pre></td></tr></table></figure><p>对应的XML实现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.instance.mapper.empMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterRows&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.instance.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>            <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                    name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                    and gender = #&#123;gender&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                    and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>            limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<br>--             order by update_time desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>        select count(*) from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                and gender = #&#123;gender&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delEmp&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的几个点：</p><blockquote><ol><li><p>name like concat (‘%’,#{name},’%’) ：利用concat 既能实现拼接又能防止sql注入！</p></li><li><p>name !&#x3D;null and name!&#x3D;‘’ 这里是空的引号，千万不要加空格，否则会出现很<del>傻逼</del>的错误：NumberFormatException: For input string:“xx”&lt;-这里是你输入的name，他认为你输入了number；</p></li><li><p>最重要的还得是动态sql到底是如何实现的，那几个关键字一定要学会使用<foreach> <where> <if>……</p></li><li><p>还有一点就是XML建立时，确定对应的函数的那几个对应，一定也要记住；</p></li><li><p>对于日期的处理，可以使用@DateTimeFormat(pattern&#x3D;“yyyy-MM-dd”)来规范，前端不按照这个格式传，就会返回对应的提示警告。</p></li></ol></blockquote><h3 id="文件上传（带头像的员工的增改）"><a href="#文件上传（带头像的员工的增改）" class="headerlink" title="文件上传（带头像的员工的增改）"></a>文件上传（带头像的员工的增改）</h3><p>上传文件，由于文件与其他一般数据不同，需要在前段端和后端都进行额外处理。</p><p>前端：form表格中 method&#x3D;“post” enctype&#x3D;“multipart&#x2F;form-data” input中type&#x3D;‘file’ name&#x3D;‘xxx(设为image)’</p><p>设置好这些后，前端通过post方法传给后端的body中就会包含一般数据和类型为MultipartFile的文件，名称为：xxx（image），后端接受时应保持名称的一致，若是非要不同，可以采用：@RequestParam(“image”) MultipartFile file)来映射名称。</p><p>为了实现文件上传，不如将其考虑为单独的一个controller层，因此设置：uploadController类，然后在这个类中编写相应的代码。</p><p>至此，后端可以接受到前端传来的文件数据，但若不将其存储下来，他将是ephemeral的，存放在本地，数据量少尚可如此，倘若数据量大了就不现实也不安全，可以考虑阿里云的oos服务。</p><blockquote><p>为文件上传专门定义一个接口，在添加或修改员工头像时调用并自动回显，这并不与添加或修改操作本身冲突，因为在选择文件的那瞬间就调用了upload接口，而另外的是另外的接口&#x2F;emps &#x2F;emps&#x2F;update</p></blockquote><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><p>先创建一个文件夹专门存放这些数据，在这里就已经提前想到了，可能会有同名文件的存在，可以通过uuid来解决这个问题。为了存放文件，必须知道（获取）文件的名称，大小，内容，输入流，和存储具体的方法。MultipartFile 常见方法中包括了这些： </p><blockquote><ul><li>String  getOriginalFilename();  &#x2F;&#x2F;获取原始文件名</li><li>void  transferTo(File dest);     &#x2F;&#x2F;将接收的文件转存到磁盘文件中</li><li>long  getSize();     &#x2F;&#x2F;获取文件的大小，单位：字节</li><li>byte[]  getBytes();    &#x2F;&#x2F;获取文件内容的字节数组</li><li>InputStream  getInputStream();    &#x2F;&#x2F;获取接收到的文件内容的输入流</li></ul></blockquote><p>还要考虑到文件大小，上传一个较大的文件(超出1M)时会报错，因为springBoot默认最大单个大小为1MB。</p><p>为了扩大一点，需要在application.properties中添加配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#配置单个文件最大上传大小</span><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-comment">#配置单个请求最大上传大小(一次请求可以上传多个文件)</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">100MB</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);<br>        <span class="hljs-comment">//获取原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>        <span class="hljs-comment">//构建新的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">extname</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<span class="hljs-comment">//文件扩展名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extname;<span class="hljs-comment">//随机名+文件扩展名</span><br>        <span class="hljs-comment">//将文件存储在服务器的磁盘目录</span><br>        image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/images/&quot;</span>+newFileName));<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可以进一步完成新增员工和修改员工的功能。</p><p>修改员工的实现：为了增强用户体验，在前端点击修改员工时，表格中应默认提供目前的员工信息，也就是要先返回一次按id的查询，然后再进行一次update操作，因此为了完成这一功能实际上要完成两部分，后端分别写与这些功能对应的接口即可，分别的调用由前端完成。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span><br>                username = #&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null and password != &#x27;&#x27;&quot;</span>&gt;</span><br>                password = #&#123;password&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>                name = #&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender = #&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null and image != &#x27;&#x27;&quot;</span>&gt;</span><br>                image = #&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job = #&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate = #&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id = #&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time = #&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;在empServiceImp中还应设置updateTime，对于这一点一定要注意，只要涉及改动就要默认更新updateTime，添加员工时还需要注意设置creteTime。</p><h4 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h4><p>可以创建一个util类，当然，不要忘记@component。</p><p>要提前购买和开通oss服务，创建一个bucket，这里有四个关键信息需要保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>; ---&gt;对应着外网访问的endpoint<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后再根据官方给出的示例程序，修改这四个信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;web-framework01&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);<br>        ossClient.putObject(bucketName, fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>若在项目中每涉及到一个第三方技术服务，就将其参数硬编码，那参数变化时要动源码，这是要避免的。难以寻找而且很不优雅。</p><h4 id="参数配置化"><a href="#参数配置化" class="headerlink" title="参数配置化"></a>参数配置化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#自定义的阿里云OSS配置信息</span><br><span class="hljs-attr">aliyun.oss.endpoint</span>=<span class="hljs-string">https://oss-cn-wuhan-lr.aliyuncs.com</span><br><span class="hljs-attr">aliyun.oss.accessKeyId</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.accessKeySecret</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.bucketName</span>=<span class="hljs-string">springbear-instance1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeyId;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br> <br> <span class="hljs-comment">//省略其他代码...</span><br> &#125; <br></code></pre></td></tr></table></figure><h4 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-attr">server.address</span>=<span class="hljs-string">127.0.0.1</span><br>=<span class="hljs-attr">&gt;</span><br><span class="hljs-attr">server</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">port</span>: <span class="hljs-string">8080</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-string">127.0.0.1 #注意数据和属性之间的空格！！</span><br></code></pre></td></tr></table></figure><p>可以看到配置同样的数据信息，yml格式的数据有以下特点：</p><ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心，重数据轻格式</li></ul><p>yml配置文件的基本语法：</p><blockquote><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul></blockquote><p>yml文件中常见的数据格式：</p><p>对象&#x2F;Map集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>数组&#x2F;List&#x2F;Set集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hobby:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">java</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">game</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">sport</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/tlias</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span><br>      <br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">aliyun:</span><br>  <span class="hljs-attr">oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">https://oss-cn-hangzhou.aliyuncs.com</span><br>    <span class="hljs-attr">accessKeyId:</span> <span class="hljs-string">LTAI4GCH1vX6DKqJWxd6nEuW</span><br>    <span class="hljs-attr">accessKeySecret:</span> <span class="hljs-string">yBshYweHOpqDuhCArrVHwIiBKpyqSL</span><br>    <span class="hljs-attr">bucketName:</span> <span class="hljs-string">web-397</span><br></code></pre></td></tr></table></figure><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>对于@value注解，当处理成批的配置文件属性时会很臃肿；可以通过@ConfigurationProperties注解来优化：</p><p>首先要在maven中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>需要创建一个实现类xxxProperties来专门存放这些配置信息，且实体类中的属性名和配置文件当中key的名字必须要一致</p><blockquote><p>比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter &#x2F; setter方法</p></blockquote></li><li><p>需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象</p></li><li><p>在实体类上添加<code>@ConfigurationProperties</code>注解，并通过perfix属性来指定配置参数项的前缀</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AliOSSProperties.java</span><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*阿里云OSS相关配置*/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSProperties</span> &#123;<br>    <span class="hljs-comment">//区域</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-comment">//身份ID</span><br>    <span class="hljs-keyword">private</span> String accessKeyId ;<br>    <span class="hljs-comment">//身份密钥</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret ;<br>    <span class="hljs-comment">//存储空间</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完成的AliOSSUtils工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//当前类对象由Spring创建和管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-comment">//注入配置参数实体类对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AliOSSProperties aliOSSProperties;-----------&gt;把原来的各种属性改成了专门存储属性的类<br>   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),<br>                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());<br>        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span>aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="hljs-string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>还可以通过设置环境变量来完成配置文件的处理。环境变量是在操作系统级别设置的全局变量。它们包含有关操作系统和正在运行的应用程序的信息。应用程序可以读取环境变量以获取配置参数。在大多数操作系统中，可以使用特定的命令来设置和获取环境变量。例如，在Linux和Mac上，可以使用<code>export</code>命令设置环境变量，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">MY_VAR</span>=value<br></code></pre></td></tr></table></figure><p>应用程序可以通过读取<code>MY_VAR</code>环境变量来获取值。</p><blockquote><p>关于配置文件的处理，无非是从程序的可维护性和安全性出发的。<del>非常好程序，这使我的屁股旋转。</del></p></blockquote><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>根据需求：在访问网站时，如果没有登录，则不能进入子路径url，这一点通过&#x3D;&#x3D;过滤器或拦截器&#x3D;&#x3D;来完成，也就是需要对除了&#x2F;login路径外的其他访问，在访问前进行拦截验证，如果已经登录了，则可以完成api的请求，否则不提供服务，为了识别是否登录过了，这一点通过&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;来完成。因此,“登录”不能仅仅只是执行一个查询检验那么简单。</p><h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><p>关于会话、会话跟踪，需要知道：</p><p>&#x3D;&#x3D;会话&#x3D;&#x3D;指的是浏览器与服务器之间的一次连接，我们就称为一次会话。</p><blockquote><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p><ul><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p><code>会话</code>:在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p></li><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p>第2次：访问的是部门管理接口，查询所有部门数据</p></li><li><p>第3次：访问的是员工管理接口，查询员工数据</p></li></ul><p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p></blockquote><p>&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p><blockquote><p>服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我就称为会话跟踪。</p></blockquote><p>使用会话跟踪技术就是要完成在同一个会话中多个请求之间数据的共享。</p><blockquote><p>为什么要共享数据呢？</p><p>由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享</p></blockquote><p>题外话：有没有想过在刷微博或者其他客户端软件时，你所看到的表象是你的账号会显示你所个性化的内容，而别人的账号显示的是别人的个性化内容（关注，粉丝等等等），这都是数据，根据你的ID，这些数据都已存入相应的表中了，根据你的id唯一标识，将这些绑定着id的个性化内容全部连根拔起显示给你。有没有想过为什么网页版会保持登录状态，这个就是会话跟踪技术实现的，他会在一定期限内保留住登录状态。</p><p>可以通过JWT,cookie,session来实现会话跟踪。</p><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>json web token（官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><ul><li><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</p><p>自包含：指的是jwt令牌，看似是一个随机的字符串，但是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</p><p>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</p></blockquote></li></ul><p>JWT的组成： （JWT令牌由三个部分组成，三个部分之间用点来分割）</p><ul><li><p>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”}</p></li><li><p>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”}</p></li><li><p>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。</p><blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，整个jwt令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败。</p></blockquote></li></ul><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>在生成JWT令牌时，会对JSON格式的数据进行一次编码————base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p><p>JWT令牌最典型的应用场景就是登录认证：</p><ol><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。</li><li>前端拿到jwt令牌之后，会将jwt令牌存储(浏览器localStorage)起来。在后续的每一次请求中都会将jwt令牌携带到服务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。</li></ol><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：</p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><p>为此定义一个工具类JWTutil。</p><p>当然，首先要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JWTutil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTutil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String signKey=<span class="hljs-string">&quot;springbear&quot;</span>;<br>    <span class="hljs-comment">//有效期30天</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30L</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genJWT</span><span class="hljs-params">(Map&lt;String,Object&gt; claims)</span>&#123;<br>        String jwt= Jwts.builder()<br>                .addClaims(claims)    <span class="hljs-comment">//自定义消息--有效载荷---有效载荷中存放什么数据也要和前端沟通好。这个项目中是id username 和 name</span><br>                .signWith(SignatureAlgorithm.HS256, signKey)    <span class="hljs-comment">//签名算法</span><br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis()+expire))<br>                .compact();<br>        <span class="hljs-keyword">return</span> jwt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseJWT</span><span class="hljs-params">(String jwt)</span>&#123;<br>        Claims claims=Jwts.parser()<br>                .setSigningKey(signKey)<br>                .parseClaimsJws(jwt)<br>                .getBody();<br>        <span class="hljs-keyword">return</span> claims;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在使用JWT令牌时需要注意：</p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。</li><li>如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。</li></ul><p>因此登录功能的实现又清晰了：登录成功则生成token，执行业务则校验token，若非法，则拦截，合法就放行。</p><p>具体在项目中：前端请求登录，先验证账密是否合法（select），如果登陆成功了，就生成JWT，并将其返回，并且这使得用户在一定时间段内（token有效期间且没有清理浏览器localstorage）不必重复进行登录验证。</p><p>登录功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> empService empService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">loginTry</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span>&#123;<br>        Emp empExist=empService.loginTry(emp);<br>        <span class="hljs-keyword">if</span>(empExist!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            Map&lt;String,Object&gt; claims=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            claims.put(<span class="hljs-string">&quot;id&quot;</span>,empExist.getId());<br>            claims.put(<span class="hljs-string">&quot;username&quot;</span>,empExist.getUsername());<br>            claims.put(<span class="hljs-string">&quot;name&quot;</span>,empExist.getName());<br>            <span class="hljs-comment">//假如登录成功，生成token（一个能被唯一转化的字符串）返回给前端，前端将会获取它并存储。</span><br>            <span class="hljs-comment">//在此后的操作，前端都会携带这个token来进行操作，只要token还在有效期，就能够放行，否则被拦截器拦截。</span><br>            String token=JWTutil.genJWT(claims);<br>            <span class="hljs-keyword">return</span> Result.success(token);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>cookie是客户端会话跟踪技术，存储在客户端浏览器中。用cookie来跟踪会话，可以在浏览器第一次发起服务器请求时，在服务器端来设置一个cookie。</p><p>比如第一次请求了登录接口，登录接口执行完成之后，就可以设置一个cookie，在cookie中就可以来存储用户相关的数据信息。比如在cookie中存储当前登录用户的用户名，ID。</p><p>服务器端给客户端响应数据时会<strong>自动</strong>将cookie响应给浏览器，浏览器接收到此cookie后，会<strong>自动</strong>将cookie的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的cookie<strong>自动</strong>地携带到服务端。</p><p>接下来服务端就可以获取到cookie的值。因此只需要判断这个cookie的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在，就说明客户端之前已经登录完成了。这样就可以基于cookie在同一次会话的不同请求之间来共享数据。</p><p>3个自动：</p><ul><li>服务器<strong>自动</strong>将cookie响应给浏览器。</li><li>浏览器接收到响应回来的数据之后，<strong>自动</strong>将cookie存储在浏览器本地。</li><li>在后续的请求当中，浏览器会<strong>自动</strong>将cookie携带到服务器端。</li></ul><p><strong>为什么这一切都是自动化进行的？</strong></p><p>因为cookie是HTTP协议中所支持的技术，而各大浏览器厂商都支持了这一标准。协议官方给我们提供了一个响应头和请求头：</p><ul><li>响应头 Set-Cookie ：设置Cookie数据</li><li>请求头 Cookie：携带Cookie数据</li></ul><p><strong>优缺点</strong></p><ul><li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带都由浏览器自动进行，无需手动操作）</li><li>缺点：<ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>服务器端会话跟踪技术，存储在服务器端的。Session就是基于Cookie来实现的</p><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案也就失效了。</p></blockquote><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>什么是拦截器？</p><ul><li>是一种动态拦截方法调用的机制，类似于过滤器。</li><li>拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。</li></ul><p>拦截器的作用：</p><ul><li>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。</li></ul><p>在拦截器中通常做一些通用性操作，比如：通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。</p><h5 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h5><p>在注册拦截器时要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>指定要拦截的请求路径，<code>excludePathPatterns</code>指定不拦截的请求路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//拦截器对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//注册自定义拦截器对象</span><br>        registry.addInterceptor(loginCheckInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<span class="hljs-comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<span class="hljs-comment">//设置不拦截的请求路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>基本使用主要包括：定义拦截器，注册拦截器。</p><p>定义拦截器：一个项目中可能有多个拦截器，不妨建立一个拦截器包，对于登录功能中的拦截，定义LoginInterceptor类,(别忘了@component),该类需要实现HandlerInterceptor，并重写其三个方法，特别是prehandle这一方法，他决定着能否放行，因此jwt的验证也在此方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        String token=request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span>(token==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//若存在 则验证合法性</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            JWTutil.parseJWT(token);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            log.info(<span class="hljs-string">&quot;非法token&quot;</span>);<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*分析此实例的流程：</span><br><span class="hljs-comment">* 1. 登录页面不拦截，其他页面拦截，这一点在注册拦截器时控制拦截路径实现。</span><br><span class="hljs-comment">* 2. 其他路径的资源请求，需要携带token(位于请求头中)来若不存在则拒绝并返回相应的信息(json)，若存在则进行验证，合法则放行，否则拒绝并返回相应信息。</span><br><span class="hljs-comment">* 注：为了实现object到json的转换，可以导入阿里的fastjson依赖</span><br><span class="hljs-comment">* 注：返回的erro信息也是有讲究的，不能瞎写，前端需要根据erro中的信息来重定向或者进行其他操作的。比如这里是not_longin,前端获取到就会执行重定向到登录页面</span><br><span class="hljs-comment">* */</span><br></code></pre></td></tr></table></figure><p>注册拦截器：定义一个类WebConfig，该类需要实现webMvcConfigurer，该类中需要重写addInterceptor方法，也是在此类中完成注册拦截器和拦截路径的设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<br>        <span class="hljs-comment">//为除了登录页外的其他页面注册拦截器。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h4><p>再次梳理登录业务：登录时，根据账密判断登录是否成功（select），成功则返回token和成功消息（jwt），否则返回错误信息，在token有效期内，该浏览器中的路径访问不会被阻拦（interceptor放行）。</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/20/b18f88897cc0af29.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>项目编写到这里，以为已经OK了？？实际上忽略了异常处理这一点，因此下次在设计项目时，可以提前考虑。</p><p>当添加部门或者员工时，如果客户端输入的重名了，而数据库又不能完成插入语句，如果没有异常处理，那么前后端将无法完成相应的错误操作，而用户也最好能够得到对应的解释或者哪怕只是简短的提示，也可以通过异常处理来实现，捕获异常后，后端向前端返回额外的消息，前端再经过处理提示给用户。</p><p>异常处理很简单，在每一处可能会出现异常的地方都try catch显然太杂乱臃肿。因此可以定义一个类，专门处理异常，即：全局异常处理器。</p><ol><li><p>定义全局异常处理器非常简单，定义一个类，为此类加上@RestControllerAdvice，加上这个注解就代表定义了一个全局异常处理器。</p></li><li><p>在类中定义一个方法来捕获异常，此方法需要加注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定要捕获异常的类型。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">//处理异常</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span> <span class="hljs-comment">//指定能够处理的异常类型</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception e)</span>&#123;<br>        e.printStackTrace();<span class="hljs-comment">//打印堆栈中的异常信息</span><br>        <span class="hljs-comment">//捕获到异常之后，响应一个标准的Result</span><br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;对不起,操作失败,请联系管理员&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</p><p>处理异常的方法返回值会转换为json后再响应给前端</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Mybatis</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Randomised Algorithm</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/RandomisedAlgorithm/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/RandomisedAlgorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="Randomised-Algorithm"><a href="#Randomised-Algorithm" class="headerlink" title="Randomised Algorithm"></a>Randomised Algorithm</h1><blockquote><p>算法执行过程中面临选择时，随机选择比最优选择更省时，因此随机算法可以很大程度上降低算法的复杂度。主要分为四种随机算法：</p><ul><li>数据概率算法：用于数值问题的求解，随着算法执行时间延长，其得到的近似解的结果与真实结果越相近。</li><li>Las Vegas算法：一旦找到解，解一定正确，但有限度，一旦超过限度，则说明无法找到解，算法失败。</li><li>Monte Carlo算法：一定能找到解，但解不一定正确，执行时间越久，解正确的概率越大。</li><li>Sherwood算法：一定能找到正确的解，用于某确定性算法最坏时间复杂度与平均时间复杂度相差较大的情况，通过降低特定用例与最坏行为之间的关联度来完成优化，比如快速排序中，基准元素选择随机元素。</li></ul></blockquote><h2 id="MonteCarlo"><a href="#MonteCarlo" class="headerlink" title="MonteCarlo"></a>MonteCarlo</h2><blockquote><p>用蒙特卡洛算法求π 设有一个边长为2的正方形，正方形内有一个内切圆，则他们的面积比为4:π. 设有一个随机点，x y随机取到[0,1](只考虑第一象限)</p><p>则x y落在圆内的次数 : x y生成的总次数(足够多),就近似于4:π，设x y总生成次数为n 落在圆内次数为m 则m&#x2F;n&#x3D;4&#x2F;π 因此：π&#x3D;4m&#x2F;n.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randa</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>() % (b - a + <span class="hljs-number">1</span>) + a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">randa01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">randa</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) * <span class="hljs-number">1.0</span> / <span class="hljs-number">100</span>;<span class="hljs-comment">//1.0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">approximatePI</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">double</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<span class="hljs-comment">//double xy!!</span><br><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>x = <span class="hljs-built_in">randa01</span>(); y = <span class="hljs-built_in">randa01</span>();<br><span class="hljs-keyword">if</span> (x * x + y * y &lt;= <span class="hljs-number">1.0</span>)<br>m++;<br>&#125;<br><span class="hljs-keyword">return</span>  <span class="hljs-number">4.0</span>* m / n;<span class="hljs-comment">//4.0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<span class="hljs-comment">//很重要！随机种子</span><br>cout&lt;&lt; <span class="hljs-built_in">approximatePI</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Las-Vegas"><a href="#Las-Vegas" class="headerlink" title="Las Vegas"></a>Las Vegas</h2><blockquote><p>用拉斯维加斯算法求N皇后问题的一个解，对于每个皇后的纵坐标，都用随机数来试探，直到试探出一组随机数使得条件成立，一旦成立就说明找到了解，否则说明没有找到，很符合Las Vegas算法，而且尝试的次数越多，越容易找到解。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> q[MAX];<br><span class="hljs-type">int</span> times = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randa</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>() % (b - a + <span class="hljs-number">1</span>) + a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; times &lt;&lt; <span class="hljs-string">&quot;次运行找到结果:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (j != q[i]) cout &lt;&lt; <span class="hljs-string">&quot;o &quot;</span>;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;* &quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlace</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (k &lt; i) &#123;<br><span class="hljs-keyword">if</span> ((q[k])==j || <span class="hljs-built_in">abs</span>(q[k]-j) == <span class="hljs-built_in">abs</span>(i-k))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>k++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NQueen</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-built_in">printResult</span>(n);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> tryTimes = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> position = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (tryTimes &lt;= n) &#123;<br>position = <span class="hljs-built_in">randa</span>(<span class="hljs-number">1</span>, n);<br>tryTimes++;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">canPlace</span>(layer, position)) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//退出循环有两种情况：找到了一个解break，此情况需要更进一层。</span><br><span class="hljs-comment">//或者是所有位置都尝试了但还是没找到符合要求的，说明之前有一处找错了，说明这次随机没有解决问题</span><br><span class="hljs-keyword">if</span> (tryTimes &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>q[layer] = position;<br><span class="hljs-built_in">NQueen</span>(layer + <span class="hljs-number">1</span>, n);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">while</span> (times &lt; <span class="hljs-number">100</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">NQueen</span>(<span class="hljs-number">1</span>,n))<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//找到一个解就不找了</span><br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; times++ &lt;&lt; <span class="hljs-string">&quot;次没找到解\n&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Sherwood"><a href="#Sherwood" class="headerlink" title="Sherwood"></a>Sherwood</h2><blockquote><p>用舍伍德算法优化快速排序，由于当快速排序选定的基准元素若为最大or最小值时，此时的时间复杂度最差，因此要避免这种极端情况，可以采用生成随机基准，降低特定实例(基准)与最坏行为(极端情况)的关联来改善快排的实际效率。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randa</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">rand</span>() % (b - a + <span class="hljs-number">1</span>)+a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span> tmp = a[l];<br><span class="hljs-type">int</span> i = l; <span class="hljs-type">int</span> j = r;<br><span class="hljs-keyword">while</span> (i!=j) &#123;<br><span class="hljs-keyword">while</span> (i&lt;j <span class="hljs-keyword">and</span> a[j]&gt;=tmp) j--;<br>a[i] = a[j];<br><span class="hljs-keyword">while</span> (i &lt; j <span class="hljs-keyword">and</span> a[i] &lt;= tmp) i++;<br>a[j] = a[i];<br>&#125;<br>a[i] = tmp;<br><span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &lt; r) &#123;<br><span class="hljs-type">int</span> i = <span class="hljs-built_in">randa</span>(l, r);<br><span class="hljs-built_in">swap</span>(a[l], a[i]);<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">partition</span>(a, l, r);<br><span class="hljs-built_in">QuickSort</span>(a, l, p <span class="hljs-number">-1</span>);<br><span class="hljs-built_in">QuickSort</span>(a, p+<span class="hljs-number">1</span> , r);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">52</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">222</span>&#125;;<br><span class="hljs-comment">/*int a[10] = &#123; 2,5,1,7,10,6,9,4,3,8 &#125;;*/</span><br><span class="hljs-built_in">QuickSort</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>随机算法</tag>
      
      <tag>概率算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法1</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/acwing_basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%951/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/acwing_basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%951/</url>
    
    <content type="html"><![CDATA[<h1 id="基础算法1"><a href="#基础算法1" class="headerlink" title="基础算法1"></a>基础算法1</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(begin &gt;= end)<span class="hljs-keyword">return</span> ;<br>    <br>    <span class="hljs-type">int</span> i = begin - <span class="hljs-number">1</span>, j = end + <span class="hljs-number">1</span>, mid = a[ begin + end &gt;&gt; <span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>        <span class="hljs-keyword">do</span> i++;<span class="hljs-keyword">while</span>(a[i]&lt;mid);<br>        <span class="hljs-keyword">do</span> j--;<span class="hljs-keyword">while</span>(a[j]&gt;mid);<br>        <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">quick_sort</span>(a,begin,j);<br>    <span class="hljs-built_in">quick_sort</span>(a,j+<span class="hljs-number">1</span>,end);    <span class="hljs-comment">//由于递归时 在begin,j 和 j+1，end 两个区间递归 如果基准点选择了 end 可能会导致死循环 同理 对于 begin, i-1和 i，end 则不能选取 begin 为 基准点</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span></span>&#123;<br><span class="hljs-keyword">if</span>(begin &gt;= end)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-type">int</span> mid= begin + end &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(a,begin,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid+<span class="hljs-number">1</span>,end);<br>    <br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=begin,j=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>( i&lt;=mid &amp;&amp; j&lt;=end )<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j]) tmp[k++]=a[i++];<br>    <span class="hljs-keyword">else</span> tmp[k++]=a[j++];<br>    <br>    <span class="hljs-keyword">while</span>(j&lt;=end)tmp[k++]=a[j++];<br>    <span class="hljs-keyword">while</span>(i&lt;=mid)tmp[k++]=a[i++];<br>    <br>    <span class="hljs-keyword">for</span>(i=begin,j=<span class="hljs-number">0</span>;i&lt;=end;j++,i++)a[i]=tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//区间被分为[l,mid-1],[mid,r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch1</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid= l+r+<span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))l=mid;<br>    <span class="hljs-keyword">else</span>r=mid<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">//区间被分为 [l,mid]和[mid+1,r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch2</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>        <span class="hljs-type">int</span> mid= l+r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid))r=mid;<br>    <span class="hljs-keyword">else</span>l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>数的范围：给定义一个有序数组，求出输入的数的起始下标和终止下标 若不存在则返回-1 -1。输入格式：先输入两个数，表示数组长度m和数组中被查找的元素的数目n，第二行输入数组各元素 共m个，后续的n行输入具体的被查找的元素的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100000</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=m<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//寻找左边界 定义check为 a[mid]&gt;= x </span><br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">int</span> mid= l+r &gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(a[mid]&gt;=x) r=mid;<br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//倘若数组中不存在该数</span><br>        <span class="hljs-keyword">if</span>(a[l]!=x)cout&lt;&lt;<span class="hljs-string">&quot;\n-1 -1&quot;</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>           cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;l&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>           <span class="hljs-comment">//再寻找右边界 定义check为 a[mid]&lt;= x</span><br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=m<span class="hljs-number">-1</span>;<br>           <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>               <span class="hljs-type">int</span> mid = l+r+<span class="hljs-number">1</span> &gt;&gt;<span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">if</span>(a[mid]&lt;=x)l=mid;<br>               <span class="hljs-keyword">else</span>r=mid<span class="hljs-number">-1</span>;<br>           &#125;<br>            cout&lt;&lt;l;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//相比整数二分 没那么多边界问题 因此会更加简单 更新区间只要 死板地l=mid 或者 r=mid</span><br><span class="hljs-comment">//例子：求平方根</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    doub accuracy=<span class="hljs-number">1e-6</span>;<span class="hljs-comment">//两种方法，1.控制精度 2.直接循环N次</span><br>    <span class="hljs-type">double</span> x;<br>    cin&gt;&gt;x;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">0</span>,r=x;<span class="hljs-comment">//此处错误 右端点应该是 max(1,x) 因为当0&lt;x&lt;1时 x的平方根应该是大于自身的 此时将会越界 因此 应该将r设置为max(1,x)</span><br>    <span class="hljs-keyword">while</span>(r-l&gt;accuracy)&#123;<br>        <span class="hljs-type">double</span> mid= (l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid &gt;= x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    cout&lt;&lt;l;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="第K小数"><a href="#第K小数" class="headerlink" title="第K小数"></a>第K小数</h3><blockquote><p>输入一个序列，求这个序列的第K小数。输入：序列长度 序列各元素 K 输出：第K小数</p></blockquote><p>用快排的思想可以较高效率地求出。有几个问题：</p><ol><li>每一次递归时，子序列的K要不要改变，即K是全局的，还是序列局部的？</li><li>应该如何快速递归应该传入的参数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-comment">//返回序列a的第K小数 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KthMin</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> a[l];<span class="hljs-comment">//此处用l==r即可 但是在快速排序中 必须是&gt;=</span><br><br><span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>,mid=a[ i+j &gt;&gt;<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(a[i]&lt;mid);<br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(a[j]&gt;mid);<br><span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(a[i],a[j]);<br>&#125;<br><span class="hljs-type">int</span> leftTotal=j-l+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(leftTotal &gt;= k)<span class="hljs-keyword">return</span> <span class="hljs-built_in">KthMin</span>(l,j,k);<span class="hljs-comment">//如果左侧的数数量大于等于K 则说明 第K小的数 就在左侧区间 并且 在左侧区间，也是第K小的数</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">KthMin</span>(j+<span class="hljs-number">1</span>,r,k-leftTotal);<span class="hljs-comment">//如果左侧的数的数量小于K 则说明 原序列第K小的数 就在右侧区间 并且 在右侧区间，应该是第K-leftTotal小的数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//数据定义和初始化 </span><br><span class="hljs-type">int</span>  n,k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><span class="hljs-comment">//输出结果 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">KthMin</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,k));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上面的问题，回答是：</p><p>K是局部的，需要在子序列中相应调整， 并且要根据子序列在基准的左侧or右侧，做出不同的K值调整，结合图形分析，同样，第二个问题也是通过画图的方式来帮助分析最好。<br>递归时不能写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(leftTotal &gt; k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">KthMin</span>(l,j,k);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftTotal &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">KthMin</span>(j+<span class="hljs-number">1</span>,r,k-leftTotal);<br><span class="hljs-keyword">else</span><span class="hljs-keyword">return</span> a[leftTotal<span class="hljs-number">-1</span>];<br><span class="hljs-comment">//本意是想要在k==leftTotal时，就判断 左侧区间的最后一个数 就是要求的数，但是左侧整体不一定是有序的！！！</span><br><span class="hljs-comment">//由于 左侧的数并非有序的，很可能要求的值在左侧区间某个地方而并非端点，不能通过这种方式就判断出返回值。最终的结果只能是通过区间宽度逼近到1的返回，</span><br></code></pre></td></tr></table></figure><h3 id="逆序对数量"><a href="#逆序对数量" class="headerlink" title="逆序对数量"></a>逆序对数量</h3><blockquote><p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n，表示数列的长度。</p><p>第二行包含 n 个整数，表示整个数列。</p></blockquote><p>分治（归并排序）的思想，取区间的中点，那么这个区间的逆序对的数量应该是，左侧区间逆序对的数量+右侧逆序对的数量+跨左右的逆序对的数量，然后对每个子区间按同样的方式来求，知道区间很小，只有两个数字，可以立马得出。然后得到上一层递归的结果，进而得到最终结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//超时代码：由于在比较跨左右的逆序对的数量的 时间性能太差 ，遍历了左右两侧，如果能对左右两侧的序列分别排序，从而找到某个左侧下标后，左侧后续的下标都不必再判断了，这样就能大大提高效率</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function">LL <span class="hljs-title">reversePair</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r-l==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a[l]&gt;a[r];<br><span class="hljs-keyword">if</span>(r&lt;=l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> leftPair=<span class="hljs-number">0</span>,rightPair=<span class="hljs-number">0</span>,betweenPair=<span class="hljs-number">0</span>;<br>leftPair=<span class="hljs-built_in">reversePair</span>(l,mid);<br>rightPair=<span class="hljs-built_in">reversePair</span>(mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-comment">//跨越左右两侧的情况，依次考虑 右侧 中的每一个数，然后对每一个数 统计 左侧 有多少数大于这个数，然后全部加起来 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> leftIndex=l;leftIndex&lt;=mid;leftIndex++)&#123;<br>    <span class="hljs-keyword">if</span>(a[leftIndex]&gt;a[i]) &#123;<br>    betweenPair++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> leftPair+rightPair+betweenPair;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">reversePair</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进后的代码如下：</p><p>思路：仍然是基于分治，在处理跨左右的区域的部分时，会进行排序操作，将左右两端区域都有序化（自底向上的归并排序），再数据量极大时，由于左右两侧的数据都是有序的，因此当找到一个逆序对后，就可以判断左侧剩余的数据都是逆序对，也就是一旦满足a[i]&gt;a[j] 则可以直接求出对于此时右侧那个元素的逆序对的数量了，为：mid-i+1，然后直接复制好元素后移动右侧指针即可。精髓是：一边排序，用来方便上一层（大规模数据）的求解的同时，求出此层的逆序对数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N],tmp[N];<br><br><span class="hljs-function">LL <span class="hljs-title">reversePair</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(r&lt;=l) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>LL leftPair=<span class="hljs-number">0</span>,rightPair=<span class="hljs-number">0</span>,betweenPair=<span class="hljs-number">0</span>;<br>leftPair=<span class="hljs-built_in">reversePair</span>(l,mid);<br>rightPair=<span class="hljs-built_in">reversePair</span>(mid+<span class="hljs-number">1</span>,r);<br><br><span class="hljs-type">int</span> i=l,j=mid+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r )&#123;<br><span class="hljs-keyword">if</span>(a[i]&lt;=a[j])  tmp[k++]=a[i++];<br><span class="hljs-keyword">else</span>&#123;<br>    betweenPair += mid - i + <span class="hljs-number">1</span>; <span class="hljs-comment">//左侧此后一定都满足逆序对，记录好后 直接移动右侧指针</span><br>tmp[k++]=a[j++];<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">while</span>(i&lt;=mid) tmp[k++]=a[i++];<br><span class="hljs-keyword">while</span>(j&lt;=r) tmp[k++]=a[j++];<br><span class="hljs-keyword">for</span>(i=l,j=<span class="hljs-number">0</span>;i&lt;=r;i++,j++) a[i]=tmp[j];<br><span class="hljs-keyword">return</span> leftPair+rightPair+betweenPair;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-built_in">reversePair</span>(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三次方根"><a href="#三次方根" class="headerlink" title="三次方根"></a>三次方根</h3><blockquote><p>求一个数的三次方根</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ACCURACY=<span class="hljs-number">1e-8</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">double</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;n);<br><span class="hljs-type">double</span> l=<span class="hljs-number">-100</span>,r=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">while</span>(r-l&gt;ACCURACY)&#123;<br><span class="hljs-type">double</span> mid = (r+l)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(mid*mid*mid &gt;= n) r=mid;<br><span class="hljs-keyword">else</span> l = mid;<br>&#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.6lf&quot;</span>,l);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>acwing算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法2</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/acwing_basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%952/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/acwing_basic/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%952/</url>
    
    <content type="html"><![CDATA[<h1 id="基础算法2"><a href="#基础算法2" class="headerlink" title="基础算法2"></a>基础算法2</h1><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>大数用vector存储。小下标存储低位数字，便于处理进位，当需要进位时，只需vector数组末尾加上一位，vector有各种方法，便于进行其他处理：size pop等…因此在输入输出时，都需要考虑下标和数字位数的逆序关系。</p><h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><blockquote><p>两个大正整数相加</p></blockquote><p>思路：这些四则运算都是用代码模拟人类的四则运算过程。加法：从低位到高位依次相加，并且考虑是否有进位，有进位则再加1，不然就加0，因此Ci&#x3D;Ai+Bi+t。t不必每一位都设置一个，只需要一个变量表示即可。t初始为0，t&#x2F;10为进位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A, B);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="减"><a href="#减" class="headerlink" title="减"></a>减</h3><blockquote><p>两个大正整数相减</p></blockquote><p>思路：考虑最终的结果为正还是负，因此要先比较A，B的大小，始终用大的数减去小的数，然后根据实际情况考虑是否要加上负号。减法：从低位到高位依次相减，并且考虑是否有借位，当Ai-Bi&lt;0时，则有借位，此时的结果应该为：Ai-Bi+10，同时标记借位为1，因此最终每位的计算公式是 ：Ci&#x3D;Ai-Bi-t。t只需用一个变量表示即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() &gt; B.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>        <span class="hljs-keyword">if</span> (A[i] != B[i])<br>            <span class="hljs-keyword">return</span> A[i] &gt; B[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a, b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A, B;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(A, B)) C = <span class="hljs-built_in">sub</span>(A, B);<br>    <span class="hljs-keyword">else</span> C = <span class="hljs-built_in">sub</span>(B, A), cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) cout &lt;&lt; C[i];<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h3><blockquote><p>大正整数乘小正整数</p></blockquote><p>思路：将小正整数作为一个整体，去依次乘以大正整数的每一位。然后考虑进位，模拟一遍运算过程可以得出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    <span class="hljs-type">int</span> b;<br><br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A, b);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, C[i]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="除"><a href="#除" class="headerlink" title="除"></a>除</h3><blockquote><p>大正整数除以小正整数</p></blockquote><p>思路：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br><br>    <span class="hljs-type">int</span> B;<br>    cin &gt;&gt; a &gt;&gt; B;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A, B, r);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) cout &lt;&lt; C[i];<br><br>    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>长度为N的数组，前缀和数组：S<sub>1</sub>&#x3D;a<sub>1</sub>，S<sub>2</sub>&#x3D;a<sub>1</sub>+a<sub>2</sub>，S<sub>i</sub>&#x3D;a<sub>1</sub>+a<sub>2</sub>+…+a<sub>i</sub>.  <strong>S<sub>i</sub>&#x3D;S<sub>i-1</sub>+a<sub>i</sub>；S<sub>0</sub>&#x3D;0</strong> </p><p>作用：便于计算某一段区间的数的和 如下标[A,B]区间的数的和，则结果为：S<sub>b</sub>-S<sub>a-1</sub></p><p>二维前缀和S<sub>i,j</sub>&#x3D;(i,j)和(0,0)所围矩形区域的所有元素的和：<strong>S<sub>i,j</sub> &#x3D; S<sub>i-1,j</sub> + S<sub>i,j-1 </sub> - S<sub>i-1,j-1</sub> + a<sub>i,j</sub></strong></p><blockquote><p>输入一个长度为 n 的整数序列。</p><p>接下来再输入 m 个询问，每个询问输入一对 l,r。</p><p>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> a[N],b[N];<span class="hljs-comment">//原数组 和 其对应的前缀和数组 </span><br><span class="hljs-type">int</span> n,m;<span class="hljs-comment">//n个数的序列 m个询问 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]=b[i<span class="hljs-number">-1</span>]+a[i];<span class="hljs-comment">//构造前缀和数组</span><br> <br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> l,r;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,b[r]-b[l<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>输入一个 n 行 m列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。</p><p>对于每个询问输出子矩阵中所有数的和。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> a[N][N],b[N][N];<span class="hljs-comment">//原矩阵 和 其对应的前缀和矩阵 </span><br><span class="hljs-type">int</span> n,m,q;<span class="hljs-comment">//n行m列矩阵的 q次询问 </span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]); <br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>b[i][j]=b[i<span class="hljs-number">-1</span>][j]+b[i][j<span class="hljs-number">-1</span>]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i][j]; <span class="hljs-comment">//构造二维前缀和矩阵 </span><br> <br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-type">int</span> x1,y1,x2,y2;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,b[x2][y2]-b[x1<span class="hljs-number">-1</span>][y2]-b[x2][y1<span class="hljs-number">-1</span>]+b[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>给定数组a 构造数组b 使得a数组为b数组的前缀和数组 即求前缀和数组的逆运算：由前缀和数组 求出 对应的 原数组。b数组称为a数组的差分数组 <br>作用：假定要对a数组中的某段元素（n个）进行统一操作，若直接在a数组中操作需要O(n)的时间复杂度，如果有a的差分数组，则只需要进行两次操作即可，即时间复杂度为O(1). 比如现在要对某数组A中[L,R]区间的元素统一加上c，若是遍历并加上c，则需要O(n)的时间复杂度，若是由这个数组的差分数组B进行操作，则只需要在B数组中的B[L]+c，此时B数组对应的前缀和数组的L后的每一项，都将加上c，但是此时只要求[L,R]区间的数加c，后续的数都没有加c，只需要再令B[R<br>+1]-c即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a[N],b[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDiff</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> e)</span></span>&#123;<br>b[l]+=e;<br>b[r+<span class="hljs-number">1</span>]-=e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-comment">//原数组初始化 </span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">getDiff</span>(i,i,a[i]);<span class="hljs-comment">//构造差分数组 </span><br><br><span class="hljs-comment">//由构造出的差分数组进行操作 </span><br><span class="hljs-keyword">while</span>(m--)&#123;<br><span class="hljs-type">int</span> l,r,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);<br><span class="hljs-built_in">getDiff</span>(l,r,c);<br>&#125; <br><br><span class="hljs-comment">//由处理后的差分数组 求出其前缀和数组 并输出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>构造：b<sub>i</sub>&#x3D;a<sub>i</sub>-a<sub>i-1</sub> 构造差分数组并非重点，主要在于如何 更新 差分数组并再由更新后的差分数组 得出其原数组（前缀和数组）的新结果。</p><p>二维差分：为二维数组中的某个矩阵区域进行操作，若由该二维数组直接操作，则需要O(n*m)的时间复杂度,用对应的差分矩阵则只需要4次操作即O(1)的时间复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n,m,q; <span class="hljs-comment">//n行 m列 q个操作 </span><br><span class="hljs-type">int</span> a[N][N],b[N][N];<br><br><span class="hljs-comment">//***</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDiff</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span>&#123;<br>b[x1][y1]+=c;<br>b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>]+=c;<br>b[x1][y2+<span class="hljs-number">1</span>]-=c;<br>b[x2+<span class="hljs-number">1</span>][y1]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);<br><span class="hljs-comment">//初始化二维矩阵 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i][j]);<br><br><span class="hljs-comment">//构造二维矩阵对应的差分矩阵 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-built_in">getDiff</span>(i,j,i,j,a[i][j]);<br><br><span class="hljs-comment">//对差分矩阵进行操作</span><br><span class="hljs-keyword">while</span>(q--)&#123;<br><span class="hljs-type">int</span> x1,y1,x2,y2,c;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);<br><span class="hljs-built_in">getDiff</span>(x1,y1,x2,y2,c);<br>&#125;<br><br><span class="hljs-comment">//由操作后的差分矩阵 反推 操作后的 原矩阵</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>b[i][j]+=b[i][j<span class="hljs-number">-1</span>]+b[i<span class="hljs-number">-1</span>][j]-b[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<span class="hljs-comment">//***</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i][j]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span>  <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>acwing算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>高精度</tag>
      
      <tag>前缀和</tag>
      
      <tag>差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CaringDoc项目总结</title>
    <link href="/zyq.github.io/2025/03/04/%E9%A1%B9%E7%9B%AE/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/CaringDoc/"/>
    <url>/zyq.github.io/2025/03/04/%E9%A1%B9%E7%9B%AE/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/CaringDoc/</url>
    
    <content type="html"><![CDATA[<h1 id="CaringDoc-项目总结"><a href="#CaringDoc-项目总结" class="headerlink" title="CaringDoc 项目总结"></a>CaringDoc 项目总结</h1><h2 id="开发日志"><a href="#开发日志" class="headerlink" title="开发日志"></a>开发日志</h2><h3 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h3><blockquote><p>2023-12-15 周五</p></blockquote><p>​    <strong>develop</strong><br>​    1. 仓库建立<br>​    2. 项目初始化：依赖安装，config文件编辑自动导入<br>​    3. 注册icon，全局样式编写<br>​    4. 登录,注册,404路由设计<br>​    5. axios封装,基本接口编写：login register captcha<br>​    6. 登录,注册,404 页面初步编写,定义content页面<br>​    7. 登录注册,表单校验1.0,可读性差,将登录的实现和校验耦合,待优化</p><p>​    <strong>bug &amp; debug</strong><br>​    无严重bug 但代码质量很低</p><h3 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h3><blockquote><p>2023-12-16 周六</p></blockquote><p>​    <strong>develop</strong><br>​    1. 引入pinia状态管理和数据持久化管理 管理token 在user.js文件中定义store<br>​    2. 优化原路由固定导入组件为动态导入,提高页面渲染效率<br>​    3. 定义子路由<br>​    4. 定义主页layout 和 主页框架</p><p>​    <strong>bug &amp; debug</strong></p><ol><li>layout–popup宽度更改 不能在scoped样式域中更改 在纯style中更改并加上!important 同时还学到了深度样式的优化写法：xxx :deep(xxx{})</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>//在无scoped的style中写important样式<br><span class="hljs-selector-class">.el-menu--popup</span>&#123;<br>    <span class="hljs-attribute">min-width</span>:<span class="hljs-number">100px</span><span class="hljs-meta">!important</span>;<br>&#125;<br>//deep的写法<br><span class="hljs-selector-class">.more</span> :<span class="hljs-built_in">deep</span>(.el-menu--popup)&#123;<br>    <span class="hljs-attribute">min-width</span>=<span class="hljs-number">100px</span>;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>layout–MainContent中的scoped写错成scope：后续因为这个出现样式污染</li></ol><h3 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h3><blockquote><p>2023-12-17 周日</p></blockquote><p><strong>develop</strong></p><ol><li>优化表单校验：实现自定义表单校验：repsw</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">rePsw</span>:[<br>    &#123;<span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入密码&#x27;</span>, <span class="hljs-attr">trigger</span>:<span class="hljs-string">&#x27;blur&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">min</span>:<span class="hljs-number">3</span>, <span class="hljs-attr">max</span>:<span class="hljs-number">15</span>, <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;密码长度应为3-15个字符&#x27;</span>, <span class="hljs-attr">trigger</span>:<span class="hljs-string">&#x27;blur&#x27;</span>&#125;,<br>    &#123;<br>        <span class="hljs-comment">//自定义校验：validator定义 rule value callback</span><br>        <span class="hljs-attr">validator</span>:<span class="hljs-function">(<span class="hljs-params">rule,value,callback</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(value!=ruleForm.<span class="hljs-property">psw</span>)&#123;<br>                <span class="hljs-title function_">callback</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;两次输入的密码不一致！&#x27;</span>))<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-title function_">callback</span>();<br>            &#125;<br>        &#125;,<br>        <span class="hljs-attr">trigger</span>:<span class="hljs-string">&#x27;blur&#x27;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><ol start="2"><li>优化vscode误报错提示:<br><strong>建议下次在项目构建前加入此配置信息</strong></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// jsconfig.json</span><br><span class="hljs-attr">&quot;lib&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;dom&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;es5&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;es2015.promise&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;es2015&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;es2017&quot;</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>接口规范化useXXXservice，并在登录验证接口调用debug 发现[Object object]这种奇怪格式 需要用JSON.stringfy解决</p></li><li><p>解耦表单校验和登录注册调用接口的实现</p></li><li><p>背景图片设置 但是发现图片位置不理想 </p></li><li><p>pinia独立维护 仓库统一导出 增加项目可维护性（需要再main.js中导入并use pinia）:</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br><span class="hljs-comment">//pinia独立维护</span><br><span class="hljs-keyword">import</span> &#123;createPinia&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> persist <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia-plugin-persistedstate&#x27;</span><br><br><span class="hljs-keyword">const</span> pinia=<span class="hljs-title function_">createPinia</span>();<br>pinia.<span class="hljs-title function_">use</span>(persist);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> pinia;<br><br><span class="hljs-comment">//仓库统一导出 以便在项目的编写过程中 直接使用index.js获取api 而不必精确到具体模块</span><br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/user.js&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/modules/user.js</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userUseStore =<span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> token=<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setToken</span>=(<span class="hljs-params">newToken</span>)=&gt;&#123;<br>        token.<span class="hljs-property">value</span>=newToken;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">removeToken</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>        token.<span class="hljs-property">value</span>=<span class="hljs-string">&#x27;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>&#123;<br>        token,setToken,removeToken<span class="hljs-comment">//对于是否携带 token 用 !!token判断</span><br>    &#125;<br>&#125;,<br>&#123;<br>    <span class="hljs-attr">persist</span>:<span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="7"><li>debug出scoped错误写成scope</li><li>完成宠物信息页面的框架搭建 但是编辑和新增信息表单弹出框没有组件化处理，不易维护，质量差</li><li>发现背景图片加上background-position:center center 背景图片的位置会好很多</li></ol><p><strong>bug &amp; debug</strong></p><p>无严重bug</p><h3 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h3><blockquote><p>2023-12-18 周一</p></blockquote><p><strong>develop</strong></p><ol><li><p>正式完成登录注册页面的接口实现</p></li><li><p>完成登录卡片的动画效果 用到setTimeOut和vue的样式绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//动画效果 利用vue的样式绑定</span><br><span class="hljs-keyword">const</span> cardHeight=<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;0px&#x27;</span>);<br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;cardHeight.<span class="hljs-property">value</span>=<span class="hljs-string">&#x27;45%&#x27;</span>&#125;,<span class="hljs-number">200</span>)<span class="hljs-comment">//0.2s后展开登录卡片</span><br>&#125;)<br><br><span class="hljs-comment">//绑定处</span><br>:style=<span class="hljs-string">&#x27;&#123;height:cardHeight&#125;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>优化了home布局，利用动态样式计算 质量更高 需要注意运算中的括号不能省略，正是用了动态样式，因此样式更加严谨正确，从而消除了滚动条冲突，因为一般来说，样式布置好了是不会出现滚动条冲突的，el-main很智能</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">height</span>:<span class="hljs-built_in">calc</span>(<span class="hljs-number">100vh</span> - <span class="hljs-number">60px</span>); //注意减号左右的空格 必须留出！！<br></code></pre></td></tr></table></figure><ol start="4"><li><p>完成了各个主页的开发，实现了新增和编辑表单弹框的组件化，更重要的是<strong>组件化思想</strong>，以后要多多学习这样的应用，为了暴露组件的方法 要用：defineExpose({methods…}),然后在父组件中对该子组件绑定ref:refName，然后在合适的时机用refName.value.method来调用子组件的方法。</p><p>注意要在编辑组件的回显赋值前赋一次空对象，否则会出现点击一次编辑后，由于是编辑，因此会有数据回显写入，然后再点击新增时，数据仍然在表单里，因此需要先赋一次空对象</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子组件中</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">open</span>=(<span class="hljs-params">row</span>)=&gt;&#123;<br>    newAnimal.<span class="hljs-property">value</span>=&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;&#x27;</span>,.....&#125;<span class="hljs-comment">//赋空值</span><br>    dialogVisible.<span class="hljs-property">value</span>=<span class="hljs-literal">true</span>;<br>    newAnimal.<span class="hljs-property">value</span>.<span class="hljs-property">name</span>=row.<span class="hljs-property">name</span>;...<br>&#125;<br><span class="hljs-title function_">defineExpose</span>(&#123;open&#125;)<br><span class="hljs-comment">//父组件</span><br><span class="hljs-keyword">const</span> dialog=<span class="hljs-title function_">ref</span>()<span class="hljs-comment">//需要定义子组件的ref</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addNeeds</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    dialog.<span class="hljs-property">value</span>.<span class="hljs-title function_">open</span>();<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">editNeeds</span>=(<span class="hljs-params">row</span>)=&gt;&#123;<br>    dialog.<span class="hljs-property">value</span>.<span class="hljs-title function_">open</span>(row)<br>&#125;<br>&lt;<span class="hljs-title class_">MaterialNeedsEdit</span> ref=<span class="hljs-string">&#x27;dialog&#x27;</span>&gt; &lt;/<span class="hljs-title class_">MaterialNeedsEdit</span>&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>完成了loading优化和empty优化</li></ol><p>​实际上是el-table的一个api和另外一个插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">//为表格的loading效果绑定loading 在调用获取数据的接口时设置loading为true 获取完毕后 改为false即可<br>&lt;el-table :loading=&quot;loading&quot; stripe :date=&#x27;NeedsList&#x27;&gt;&lt;/el-table&gt;<br>&lt;template #empty&gt; &lt;el-empty description=&#x27;无数据&#x27;&gt;&lt;/el-empty&gt; &lt;/template&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li>完成了各个页面的get数据接口规范化开发和引入</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; getMaterialNeedsService &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/apis&#x27;</span> <br><span class="hljs-comment">//引入后再封装</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getMaterialNeedsList</span> = <span class="hljs-keyword">async</span>(<span class="hljs-params"></span>)=&gt;&#123;<br>    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getMaterialNeedsService</span>();<br>    <span class="hljs-title class_">NeedList</span>.<span class="hljs-property">value</span>=res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>;<br>    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-title function_">getMaterialNeedsList</span>();<br></code></pre></td></tr></table></figure><p><strong>bug &amp; debug</strong></p><p>无严重bug  更多的是代码优化  发现heima上的课写得很好  可以跟着刷一遍！！</p><h3 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h3><blockquote><p>2023-12-19</p></blockquote><p>今天基本完成了项目的开发。 commit:11次</p><p><strong>develop</strong></p><ol><li>注销时的确认弹窗 &#x3D;&gt; 对于重要操作 需要以这种形式来确认用户操作 包括后面的删除功能也是如此;</li><li>新增和编辑表单时的表单校验 &#x3D;&gt; 正则表达式的初步学习，需要深入学习<strong>正则表达式</strong></li><li>分页请求接口和分页器设计 </li><li>分页和筛选的耦合 &#x3D;&gt; 开发时发现 若想要实现筛选和分页 最好将数据绑定在一起作为data传到后端 </li><li>完成所有接口的设计 &#x3D;&gt; 观察页面整体布局和组件和需求文档 分析并准备出所有所需的接口</li><li>完成新增&#x2F;编辑表单的父子通信和接口调用 &#x3D;&gt;发现在编辑或新增数据后 需要让table刷新 但是编辑和新增是子组件 因此涉及到defineEmits ref绑定</li><li>完成删除接口的设计和引入 &#x3D;&gt;通过插槽向后端传入id 删除即可</li><li>完成使用物资的接口设计 &#x3D;&gt; 通过分析需求和讨论 确定出前端向后端传入id和使用的数量，然后再进行数据更新，而不是前段改变后直接put到后端，但是前端仍然可以通过校验值来进行一些修饰</li><li>完成‘’寻找‘和’‘领养审核’‘功能的开发 &#x3D;&gt; 7.8.都是分析 设计接口 通过需求确定思路</li><li>axios拦截器的配置 &#x3D;&gt;响应拦截和请求拦截 分别用来拦截前端的非法(不够格)请求和后端的错误响应</li><li>完成token和路由守卫 &#x3D;&gt; 询问GPT得到结果</li></ol><p><strong>bug &amp; debug</strong></p><p>无严重bug</p><p>开发要点：</p><ol><li>确认弹窗如何写</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">ElMessageBox</span>.<span class="hljs-title function_">confirm</span>(<br><span class="hljs-string">&#x27;提示内容&#x27;</span>,<br>    <span class="hljs-string">&#x27;提示标题&#x27;</span>,<br>    &#123;<br>        <span class="hljs-attr">confirmButtonText</span>:<span class="hljs-string">&#x27;确认按钮文字&#x27;</span>,<br>        <span class="hljs-attr">cancelButtonText</span>:<span class="hljs-string">&#x27;取消按钮文字&#x27;</span>,<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;waring&#x27;</span>,<span class="hljs-comment">//弹窗类型 waring danger</span><br>    &#125;<br>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">//点击确认按钮后的处理</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">//点击取消按钮以及出错的处理</span><br>&#125;)<br><br><span class="hljs-variable constant_">EMB</span>.<span class="hljs-title function_">confirm</span>(<br><span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#123;<br>        <span class="hljs-attr">confirmButtonText</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">cancelButtonText</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;<br>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <br>&#125;)<br><br></code></pre></td></tr></table></figure><p>四部分：提示内容和提示标题 | 按钮文字和弹窗类型 | 确认操作 |取消<strong>和出错</strong>操作</p><ol start="2"><li>表单校验实现时主要涉及到两点：1. 表单校验的实现思路 2. 正则式的编写</li></ol><p>​实现思路：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> formModel=<span class="hljs-title function_">ref</span>(&#123;<span class="hljs-attr">pro1</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-attr">pro2</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;)<br><span class="hljs-comment">//1.定义rules 要求以下格式 要求属性与formModel(要绑定的表单)一致</span><br><span class="hljs-keyword">const</span> rules=&#123;<br>    <span class="hljs-attr">pro1</span>:[<br>        &#123;<span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;请输入xxxx&#x27;</span>,<span class="hljs-attr">trigger</span>:<span class="hljs-string">&#x27;blur&#x27;</span>&#125;<br>        &#123;<span class="hljs-attr">pattern</span>:<span class="hljs-regexp">/^S&#123;1,10&#125;$/</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;pro1必须是1到10位非空字符&#x27;</span>&#125;<br>    ],<br>    <span class="hljs-attr">pro2</span>:[<br>        &#123;<span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>|<span class="hljs-literal">false</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;请输入xxxx&#x27;</span>,<span class="hljs-attr">trigger</span>:<span class="hljs-string">&#x27;blur|focus|active...&#x27;</span>&#125;<br>        &#123;<span class="hljs-attr">pattern</span>:<span class="hljs-regexp">/^.../</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;pro2必须是...&#x27;</span>&#125;<br>    ]...<br>&#125;<br><span class="hljs-comment">//2.为el-form 绑定:rules=&#x27;rules&#x27; 以及 :model=&#x27;formModel&#x27;(这个即使不校验 也要绑定...)同时为每个对应的表单item绑定prop=&#x27;pro&#x27; 对应的属性</span><br>&lt;el-form :rules=<span class="hljs-string">&#x27;rules&#x27;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&#x27;pro1&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&#x27;pro2&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span></span><br>&lt;/el-form&gt;<br></code></pre></td></tr></table></figure><p>另一点比较重要的是 表单校验的同步：只有在校验有效后才提交表单，这需要通过ref实现，<strong>首先为表单绑定ref，然后定义ref，然后同步调用ref对象的validate方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> formRef=<span class="hljs-title function_">ref</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">confirm</span>=<span class="hljs-keyword">async</span>(<span class="hljs-params"></span>)=&gt;&#123;<br>  <span class="hljs-keyword">await</span> formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">validate</span>();<br>  <span class="hljs-comment">//xxx其他操作 如提交等</span><br>&#125;<br><br>&lt;el-form ref=<span class="hljs-string">&quot;formRef&quot;</span> :model=<span class="hljs-string">&quot;newStray&quot;</span>&gt;...<br></code></pre></td></tr></table></figure><ol start="3"><li>分页请求接口和分页器的设计</li></ol><p>​分页器常常渲染不出来，而且还不会报错。因此用不好会很头疼，但是要点在于数据的合法性，有些数据一定要绑定，有些数据绑定时还应遵守规则，比如page-size和page-sizes[x,x,x]page-size一定要在page-size的集合中，而total等数据等一定要绑定有值的数据，不能是空值或undefined，因此在模拟时也尽量模拟有效值，另外，最不易出错的方法是：<strong>绑定所有接口，并为每个接口都绑定<u>有效</u>属性</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;el-pagination<br>v-<span class="hljs-attr">model</span>:current-page=<span class="hljs-string">&#x27;param.currentPage&#x27;</span><br>v-<span class="hljs-attr">model</span>:page-size=<span class="hljs-string">&#x27;param.pageSize&#x27;</span><br>:page-sizes=<span class="hljs-string">&#x27;[5,10]&#x27;</span><span class="hljs-comment">//page-size和page-sizes一定要注意</span><br>:background=<span class="hljs-literal">true</span><br>layout=<span class="hljs-string">&quot;total, sizes, prev, pager, next, jumper&quot;</span><br>:total=<span class="hljs-string">&#x27;total&#x27;</span><span class="hljs-comment">//测试时最好绑定正常一点的值</span><br>@size-change=<span class="hljs-string">&quot;handleSizeChange&quot;</span><span class="hljs-comment">//这方法最好定义出来 一般是页面数据改变时，改变param数据并回显(再调用get请求 渲染新数据)</span><br>    @current-change=<span class="hljs-string">&quot;handleCurrentChange&quot;</span><br>style=<span class="hljs-string">&quot;justify-content: center;margin-top: 9px;padding-bottom: 10px;&quot;</span><span class="hljs-comment">//这样式最好加上 居中并控制上下空隙</span><br>/&gt;<br></code></pre></td></tr></table></figure><p>分页请求接口的设计中，最关键的是实现分页的数据结构param对象，分析：前端需要向后端传递页面大小和当前页面，后端根据这些来返回对应的数据，然后前端再渲染这些数据，会感觉到前端并没有保存着所有页的数据，分页只是表象，本质其实是请求不同的数据并展示，可以注意到，我们所看到的数据本地都是没有的，那么对于筛选也是这样，后端向前端返回数据，前端再展示，因此呢，完全可以将他们封装在一起，作为请求渲染时的数据结构！注意啊：关键是数据，本质是特定数据，前端,或者说用户本地并没有真的有这么多页的数据！！！因此不难得出以下的设计结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> param=<span class="hljs-title function_">ref</span>(&#123;<br><span class="hljs-attr">pageSize</span>:<span class="hljs-number">10</span>,<br>    <span class="hljs-attr">currentPage</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-comment">// ↑分页 ↓具体数据或者说关键数据 需要展示的内容 或者 筛选需要的内容 但是最好全部拿过来 又不会很影响性能 而且有利于以防万一</span><br>    <span class="hljs-attr">pro1</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">pro2</span>:<span class="hljs-string">&#x27;&#x27;</span>,...<br>&#125;)<br><br><span class="hljs-keyword">const</span> total=<span class="hljs-title function_">ref</span>(<span class="hljs-number">200</span>);<span class="hljs-comment">//在测试时 不要用0 否则有时渲染不出来分页器</span><br><span class="hljs-comment">//以下为接口 注意：get和delete请求 需要在config中加对象，而post put可以直接在路径后跟data对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getInforService</span>=(<span class="hljs-params">params</span>)=&gt;request.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/manage/petsInfor/get&#x27;</span>,&#123;params&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li>接口的设计</li></ol><p>​token的处理一并说了，token需要加在请求的header中，这样每次请求就能携带token了，添加在config中就可以了，然后就是post put和delete get的参数的处理区别，后者需要写在config中 而前者直接跟在路径后：</p><p>​还需特别注意的是命名规范：xx(action)XX(object)Service 而在调用时进一步封装为 xx(action)Service，同时，store也有对应的命名和封装规范.后面再讲。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/utils/http/request.js&quot;</span><br><span class="hljs-keyword">import</span> &#123; useUserStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/stores&quot;</span><br><span class="hljs-keyword">const</span> userStore=<span class="hljs-title function_">useUserStore</span>();<br><span class="hljs-comment">//get all -&gt;select</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPetsInforService</span>=(<span class="hljs-params">params</span>)=&gt;request.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/manage/petsInfor/get&#x27;</span>,&#123;params,<span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer &#x27;</span> + userStore.<span class="hljs-property">token</span> &#125;&#125;)<br><span class="hljs-comment">//add -&gt; insert</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">addPetsInforService</span>=(<span class="hljs-params">data</span>)=&gt;request.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/manage/petsInfor/add&#x27;</span>,data,&#123;<span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer &#x27;</span> + userStore.<span class="hljs-property">token</span> &#125;&#125;)<br><span class="hljs-comment">//delete by id -&gt;delete</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">deletePetsInforService</span>=(<span class="hljs-params">id</span>)=&gt;request.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;/manage/petsInfor/delete&#x27;</span>,&#123;<span class="hljs-attr">params</span>:id,<span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer &#x27;</span> + userStore.<span class="hljs-property">token</span> &#125;&#125;)<br><span class="hljs-comment">//edit by id -&gt;update</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">editPetsInforService</span>=(<span class="hljs-params">data</span>)=&gt;request.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/manage/petsInfor/edit&#x27;</span>,data,&#123;<span class="hljs-attr">headers</span>: &#123; <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer &#x27;</span> + userStore.<span class="hljs-property">token</span> &#125;&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>接口的调用，即业务功能的实现，实际上，业务功能不是单一的，并非编辑就仅仅调用编辑接口，用户是十分需要反馈的，进行操作后，视图最好马上就重新渲染，因此<strong>基本上。凡是影响到数据，而数据影响到当前视图的，应当马上再调用get接口渲染新数据！</strong>除此之外，还应该注意到，业务功能的实现，最重要的是思路，而好的思路是分析问题，将问题抽象为已有的简单接口，用简单的事情完成困难的事情！！</p></li><li><p><a name='diff1'>组件化和父子通信</a>：其实这里涉及到另一个我想说的，就是优化，在本项目中，我是将新增&#x2F;编辑信息组件化成了一个弹框类型的组件，但是也可以组件化<strong>抽屉</strong>组件，这个组件在某些场景下能带来更好的用户体验，首先，最重要的就是组件化的思想，不仅能增加复用性，甚至有些操作的实现在组件化下会非常简单，比如这里的：如果是新增则为空表格，如果是编辑则回显，这里就是组件化，然后在子组件中判断是否存在id，是则回显数据，否则让数据为空，不过这里涉及到一个细节：<strong>无论如何 先赋空</strong>，否则会导致点击编辑后，以后再点新增时，表单里面会有残余数据。其实就是通信：组件的父子通信可以分为definedEmits和definedProps和definedExposed三种，这里用到的是emits，即子组件在提交后，通知父组件重新渲染一次页面（符合5中的原则），这种事件的通知就是依靠emits实现的。这三个的具体结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span><span class="hljs-attr">defineEmits</span>:<br>用处：向父组件抛出子组件的事件，以便该事件发生后，父组件能够察觉并采取相应的行动,如本项目中，<span class="hljs-title class_">Edit</span>组件数据更改确认后，父组件需要马上get一次数据刷新页面，就是通过emits完成的<br>用法： <span class="hljs-number">1.</span> 在子组件中定义：<br><span class="hljs-keyword">const</span> emits = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;eventA&#x27;</span>,<span class="hljs-string">&#x27;eventB&#x27;</span>])<br>      <span class="hljs-number">2.</span> 在子组件中触发：<br>      ...<span class="hljs-title function_">emits</span>(<span class="hljs-string">&#x27;eventA&#x27;</span>)...<span class="hljs-comment">//也可以携带参数↓</span><br>        ...<span class="hljs-title function_">emits</span>(<span class="hljs-string">&#x27;eventB&#x27;</span>,xx.<span class="hljs-property">value</span>)<br>  <span class="hljs-number">3.</span> 父组件中定义和绑定<br>      <span class="hljs-comment">//定义</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleEventA</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-title function_">handelEventB</span>=(<span class="hljs-params">val</span>)=&gt;&#123;<br>            ...<br>        &#125;<br>        <span class="hljs-comment">//绑定   </span><br>        &lt;<span class="hljs-title class_">ChildComponent</span> @eventA=<span class="hljs-string">&#x27;handelEventA&#x27;</span> @eventB=<span class="hljs-string">&#x27;handelEventB&#x27;</span>&gt;&lt;/<span class="hljs-title class_">ChildComponents</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">2.</span><span class="hljs-attr">defineProps</span>:<br>用处：向父组件暴露子组件的属性，父组件可以为子组件的属性赋值<br>用法： <span class="hljs-number">1.</span> 在子组件中定义<br><span class="hljs-title function_">defineProps</span>(&#123;<br>            <span class="hljs-attr">propA</span>:&#123;<br>                <span class="hljs-attr">type</span>:[<span class="hljs-title class_">Number</span>,<span class="hljs-title class_">String</span>],<br>            <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span> <br>            &#125;<br>            <span class="hljs-attr">propB</span>:&#123;<br>            <span class="hljs-attr">type</span>:<span class="hljs-title class_">Boolean</span>,<br>            <span class="hljs-keyword">default</span>=<span class="hljs-literal">false</span>;<br>        &#125;<br>        &#125;)<br>  <span class="hljs-number">2.</span> 在父组件中传值<br>      &lt;<span class="hljs-title class_">ChildComponents</span> :propA=<span class="hljs-string">&quot;dataA&quot;</span> :propB=<span class="hljs-string">&quot;dataB&quot;</span>&gt;&lt;/<span class="hljs-title class_">ChildComponents</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">3.</span><span class="hljs-attr">defineExpose</span>:<br>用处：子组件向父组件暴露方法，父组件可以调用子组件暴露出来的这个方法 如此项目的open方法<br>用法: <span class="hljs-number">1.</span> 子组件中暴露<br><span class="hljs-title function_">defineExpose</span>(&#123;method&#125;)<span class="hljs-comment">//method是已经定义好了的方法</span><br>  <span class="hljs-number">2.</span> 父组件定义，绑定和调用<br>      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span>=<span class="hljs-title function_">ref</span>();<span class="hljs-comment">//定义</span><br>...<span class="hljs-title class_">Child</span>.<span class="hljs-property">value</span>.<span class="hljs-property">method</span>...<span class="hljs-comment">//在某个合适的时机调用子组件的method方法</span><br>      &lt;<span class="hljs-title class_">ChildComponents</span> ref=<span class="hljs-string">&#x27;Child&#x27;</span>&gt;&lt;<span class="hljs-regexp">/ChildComponents&gt; /</span>/绑定<br></code></pre></td></tr></table></figure></li><li><p>拦截器</p><p>拦截器包括响应拦截器和请求拦截器，各自的功能是：</p><ol><li>响应拦截器：在请求发送前进行必要操作处理，例如添加统一cookie、请求体加验证、设置请求头等，相当于是对每个接口里相同操作的一个封装；</li><li>请求拦截器：在请求得到响应之后，对响应体的一些处理，通常是数据统一处理等，也常来判断登录失效等。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么，例如设置token</span><br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer your-token&#x27;</span>;<br>    <span class="hljs-keyword">return</span> config;<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;);<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 对响应数据做点什么 打印错误信息msg或者错误码code等等</span><br>    <span class="hljs-keyword">return</span> response;<br>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>        <span class="hljs-comment">// 处理未授权的情况 一般为跳转到login界面</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><a name='diff2'>路由守卫</a></p></li></ol><p>​token，vue router，pinia，axios拦截器共同完成权限的处理，只有登录了的用户（token有效）才能访问主页和请求数据，否则将被拦截且重定向到登录页面。对于token，要用pinia进行持久化状态管理，对于路由守卫，要结合token去判断，并且赦免登录页和注册页的守卫（或者说 只对于被标记了<strong>需要保护</strong>的路径进行审查）。</p><p>​1. 设置pinia store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useAuthStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;auth&#x27;</span>, &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">token</span>: <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>) || <span class="hljs-string">&#x27;&#x27;</span>,<br>  &#125;),<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">setToken</span>(<span class="hljs-params">newToken</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span> = newToken;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, newToken);<br>    &#125;,<br>    <span class="hljs-title function_">clearToken</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">token</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>      <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li>配置router</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//保护需要认证的路由，并在token无效时重定向到登录页面。</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useAuthStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../store/auth&#x27;</span>;<br><br><span class="hljs-keyword">const</span> routes = [<br>  <span class="hljs-comment">// ...你的其他路由</span><br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/protectedPath&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;path/to/protected/component.vue&#x27;</span>),<br>    <span class="hljs-attr">meta</span>: &#123; <span class="hljs-attr">requiresAuth</span>: <span class="hljs-literal">true</span> &#125;<span class="hljs-comment">//这就是上文提到的被标记为《需要保护》的路径</span><br>  &#125;,<br>  <span class="hljs-comment">// ...其他路由</span><br>];<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  routes,<br>&#125;);<br><br><span class="hljs-comment">//核心代码</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> authStore = <span class="hljs-title function_">useAuthStore</span>();<br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span> &amp;&amp; !authStore.<span class="hljs-property">token</span>) &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">next</span>();<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><ol start="3"><li>axios拦截器配置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useAuthStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/auth&#x27;</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>; <br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">const</span> intance = axios.<span class="hljs-title function_">create</span>();<br><span class="hljs-comment">// 请求拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> authStore = <span class="hljs-title function_">useAuthStore</span>();<br>  <span class="hljs-keyword">if</span> (authStore.<span class="hljs-property">token</span>) &#123;<br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;authStore.token&#125;</span>`</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> config;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;);<br><br><span class="hljs-comment">// 响应拦截器</span><br>instance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> response;<br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> authStore = <span class="hljs-title function_">useAuthStore</span>();<br>  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123; <span class="hljs-comment">// token过期或未授权</span><br>    authStore.<span class="hljs-title function_">clearToken</span>();<br>    router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>注意 别忘了在main.js中为app应用所有的依赖实例。</strong></p><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><h3 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h3><blockquote><p>一站式解决流浪动物的管理，领养，寻回，因此包括动物信息的管理，走失信息的管理，领养申请的管理，物资捐赠和需求的管理的几大管理功能。目前仅涉及管理员端，包括登录，注册页面，主页：各信息的增删查改。</p></blockquote><p><strong>404页面</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_404.png" alt="404"></p><p><strong>登录页面</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_login.png" alt="登录"></p><p><strong>注册页面</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_register.png" alt="注册"></p><p><strong>主页-动物信息管理</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_home_petsInfo.png" alt="动物信息"></p><p><strong>主页-动物信息添加&#x2F;编辑</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_addPetsInfo.png" alt="动物信息添加/编辑"></p><p><strong>主页-领养信息管理</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_home_adoption.png" alt="领养信息"></p><p><strong>主页-失主信息管理</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_home_stray.png" alt="失主信息"></p><p><strong>主页-物资捐献管理</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_home_materialDonation.png" alt="物资捐献"></p><p><strong>主页-物资需求管理</strong></p><p><img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_home_materialNeeds.png" alt="物资需求"></p><p><strong>主页-个人操作入口</strong></p><p>即包括注销，个人信息编辑（未开发）等<br>将鼠标悬浮在右上角头像上将弹出冒泡框，显示个人中心，注销，更多等功能。点击注销后弹出如下警告窗口。<img src="https://springbear-markdown-photo.oss-cn-wuhan-lr.aliyuncs.com/pro_CaringDoc_logout.png" alt="注销"></p><h3 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h3><ol start="0"><li><p>与团队成员沟通，确定好原型图，统一并记录变量命名和api路径</p></li><li><p>初始化vue 项目 引入依赖和必要的配置信息：自动导入和ES版本引入等等</p></li><li><p>gitee仓库创建 并对项目进行版本控制</p></li><li><p>路由设计和各页面框架设计</p></li><li><p>各页面静态开发，不着重考虑样式</p></li><li><p>权限管理 token pinia axios vueRouter</p></li><li><p>api设计和引入，即完成动态开发</p></li><li><p>样式开发</p></li><li><p>测试</p></li></ol><h3 id="难点和解法"><a href="#难点和解法" class="headerlink" title="难点和解法"></a>难点和解法</h3><p>难点：</p><ol><li><a href='#diff1'>组件通信 3个define </a></li><li><a href='#diff2'>权限管理</a></li></ol><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>本次项目是开发的第一个较完整的前端项目，之前的都没实现动态，而且团队组织也一般，尽管这次也有很多不完美的地方，但总体来说，学到了很多很多。</p><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><h4 id="个人规划不足"><a href="#个人规划不足" class="headerlink" title="个人规划不足"></a>个人规划不足</h4><blockquote><p>规划角度 目前只能回忆到两点不足了。 自我反思的能力很大程度上取决于对内心的探索能力，内心戏多，高敏感也挺好，可以看到更多向内的东西。我应该接纳自己 爱上自己~</p></blockquote><ol><li>没有第一时间记录项目开发。放在第一点反思，因为真的很重要。如果不能及时记录下当时遇到的困惑和解决方法，很容易下次遇到相同的问题只能无奈地又去搜索。因为几乎没有再有高效的复习方法了，以后再看这个项目时，对于一些细节和坑可能无法像当时一样记得清楚了。</li><li>开发思路还可以更清晰。这一点应该是值得赞许的，作为首个项目，本人的开发过程和思路已经有一定的规划和整理，比如先导入好所有依赖和对依赖进行配置和自动导入，再准备好整体路由设计框架。但是还可以更加清晰，从而加快开发速度，比如：再第一个阶段不该太苛求于样式，样式美化是好事，但是不能耽误自己的进度，以及原型图等的设计，尽管这一部分可能不由开发者处理，但是当团队无人负责此工作时，自己学着做好会更好；另一点就是数据命名和接口路径，无论是协作还是个人独立开发，现在接触的动态网页项目，那么对于数据的命名和接口的路径，最好在开发前商定好，并记录下来！口说无凭，容易忘记，开个会不能仅仅只靠脑子，一定要记在文档中；这个项目后期因为命名浪费了好多好多时间。</li></ol><h4 id="团队规划不足"><a href="#团队规划不足" class="headerlink" title="团队规划不足"></a>团队规划不足</h4><blockquote><p>其实感觉团队其他成员做得已经很好了 但是还可以更好！而且这些不足或许很大程度上是有项目开发的时间决定的？当时是期末，总感觉大家都没有静下心来？因为期末的事情比较多，所以大家没有沉下心来做这件事？</p></blockquote><ol><li>分工问题。没有负责进行接口文档撰写和原型图设计等产品经理所扮演的角色的成员。我们是一个四人组，一人前端，一人后端，另外两位负责报告撰写，数据库设计，uml建模，需求分析，数据字典编写等等，我没有切身尝试过全部的这些事情，所以我不知道到底是分工的确可以再优化（没有优化），还是团队人数所限才导致没人负责api文档和原型设计等(优化不了)；</li><li>整体开发规划。由于项目队长缺少项目开发经验，因此对于项目的开发过程并没有干预或领导太多，也就没有太多的过程监督和高质量的结果评价，没有进行敏捷开发，没有分配具体任务，没有绘制燃尽图等；</li></ol><h4 id="开发能力不足"><a href="#开发能力不足" class="headerlink" title="开发能力不足"></a>开发能力不足</h4><blockquote><p>在开发方面，因为经验欠缺，开发的能力也显得十分不足，解决之道是多参与项目的开发，熟能生巧。</p></blockquote><ol><li>接口设计：接口是动态网页的关键，然而在这一方面我却最为薄弱。应该自己做一个全栈项目，这样才能真正弄懂接口设计。具体而言，在本项目中，没有用到fetch请求，在开发过程中没有彻底弄懂前端的请求拦截和响应拦截，只是粗略带过，但是在回顾该内容时进行了梳理。</li><li>token：仍属于动态网页的关键部分，有的token要求Authencation为key，在开发的过程中也忽略过了，但是好在回顾的时候，进行了梳理。（看来项目的回顾和总结真的是非常重要，受迫于项目开发进度要求，可能无法在项目开发的过程中弄懂每个知识点，因此必要的带过有助于高效学习，但是重要的是，一定不能忘记自己粗略带过去的那些知识点，否则就得不偿失了）</li><li>开发流程：经过此次项目后：我发觉自己在开发前端项目时，虽然有一定的开发规划，正如前文个人规划不足的第二点所说，但是无论是整体开发流程还是开发细节流程上，都是可以进一步完善的。比如：这一次，我设计好路由后，就直接开始逐个开发主页，然而考虑到很多组件的复用性，其实在总体把握和分析好项目界面后再去开发会更好，如果有了原型图，那么就更应该进一步观察和分析项目原型图，分析哪些部分是可以进行复用的，这样才能提高代码的可维护性，提高项目的开发效率。Vue的组件机制是很好的！要学会利用这一机制，本次项目的一个比较简单的点就在于，主页全是表格插槽，没有涉及太多父子组件传值等机制。因此，这个项目还不够，远远不够。以上是细节的角度；而从总体流程上来看，应该更有规划一些，先静态，再动态，先结构，再样式，先分析，再设计。只有最不会写代码的人，才会急于去写代码！！！</li></ol><h3 id="进步"><a href="#进步" class="headerlink" title="进步"></a>进步</h3><h4 id="非代码能力进步"><a href="#非代码能力进步" class="headerlink" title="非代码能力进步"></a>非代码能力进步</h4><p>在写完了这篇文章后才算真正完成这个项目，写文档这一行为本身就是非代码能力上的最大的进步！进行本次完整的开发后，深刻反思和认识到<strong>分析</strong>的重要性，千万不能一股脑地动代码！！！总体按照开发思路来，而对于具体的页面开发部分，要分析原型图和需求，考虑哪些部分可以进行组件化开发，考虑哪些部分是需要和团队沟通来改进、调整的。</p><h4 id="开发能力进步"><a href="#开发能力进步" class="headerlink" title="开发能力进步"></a>开发能力进步</h4><p>New：能够开发出一个动态网站，进行权限管理，添加一些简单动画来优化用户体验，通过深度样式改变EP的原生样式，进一步封装各种依赖工具：pinia，axios</p><p>Up：在路由设计中用动态组件来提高效率。。。想不到别的了(✿◡‿◡)</p><h3 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h3><ol><li>开发出客户端，小组成员可能不会再理这个项目了，但是，本人将在完善好后端方面的知识后，进行项目的扩展开发，实现客户端的开发，并实现管理端的其他功能，包括文件上传，模糊查询，个人信息的更新等；</li><li>进一步学习JavaWeb，用SSM进行后端的编写，进一步学习Redis数据库，进行数据缓存存储的优化，进一步学习Vue的其他技巧。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>前端项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Branch&amp;Bound</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Branch&amp;Bound/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Branch&amp;Bound/</url>
    
    <content type="html"><![CDATA[<h1 id="Branch-Bound"><a href="#Branch-Bound" class="headerlink" title="Branch&amp;Bound"></a>Branch&amp;Bound</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>与回溯法的区别：回溯法掌握穿越时空技术可以遍历所有的解集。而分支限界掌握预知能力，能提前看清unpromising解并跳过他的求解过程，只专注于最优解，也正是他傲慢和无情地依靠自己的预知，他无法遍历所有的解(除非他的预知太烂了！或者解空间本来就很小)。回溯法依次看到每种结局再回退(dfs)，分支限界放眼所有情况但只考虑最有希望的节点(bfs)，按照自己的预测方式走下去,如果预测方式刁钻(优先队列),他在解空间上的遍历还会是跳跃的，运气好的话他甚至能直接找到最优解。</p><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>用分支限界写01背包，普通队列：</p><p>准备一个队列和三个队列节点:分别表示根节点，左子节点(选择了该层对应的背包)，右子节点(未选择该层对应的背包)。初始化根节点，根节点入队，队不空则循环：{ 出队并记录该节点于e节点(子也将成为父,因此将信息保存到e很合理！),然后考虑左子结点，先剪枝超重的情况,若未超重,则为e1赋数据并判断上界后入队或剪枝 。在考虑右子节点，赋予数据并求上界后入队或剪枝}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> W = <span class="hljs-number">6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> total = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> w[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> v[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-type">int</span> maxValue = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> tatic[MAX];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span> &#123;<br><span class="hljs-type">int</span> no;<br><span class="hljs-type">int</span> layer;<br><span class="hljs-type">int</span> weight;<br><span class="hljs-type">int</span> value;<br><span class="hljs-type">double</span> upper;<br><span class="hljs-type">int</span> x[MAX];<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(queue&lt;NodeType&gt; &amp;q,NodeType e)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (e.layer == n) &#123;<br><span class="hljs-keyword">if</span> (e.value &gt; maxValue)<br>&#123;<br>maxValue = e.value;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>tatic[i] = e.x[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>q.<span class="hljs-built_in">push</span>(e);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bound</span><span class="hljs-params">(NodeType&amp; e)</span> </span>&#123;<br><span class="hljs-type">double</span> nowV = e.value; <span class="hljs-type">int</span> nowW = e.weight; <span class="hljs-type">int</span> layer = e.layer+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (layer &lt;= n &amp;&amp; nowW + w[e.layer] &lt;= W) &#123;<br>nowV += v[layer];<br>nowW += w[layer];<br>layer++;<br>&#125;<br><span class="hljs-keyword">if</span> (layer &lt;= n)<br>e.upper = nowV + (v[layer] / w[layer]) * (W - nowW);<br><span class="hljs-keyword">else</span><br>e.upper = nowV+ v[layer];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><br>NodeType e, e1, e2; queue&lt;NodeType&gt; q;<br>e.value = <span class="hljs-number">0</span>; e.weight = <span class="hljs-number">0</span>; e.layer = <span class="hljs-number">0</span>; e.no = total++;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>e.x[i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*bound(e);*/</span><br>q.<span class="hljs-built_in">push</span>(e);<br><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>e = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (e.weight + w[e.layer + <span class="hljs-number">1</span>] &lt;= W) &#123;<br>e1.no = total++;<br>e1.layer = e.layer + <span class="hljs-number">1</span>;<br>e1.weight = e.weight + w[e1.layer];<br>e1.value = e.value + v[e1.layer];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>e1.x[i] = e.x[i];<br>e1.x[e1.layer] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">bound</span>(e1);<br><span class="hljs-keyword">if</span>(e1.upper&gt;maxValue)<br><span class="hljs-built_in">EnQueue</span>(q, e1);<br>&#125;<br>e2.no = total++;<br><span class="hljs-comment">/*e2.layer = e1.layer;*/</span> <span class="hljs-comment">//错误 不能以e1为基准，因为可能没有e1</span><br>e2.layer = e.layer + <span class="hljs-number">1</span>;<br>e2.value = e.value; e2.weight = e.weight;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>e2.x[i] = e.x[i];<br>e2.x[e2.layer] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">bound</span>(e2);<br><span class="hljs-keyword">if</span> (e2.upper &gt; maxValue)<br><span class="hljs-built_in">EnQueue</span>(q, e2);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-keyword">if</span> (tatic[i])<br>cout &lt;&lt; <span class="hljs-string">&quot;选择物品 &quot;</span> &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; 价值为：&quot;</span>&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; 重量为：&quot;</span>&lt;&lt;w[i]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;总价值为：&quot;</span> &lt;&lt; maxValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>优先级队列：</p><p>队列不再按FIFO顺序，而按高upper优先，因此能更快搜索到最优解。只需要将队列换成优先级队列，重载NodeType&lt;运算符：<code>return upper&lt; anotherE.upper</code> 使满足大upper优先。</p><h2 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h2><p>优先级队列解法：优先出队最小的可能cost 即优先出队最小下界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">200</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> c[MAX][MAX] = &#123; &#123;<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&#125; &#125;;<br><span class="hljs-type">int</span> tactic[MAX];<br><span class="hljs-type">int</span> minCost=INF;<br><span class="hljs-type">int</span> total = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><br>&#123;<br><span class="hljs-type">int</span> layer;<br><span class="hljs-type">int</span> no;<br><span class="hljs-type">int</span> cost;<br><span class="hljs-type">bool</span> worker[MAX];<span class="hljs-comment">//worker[i]=true表示任务i已经分配</span><br><span class="hljs-type">double</span> lower;<br><span class="hljs-type">int</span> tactic[MAX];<span class="hljs-comment">//x[i]为人员i分配的任务编号</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> NodeType&amp; aNode)<span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> lower&gt;aNode.lower;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bound</span><span class="hljs-params">(NodeType &amp;e)</span> </span>&#123;<br><span class="hljs-type">int</span> lower = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = e.layer + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-type">int</span> nowMinCost = INF;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (e.worker[j] == <span class="hljs-literal">false</span> &amp;&amp; c[i][j] &lt; nowMinCost)<br>nowMinCost = c[i][j];<br>lower += nowMinCost;<br>&#125;<br>e.lower =e.cost+lower;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>NodeType e, e1;<br>priority_queue&lt;NodeType&gt; q;<br>e.cost = <span class="hljs-number">0</span>; e.layer = <span class="hljs-number">0</span>; e.no = total++;<br><span class="hljs-built_in">memset</span>(e.tactic, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(e.tactic));<br><span class="hljs-built_in">memset</span>(e.worker, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(e.worker));<br>q.<span class="hljs-built_in">push</span>(e);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>e = q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (e.layer == n) &#123;<br><span class="hljs-keyword">if</span> (e.cost &lt; minCost) &#123;<br>minCost = e.cost;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>tactic[i] = e.tactic[i];<br>&#125;<br>&#125;<br>e1.layer = e.layer + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (e.worker[i])<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//若任务已经分配则跳过</span><br>e1.no = total++;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; e1.tactic[i] = e.tactic[i]; e1.worker[i] = e.worker[i]; &#125;<br>e1.tactic[e1.layer] = i; e1.worker[i] = <span class="hljs-literal">true</span>;<br>e1.cost = e.cost + c[e1.layer][i];<br><span class="hljs-built_in">bound</span>(e1);<br><span class="hljs-keyword">if</span> (e1.lower &lt; minCost)<br>q.<span class="hljs-built_in">push</span>(e1);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">bfs</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;最佳安排方案：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>cout &lt;&lt; <span class="hljs-string">&quot;\n给第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个人分配任务&quot;</span> &lt;&lt; tactic[i]&lt;&lt;<span class="hljs-string">&quot; 成本为：&quot;</span>&lt;&lt;c[i][tactic[i]];<br>cout &lt;&lt; <span class="hljs-string">&quot;\n总成本为：&quot;</span> &lt;&lt; minCost;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流水线调度"><a href="#流水线调度" class="headerlink" title="流水线调度"></a>流水线调度</h2><p>建议johnson算法。这里采用优先级队列写出：</p><p>分析：与任务分配几乎相同的写法，流水线调度之前就分析过<code>f1=f1+a[i];f2=max(f1,f2[i-1]+b[i])</code>设问题的解集树的层数表示当前处理的步骤：根节点(无实际意义)，叶节点(处理的最后一步,得到了一组完整方案),因此当程序执行到解集树中某个节点时,考虑当前还没有完成的作业(因此需要设计一个bool数组表示每个作业是否完成了),将这些作业的b时间累加起来就是当前节点的下界，如果该下界还小于已经求出了的minTime的话,就可以果断剪枝了。同时,也知道了,优先出队下界小的节点。</p><p>思路：首先设置节点类型结构体：包括 当前节点的解向量int[]，当前节点的作业完成情况bool[],当前节点的下界,当前节点的层数,a时间累计(f1),b时间累计(f2),操作符重载,还可以增设一个节点编号,可以统计节点数量。然后将根节点初始化并进队,然后只要队不空就循环,在任务分配问题中,进入循环后就判断出队的节点的层数,若为叶节点就输出,实际上,在一个节点产生时就已经可以根据其layer判断是否为叶节点了，因此叶节点其实不必进队！这里将对这一部分进行优化，后续的操作无非复制父节点数据，修改关键数据并判断。此问题的限界函数更简单，只要遍历未完成的任务，将任务的b时间累加加加上当前节点的f2就可以得到下界了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f<span class="hljs-comment">//定义∞</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 21</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<span class="hljs-comment">//作业数</span><br><span class="hljs-type">int</span> a[MAX]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//M1上的执行时间,不用下标0的元素</span><br><span class="hljs-type">int</span> b[MAX]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//M2上的执行时间,不用下标0的元素</span><br><br><span class="hljs-comment">//int a[MAX]=&#123;0,5,10,9,7&#125;;//M1上的执行时间,不用下标0的元素</span><br><span class="hljs-comment">//int b[MAX]=&#123;0,7,5, 9,8&#125;;//M2上的执行时间,不用下标0的元素</span><br><br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> bestf=INF;<span class="hljs-comment">//存放最优调度时间</span><br><span class="hljs-type">int</span> bestx[MAX];<span class="hljs-comment">//存放当前作业最佳调度</span><br><span class="hljs-type">int</span> total=<span class="hljs-number">1</span>;<span class="hljs-comment">//结点个数累计</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><span class="hljs-comment">//队列结点类型</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//结点编号</span><br><span class="hljs-type">int</span> x[MAX];<span class="hljs-comment">//x[i]表示第i步分配作业编号</span><br><span class="hljs-type">int</span> y[MAX];<span class="hljs-comment">//y[i]=1表示编号为i的作业已经分配</span><br><span class="hljs-type">int</span> i;<span class="hljs-comment">//步骤编号</span><br><span class="hljs-type">int</span> f1;<span class="hljs-comment">//已经分配作业M1的执行时间</span><br><span class="hljs-type">int</span> f2;<span class="hljs-comment">//已经分配作业M2的执行时间</span><br><span class="hljs-type">int</span> lb;<span class="hljs-comment">//下界</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> NodeType &amp;s) <span class="hljs-type">const</span><span class="hljs-comment">//重载&lt;关系函数</span><br>&#123;<br><span class="hljs-keyword">return</span> lb&gt;s.lb;<span class="hljs-comment">//lb越小越优先出队</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bound</span><span class="hljs-params">(NodeType &amp;e)</span><span class="hljs-comment">//求结点e的限界值</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//扫描所有作业</span><br><span class="hljs-keyword">if</span> (e.y[i]==<span class="hljs-number">0</span>) sum+=b[i];<span class="hljs-comment">//仅累计e.x中还没有分配的作业的b时间</span><br>e.lb=e.f1+sum;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has</span><span class="hljs-params">(NodeType e,<span class="hljs-type">int</span> j)</span><span class="hljs-comment">//作业j是否已经分配</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span> (e.x[i]==j)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span><span class="hljs-comment">//求解流水作业调度问题</span></span><br><span class="hljs-function"></span>&#123;<br>NodeType e,e1;<br>priority_queue&lt;NodeType&gt; qu;<br><span class="hljs-built_in">memset</span>(e.x,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(e.x));<span class="hljs-comment">//初始化根结点的x</span><br><span class="hljs-built_in">memset</span>(e.y,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(e.y));<span class="hljs-comment">//初始化根结点的y</span><br>e.i=<span class="hljs-number">0</span>;<span class="hljs-comment">//根结点</span><br>e.f1=<span class="hljs-number">0</span>;<br>e.f2=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">bound</span>(e);<br>e.no=total++;<br>qu.<span class="hljs-built_in">push</span>(e);<span class="hljs-comment">//根结点进队列</span><br><span class="hljs-keyword">while</span> (!qu.<span class="hljs-built_in">empty</span>())<br>&#123;<br>e=qu.<span class="hljs-built_in">top</span>(); qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队结点e</span><br>e1.i=e.i+<span class="hljs-number">1</span>;<span class="hljs-comment">//扩展分配下一个步骤的作业，对应结点e1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//考虑n个作业</span><br>&#123;<br><span class="hljs-keyword">if</span> (e.y[j]==<span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//作业j是否已分配,若已分配，跳过</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i1=<span class="hljs-number">1</span>;i1&lt;=n;i1++)<span class="hljs-comment">//复制e.x得到e1.x</span><br>e1.x[i1]=e.x[i1];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i2=<span class="hljs-number">1</span>;i2&lt;=n;i2++)<span class="hljs-comment">//复制e.y得到e1.y</span><br>e1.y[i2]=e.y[i2];<br>e1.x[e1.i]=j;<span class="hljs-comment">//为第i步分配作业j</span><br>e1.y[j]=<span class="hljs-number">1</span>;<span class="hljs-comment">//表示作业j已经分配</span><br>e1.f1=e.f1+a[j];<br>e1.f2=<span class="hljs-built_in">max</span>(e.f2,e1.f1)+b[j];<br><span class="hljs-built_in">bound</span>(e1);<br><span class="hljs-keyword">if</span> (e1.i==n)<span class="hljs-comment">//达到叶子结点</span><br>&#123;<br><span class="hljs-keyword">if</span> (e1.f2&lt;bestf)<span class="hljs-comment">//比较求最优解</span><br>&#123;<br>bestf=e1.f2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j1=<span class="hljs-number">1</span>;j1&lt;=n;j1++)<br>bestx[j1]=e1.x[j1];<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//找到一个解后结束</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (e1.f2&lt;=bestf)<span class="hljs-comment">//剪枝</span><br>&#123;<br>e1.no=total++;<span class="hljs-comment">//结点编号增加1</span><br>qu.<span class="hljs-built_in">push</span>(e1);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">bfs</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最优方案:\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   第%d步执行作业%d\n&quot;</span>,k,bestx[k]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   总时间=%d\n&quot;</span>,bestf);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图的单源最短路径"><a href="#图的单源最短路径" class="headerlink" title="图的单源最短路径"></a>图的单源最短路径</h2><p>o(<em>￣︶￣</em>)o</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>分支限界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/DP_TEXT/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/DP_TEXT/</url>
    
    <content type="html"><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><blockquote><ol><li>dp数组设计和初始化 </li><li>状态转移方程设计 </li><li>举例并反推</li></ol></blockquote><span id="more"></span><h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><blockquote><p>整数N分解成不超过K的自然数的和，求拆分方案的个数：</p></blockquote><p>分析：设有F(N,K)表示最终结果。容易知道：<code>F(1,x)=1 and F(x,1)=1</code><br>当N&lt;K 时：<code>F(N,K)=F(N,N)</code><br>当N&#x3D;K 时：可以考虑将整数就分解为他本身这一种方案 和 F(N,K-1) 有：<code>F(N,K)=1+F(N,K-1)</code><br>当N&gt;K 时：可以分类讨论拆分的数中是否包含K，若包含：则其余的数的和必然为:N-K 现在只需要考虑N-K如何拆分即可，故有：F(N-K,K)；若不包含：则拆分可以转变为：F(N,K-1) 有：<code>F(N,K)=F(N,K-1)+F(N-K,K)</code><br>因此：<img src="https://s3.bmp.ovh/imgs/2023/11/21/aa143084b1426144.png"><br>设DP[n][k]为答案。因此源程序如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> dp[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; j++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> j == <span class="hljs-number">1</span>)<br>dp[i][j] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; j)<br>dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] + dp[i - j][j];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == j)<br>dp[i][j] = <span class="hljs-number">1</span> + dp[i][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = dp[i][i];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>;<br>cin &gt;&gt; n&gt;&gt; k;<br><span class="hljs-built_in">solution</span>(n, k);<br>cout &lt;&lt; dp[n][k];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最大连续子序列和问题"><a href="#最大连续子序列和问题" class="headerlink" title="最大连续子序列和问题"></a>最大连续子序列和问题</h2><blockquote><p>一段数字序列 求其中的最大连续和子序列</p></blockquote><p>分析：问题分成两部分：求值，构建具体的序列。<br>设dp[N]为包括Sequence[N-1]往前的最大连续子序列和。<br>关键在于找状态转移方程：<code>dp[N]=max&#123;dp[N-1]+Sequence[N-1],Sequence[N-1]&#125;</code><br>Sequence[N-1]为序列数组末尾元素。<br>且一定有边界条件：<code>dp[0]=0</code>,没有所谓的前0个元素，是从1开始确定的，这里只是个主观规定。</p><p>通过dp很容易求出最大连续子序列和，但是要考虑如何通过这个结果构造出具体的子序列.</p><blockquote><p><em><strong>从抽象入手总是困难，不妨设置一些用例来帮助分析，写算法就是如此，这样的用例可能无法覆盖所有的情况，所有就有了一个叫做debug的工作来完善你的算法思想。</strong></em></p></blockquote><p>设-2 11 -4 13 -5 -2<br>则dp[1]&#x3D;max{0-2，-2}&#x3D;-2；<br>dp[2]&#x3D;max{-2+11,11}&#x3D;11;<br>dp[3]&#x3D;max{11-4,-4}&#x3D;7;<br>dp[4]&#x3D;max{7+13,13}&#x3D;20;<br>dp[5]&#x3D;max{20-5,-5}&#x3D;15;<br>dp[6]&#x3D;max{15-2,-2}&#x3D;13.</p><p>最大的DP为20，最大子序列为11 -4 13。根据这个例子：若dp一开始为负数，则后来一旦出现正数，那么那个负数就不会再计入在最大子序列中，因此那个负数就是临界处。每一次dp的负数，都是对连续子序列的一次重新选择。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span>* s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>dp[i] = <span class="hljs-built_in">max</span>( dp[i - <span class="hljs-number">1</span>] + s[i],s[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> dpMax=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (dp[i] &gt; dp[dpMax])<br>dpMax = i;<span class="hljs-comment">//记录其下标</span><br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大连续子序列和为:&quot;</span> &lt;&lt; dp[dpMax];<br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = dpMax; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br><span class="hljs-keyword">if</span> (dp[i] &lt;= <span class="hljs-number">0</span>) &#123;<br>start = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;子序列为：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start+<span class="hljs-number">1</span>; i &lt;= dpMax; ++i)<br>cout &lt;&lt; s[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-built_in">solution</span>(S,n);<br><span class="hljs-built_in">display</span>(S,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：连续最长数字串：读入一个字符串str，求出str中连续最长的数字串的长度。<br>如：abasjdbkjan1212ksnksn1221213213123；的连续最长数字串为1221213213123。<br>来源：P295</p></blockquote><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><blockquote><p>两个序列A B，求他们的最长的公共子序列C</p></blockquote><p>设A&#x3D;(a0,a1…am-1) B&#x3D;(b0,b1…bn-1) C&#x3D;(c0,c1…cz-1)<br>若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;am-1 C此时为a0..am-2 和 b0..bn-1的最长公共子序列<br>若 am-1!&#x3D;bn-1 and cz-1!&#x3D;bm-1 C此时为a0..am-1 和 b0..bn-2的最长公共子序列<br>因此对于am-1!&#x3D;bn-1的case C最终应是两种情况的最大值。<br>设dp[i][j]为a0..ai-1 与 b0..bj-1的最长公共子序列长度<br>则有<br><code>dp[i][j]=0   i=j=0 dp[i][j]=1+d[i-1][j-1]  ai-1=bj-1 dp[i][j]=max&#123;dp[i][j-1],dp[i-1][j]&#125; ai-1!=bj-1</code><br>这里又要涉及两个问题：求长度和求具体的序列。<br>考虑何时会使得公共序列中的元素+1?就是若 am-1&#x3D;bn-1 则 cz-1&#x3D;am-1&#x3D;bn-1,因此关键在于找到dp[i][j]，此时的i j能做出实质性的改变，也即跳过那些非公共元素，非公共元素不会影响dp[][]的值，因此对于相同行和列相邻且相同的dp[][]直接跳过，那些元素不是公共元素。<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//边界初始化</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//状态转换</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;=n; j++) &#123;<br><span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] == b[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">char</span>* a, <span class="hljs-type">char</span>* b, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>vector &lt;<span class="hljs-type">char</span>&gt; aimStr;<br><span class="hljs-type">int</span> k = dp[m][n];<br><span class="hljs-type">int</span> i = m;<br><span class="hljs-type">int</span> j = n;<br><span class="hljs-keyword">while</span> (k&gt;<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][j] == dp[i - <span class="hljs-number">1</span>][j])<br>--i;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[i][j] == dp[i][j - <span class="hljs-number">1</span>])<br>--j;<br><span class="hljs-keyword">else</span><br>&#123;<br>aimStr.<span class="hljs-built_in">push_back</span>(a[i - <span class="hljs-number">1</span>]);<br>--i; --j; --k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;长度为：&quot;</span> &lt;&lt; dp[m][n];<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;序列为:&quot;</span>&lt;&lt;endl;<br>vector &lt;<span class="hljs-type">char</span>&gt;::reverse_iterator rit;<br><span class="hljs-keyword">for</span> (rit = aimStr.<span class="hljs-built_in">rbegin</span>(); rit != aimStr.<span class="hljs-built_in">rend</span>(); ++rit)<br>cout &lt;&lt; *rit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input m,n&quot;</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string A&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input string B&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br><span class="hljs-built_in">display</span>(A,B,m,n);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>变式：求两个字符串A B的最长公共连续子串<br>来源P302</p></blockquote><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>字面意思 注意:不必连续</p></blockquote><p>到现在已经写了三个问题了，不难发现dp是一种思想，最关键在于状态的设置及其转换，分类讨论的思想也举足轻重。<br>假定有序列：1 2 3 0 1 5 2 3 4<br>结果是：0 1 2 3 4（不必连续，跳过5）<br>首先要知道最长长度，其次是去构造。<br><strong>设dp[i]为序列中以s[i]之前的最长递增子序列</strong><br>则有<br><strong>dp[i]&#x3D;1 and dp[i]&#x3D;max{dp[i],dp[j]+1},a[i]&gt;a[j] 0&lt;&#x3D;i&lt;&#x3D;n-1 0&lt;&#x3D;j&lt;&#x3D;i-1</strong><br>明显需要用到以外层循环定界的二重循环<br>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> *s,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>&amp; ans)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>&#123;<br>dp[i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (s[i] &gt; s[j])<br>dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>ans = <span class="hljs-built_in">max</span>(ans,dp[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* S = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>cin &gt;&gt; S[i];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">solution</span>(S, n,ans);<br>cout &lt;&lt; ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="序列编辑问题"><a href="#序列编辑问题" class="headerlink" title="序列编辑问题"></a>序列编辑问题</h2><blockquote><p>将A串编辑成B串的最小步数，操作方法有：删字符 插字符 换字符</p></blockquote><p><strong>设dp[i][j]为将A串的前i个元素编辑成B串的前j个元素所用的最少步数</strong><br>分析:若A[i-1]&#x3D;B[j-1] 则不必理会 <strong>dp[i][j]&#x3D;dp[i-1][j-1]</strong>;<br>若A[i-1]!&#x3D;B[j-1] 则可以通过三种方式完成：<br>1.将A[i-1]换成B[i-1]：dp[i][j]&#x3D;1+dp[i-1][j-1];<br>2.插入B[j-1]：dp[i][j]&#x3D;1+dp[i][j-1];<br>3.删除A[i-1]：dp[i][j]&#x3D;1+dp[i-1][j];<br>最终的结果是去这三种不同操作的最小值：<strong>dp[i][j]&#x3D;1+min{dp[i-1][j-1],dp[i][j-1],dp[i-1][j]}</strong><br>同时还有边界条件：当A为空时，则插入B.length次,当B为空时，则删除B.length次<br><strong>dp[x][0]&#x3D;x,dp[0][x]&#x3D;x</strong></p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">char</span>* A, <span class="hljs-type">char</span>* B, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[i][<span class="hljs-number">0</span>] = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)<br>dp[<span class="hljs-number">0</span>][i] = i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] == B[j - <span class="hljs-number">1</span>])<br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span><br>dp[i][j] = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]), dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> m=<span class="hljs-number">0</span>, n=<span class="hljs-number">0</span>;<br>cin &gt;&gt; m &gt;&gt; n;<br><span class="hljs-type">char</span>* A = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[m];<br><span class="hljs-type">char</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input A\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>cin &gt;&gt; A[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;input B\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; B[i];<br><span class="hljs-built_in">solution</span>(A, B, m, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;min edit step: &quot;</span> &lt;&lt;dp[m][n] ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><blockquote><p>n种物品 每种物品都有其重量和价值 每种物品只有一个 在限定总重W下尽可能获得最大的价值。</p></blockquote><p>给物品标上序号：x1…xn x为1则是拿走该物品，为0则不拿走<br>设dp[i][j]表示当容量为j时，物品1-i装入背包的最高价值。<br>dp[i][0]&#x3D;0 dp[0][j]&#x3D;0 dp[i][j]&#x3D;max{dp[i-1][j-w[i]]+v[i],dp[i-1][j]}<br>问题的解为dp[n][W];<br>设n&#x3D;5 W&#x3D;10 w[5]&#x3D;{2,2,6,5,4} v[5]&#x3D;{6,3,5,4,6} 下标从1开始<br>dp[1][1]:1个物品1个重量：   重量不够 只能不选                     价值：0<br>dp[1][2]:1个物品2个重量：   重量足够 决策max{dp[0][0]+6,dp[0][2]} 价值：6<br>dp[1][3]:1个物品3个重量：   重量足够 决策max{dp[0][1]+6,dp[0][3]} 价值：6<br>dp[1][4]:1个物品4个重量：   重量足够 决策max{dp[0][2]+6,dp[0][4]} 价值：6<br>dp[1][5]:1个物品5个重量：   重量足够 决策max{dp[0][3]+6,dp[0][5]} 价值：6<br>dp[1][6]:1个物品6个重量：   重量足够 决策max{dp[0][4]+6,dp[0][6]} 价值：6<br>dp[1][7]:1个物品7个重量：   重量足够 决策max{dp[0][5]+6,dp[0][7]} 价值：6<br>dp[1][8]:1个物品8个重量：   重量足够 决策max{dp[0][6]+6,dp[0][8]} 价值：6<br>dp[1][9]:1个物品9个重量：   重量足够 决策max{dp[0][7]+6,dp[0][9]} 价值：6<br>dp[1][10]:1个物品10个重量： 重量足够 决策max{dp[0][8]+6,dp[0][10]} 价值：6</p><p>dp[2][1]:2个物品1个重量：   重量不够 只能不选                      价值：0<br>dp[2][2]:2个物品2个重量：   重量足够 决策max{dp[1][0]+3,dp[1][2]}  价值：6<br>dp[2][3]:2个物品3个重量：   重量足够 决策max{dp[1][1]+3,dp[1][3]}  价值：6<br>dp[2][4]:2个物品4个重量：   重量足够 决策max{dp[1][2]+3,dp[1][4]}  价值：9<br>dp[2][5]:2个物品5个重量：   重量足够 决策max{dp[1][3]+3,dp[1][5]}  价值：9<br>dp[2][6]:2个物品6个重量：   重量足够 决策max{dp[1][4]+3,dp[1][6]}  价值：9<br>dp[2][7]:2个物品7个重量：   重量足够 决策max{dp[1][5]+3,dp[1][7]}  价值：9<br>dp[2][8]:2个物品8个重量：   重量足够 决策max{dp[1][6]+3,dp[1][8]}  价值：9<br>dp[2][9]:2个物品9个重量：   重量足够 决策max{dp[1][7]+3,dp[1][9]}  价值：9<br>dp[2][10]:2个物品10个重量：   重量足够 决策max{dp[1][8]+3,dp[1][10]}  价值：9<br>dp[3][1]:3个物品1个重量：   重量不够 只能不选                      价值：0</p><p>跟着dp设计分析一遍发现：还真是~ 验证一下最终结果?dp[5][10]&#x3D;max{dp[4][10],dp[4][10-w[4]]+v[4]}…以此类推</p><blockquote><p>01背包问题，只要记住dp的设计即可。其他只要你验证就发现是对的，也不难，但是麻烦，只要牢记这样子做是对的，就这样做即可。都是前辈们铺好了的路。<br>另一个值得考虑的问题是，如何构造出具体的方案，每个dp总是这样，通过设计dp数组和递推方程给出结果，但具体的方案，一般是通过dp的设计思路并结合最终结果<strong>反推</strong>得到的：<br>源程序：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W=<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-comment">//下标为0的不用 不然不便于展现清晰的思路</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">bool</span> x[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-literal">false</span> &#125;;<span class="hljs-comment">//表示编号为下标的背包有没有被选 0就是选了 1就是没选 便于输出方案</span><br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Knap01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//先写边界条件，发现其他dp也都是如此</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=W;i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//然后由递推方程构建dp各项</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-comment">//leftWeight为可用的重量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> leftWeight = <span class="hljs-number">1</span>; leftWeight &lt;= W; leftWeight++)<br>&#123;<br><span class="hljs-keyword">if</span> (leftWeight &lt; w[i])<span class="hljs-comment">//可用重量小于当前物品重量 则不可选</span><br>dp[i][leftWeight] = dp[i - <span class="hljs-number">1</span>][leftWeight];<br><span class="hljs-keyword">else</span><br>&#123;<br>dp[i][leftWeight] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][leftWeight],dp[i<span class="hljs-number">-1</span>][leftWeight-w[i]]+v[i]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//已经求出了dp各项，现要根据dp项构造出选择方案；根据之前的分析发现：如果因为决策没选择和因为重量不够而不选择，他们的结构都一样</span><br><span class="hljs-comment">//他们的递推式都一样，因为原因不重要，重要的是你到底选没有选择。因此，只要你没有选择，我就要使用对应的递推方程；</span><br><span class="hljs-comment">//反过来说，要是你满足某个递推方程，那么你就一定没被选，再进一步，如果你不满足那个递推式，那你就一定被选了。</span><br><span class="hljs-comment">//循环的边界情况都已经考虑好了，因此只要记住即可</span><br><span class="hljs-type">int</span> i = n;<br><span class="hljs-type">int</span> leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] != dp[i - <span class="hljs-number">1</span>][leftWeight])<br>&#123;<br>x[i] = <span class="hljs-literal">true</span>;<br>leftWeight -= w[i];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>x[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>i--;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Knap01</span>();<br><span class="hljs-built_in">choose</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;选择的物品编号：\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (x[i] == <span class="hljs-number">1</span>)<br>cout &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n总价值为：&quot;</span> &lt;&lt; dp[n][W];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><blockquote><p>在01背包的基础上:那些物品每样都有无穷多个。求此时的最大价值选法。<br>真·多重背包问题将在AcWing部分解决。</p></blockquote><p>分析：在01的问题上增设一个属性：物品的数量，dp还是那个dp，dp[i][j]：在重量为j的情况下选择1-i号物品的最大收益，但此时还要增加另一个变量fk[i][j]表示dp[i][j]下i物品选择的数量。</p><p>dp[i][j]&#x3D;max{dp[i-1][j-k<em>w[i]]+k</em>v[i],dp[i-1][j]},第一项也是关于K的最大值函数。<br>设：n&#x3D;3 W&#x3D;7 w[4]&#x3D;{0,3,4,2} v[4]&#x3D;{0,4,5,3}<br>dp[0][x]&#x3D;dp[x][0]&#x3D;0<br>dp[1][1]&#x3D;0 dp[1][2]&#x3D;0 dp[1][3]&#x3D;4(k&#x3D;1) dp[1][4]&#x3D;4(k&#x3D;1) dp[1][5]&#x3D;4(k&#x3D;1) d[1][6]&#x3D;8(k&#x3D;2) dp[1][7]&#x3D;8(k&#x3D;2)</p><p>dp[2][1]&#x3D;0 dp[2][2]&#x3D;0 dp[2][3]&#x3D;4 dp[2][4]&#x3D;max{dp[1][3],dp[1][4-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][5]&#x3D;max{dp[1][5],dp[1][5-4k]+5k}&#x3D;5(k&#x3D;1) dp[2][6]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0) dp[2][7]&#x3D;max{8,5}&#x3D;8(k&#x3D;2,0)…</p><p>源程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> fk[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initial</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++)<br>dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= W; i++)<br>dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxValue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//背包序号dp的i</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> leftWeight=<span class="hljs-number">1</span>;leftWeight&lt;=W;leftWeight++)<span class="hljs-comment">//剩余重量dp的j</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * w[i] &lt;= leftWeight; k++)<span class="hljs-comment">//数量fk的值</span><br>&#123;<br><span class="hljs-keyword">if</span> (dp[i][leftWeight] &lt; dp[i - <span class="hljs-number">1</span>][leftWeight - k * w[i]] + k * v[i])<span class="hljs-comment">//找出最大值对应的K</span><br>&#123;<br>dp[i][leftWeight] = dp[i<span class="hljs-number">-1</span>][leftWeight-k*w[i]]+k*v[i];<br>fk[i][leftWeight] = k;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;最大价值是：&quot;</span> &lt;&lt; dp[n][W];<br><span class="hljs-keyword">return</span> dp[n][W];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">choose</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> i = n, leftWeight = W;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">1</span>) &#123;<br>cout &lt;&lt;endl&lt;&lt; <span class="hljs-string">&quot;物品&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;拿走了&quot;</span> &lt;&lt; fk[i][leftWeight] &lt;&lt; <span class="hljs-string">&quot;件数&quot;</span>;<br>leftWeight -= fk[i][leftWeight] * w[i];<br>--i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">initial</span>();<br><span class="hljs-built_in">MaxValue</span>();<br><span class="hljs-built_in">choose</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h2><blockquote><p>将有限的资源分配给有限的使用者，使得总收益最大。是完全背包问题的变式</p></blockquote><h2 id="会议安排"><a href="#会议安排" class="headerlink" title="会议安排"></a>会议安排</h2><h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><blockquote><p>dp数组项在构建时，往往只会利用前几项，或者说，某一项只会在构建出其后几项被利用，如果最终的结果只要求最终项，那么很多项在被利用后是可以抛弃的，这部分空间完全是浪费了，因此设置滚动数组压缩存储空间。一般是通过取模运算完成。</p></blockquote><p>举例：斐波那列数列的dp数组 <strong>元素依赖跨度</strong>为3 设置dp[3]<br>于是dp[i%3]&#x3D;dp[(i-2)%3]+dp[(i-1)%3]<br>01Knap 元素依赖跨度为第一维的i 跨度为2 设置dp[2][j]<br>前者的值只有0,1 可以考虑取模但很傻，可以考虑用初始x&#x3D;0；之后x&#x3D;1-x；代替取模运算，核心不变，就是通过手段将数组存储空间压缩为其元素依赖跨度即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Backtrack</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Backtrace/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Backtrace/</url>
    
    <content type="html"><![CDATA[<h1 id="Backtrack"><a href="#Backtrack" class="headerlink" title="Backtrack"></a>Backtrack</h1><blockquote><p>后悔药，时光机…没有什么最优解，只是遍历了所有时空才确定了你。</p></blockquote><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="递归和非递归"><a href="#递归和非递归" class="headerlink" title="递归和非递归"></a>递归和非递归</h3><p>回溯法可由递归和非递归方式实现，根据问题性质是排列还是集合，也可以抽象出对应的模板。<br>非递归回溯需要设计额外的数据结构来保存节点。</p><h3 id="排列与子集"><a href="#排列与子集" class="headerlink" title="排列与子集"></a>排列与子集</h3><p>问题的解空间树有两种类型。若问题为从含n个元素的集合S中找出符合某约束的元素的集合，此为<strong>子集树</strong>，比如求子集问题；若问题为从含n个元素的集合S从，找出满足约束的n个元素的排列，此为<strong>排列树</strong>，比如求全排列问题。</p><h4 id="幂集问题"><a href="#幂集问题" class="headerlink" title="幂集问题"></a>幂集问题</h4><p>分析：设定一个数组bool choose[n]表示这n个对应的元素是否被选了，因此对于n个元素，从第一个元素开始，若选中了，则置choose[i]&#x3D;1;直到处理完最后一个元素，输出这组结果，然后回溯上一层…</p><p>建模：</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/21/b6461ba45eeeb71f.png"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//now：当前处理的元素 last：数组末尾元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">bool</span> c[],<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now &gt;= last) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&#123; &quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; last; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (c[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt; a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>c[now] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(a, c, now + <span class="hljs-number">1</span>, last);<br>c[now] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(a, c, now + <span class="hljs-number">1</span>, last);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input array length:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-type">bool</span>* choose = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n);<br>cout &lt;&lt; <span class="hljs-string">&quot;input array elements:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; array[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(array,choose,<span class="hljs-number">0</span>,n);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h4><p>分析：从数组首元素开始处理，让他与自己交换位置，然后处理交换位置后的元素，让他与自己交换…最终处理到最后一个元素，由于是与自身交换位置，此时的序列不会有任何改变，因为没有后继元素了，则输出该序列然后回溯到上一层，处理倒数第二的元素，这次让他与倒数第一的元素交换位置（而非自身），此时进入下一层，处理末元素，又得到一组结果，然后再回溯到上上层…</p><p>建模：</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/21/3ef8173d66043f60.png"></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//now：当前处理的元素 last：数组末尾元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> now, <span class="hljs-type">int</span> last)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (now == last)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; last; i++)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">return</span>;<span class="hljs-comment">//在这里回溯了</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt; last; i++)<br>&#123;<br><span class="hljs-built_in">swap</span>(a[now], a[i]);<br><span class="hljs-built_in">dfs</span>(a, now + <span class="hljs-number">1</span>, last);<br><span class="hljs-built_in">swap</span>(a[now], a[i]);<span class="hljs-comment">//当回到当前层，还需要换回，保证是当前处理的元素与后续元素分别交换。再进入下一次循环。</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input array length:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-type">int</span>* array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>cout &lt;&lt; <span class="hljs-string">&quot;input array elements:\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>cin &gt;&gt; array[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(array, <span class="hljs-number">0</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>比较：</p><p>排列树的决策是交换，恢复是换回，子集树的决策是选择是否，恢复是做出另一选择。另外，问题也有维度之分，多维问题，除了dfs本身的层数外，在主要决策处也会有循环试探：N皇后，任务分配。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>为了提高回溯法的时间效率，常常要考虑剪枝，进一步涉及到左子树的剪枝和右子树的剪枝：<br>对于右子树的剪枝，一般还要额外设置一个函数参数rightIndex。<br>左子树：一般是无法满足的条件：比如背包问题中剩余重量不够用。<br>右子树：一般是不用判断，一定满足的条件：比如背包问题中即使后续全选也不会超重。<br>对于复杂问题，还要专门写出一个剪枝函数prune：比如活动安排问题中的剪枝函数：</p><h3 id="回溯和深度遍历"><a href="#回溯和深度遍历" class="headerlink" title="回溯和深度遍历"></a>回溯和深度遍历</h3><p>可以简略地认为<code>backtrace=dfs with pruning.</code>他们本来就很暧昧~</p><h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p> 可以抽象为子集问题，回溯于：是否选择某物品。</p><blockquote><p>分析：约束在于总重，优化在于价值。决策将会影响重量和价值，只需要遍历所有的决策组合，约束和优化在最后一层判断。将决策与约束和优化分离后就会清晰很多。感觉不如dp…效率。但是思想也很美~</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> W = <span class="hljs-number">6</span>;<br><span class="hljs-comment">//下标为0不考虑，便于叙述 第N个背包和数组下标</span><br><span class="hljs-type">int</span> w[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> v[n+<span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">//最优选择方案和最大价值</span><br><span class="hljs-type">bool</span> choose[n+<span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> maxValue=<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//layer:解集树层次，即正在第LAYER个物品。</span><br><span class="hljs-comment">//nowChoose现在的选择方案</span><br><span class="hljs-comment">//nowWeight现在的总重量 nowValue现在的总价值</span><br><span class="hljs-comment">//leftWeights:剩下的背包的重量，用于剪枝.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">bool</span> nowChoose[], <span class="hljs-type">int</span> nowWeight, <span class="hljs-type">int</span> nowValue,<span class="hljs-type">int</span> leftWeights)</span> </span>&#123;<br><span class="hljs-comment">//n个物品，对每个物品依次进行抉择，最多讨论n层。n层后定结论</span><br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-keyword">if</span> (nowWeight == W <span class="hljs-keyword">and</span> nowValue &gt; maxValue) &#123;<br>maxValue = nowValue;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>choose[i] = nowChoose[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//当前总重量加上此物品的重量若&gt;最大能容纳的重量,则不能选这个物品！直接跳过</span><br>nowChoose[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (nowWeight+w[layer]&lt;=W) <br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>, nowChoose, nowWeight + w[layer], nowValue + v[layer],leftWeights-w[layer]);<br><span class="hljs-comment">//实际上想表达：若剩下的所有物品的总重量与当前重量的和都要小于最大能容纳的重量，</span><br><span class="hljs-comment">//那为了最大价值，自然是希望狂拿的，反正也不会超重.就不会再考虑不拿的情况了.</span><br>nowChoose[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (nowWeight+leftWeights &gt;= W) <br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>, nowChoose, nowWeight, nowValue,leftWeights-w[layer]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> nowChoose[n + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(nowChoose, <span class="hljs-literal">false</span>, n + <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> leftWeight = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>leftWeight += w[i];<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, nowChoose, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>,leftWeight);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;choose tactic:&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (choose[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;object&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; value: &quot;</span> &lt;&lt; v[i] &lt;&lt; <span class="hljs-string">&quot; weight: &quot;</span> &lt;&lt; w[i];<br>&#125;<br>cout &lt;&lt;<span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;maxValue:&quot;</span> &lt;&lt; maxValue;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="装载和复杂装载"><a href="#装载和复杂装载" class="headerlink" title="装载和复杂装载"></a>装载和复杂装载</h3><blockquote><p>一般装载问题：n个集装箱要装入载重为W的轮船，每个箱子重量：w<sub>i</sub> 求最佳装载方案。</p><p>分析：每个货物选或不选。不如背包问题。。。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> limitedWeight = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> w[N + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-type">int</span> maxWeight = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> choose[N + <span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">bool</span> c[],<span class="hljs-type">int</span> nowWeight,<span class="hljs-type">int</span> leftWeight)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; N) &#123;<br><span class="hljs-keyword">if</span> (nowWeight &gt; maxWeight &amp;&amp; nowWeight&lt;=limitedWeight) &#123;<br>maxWeight = nowWeight;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>choose[i] = c[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>c[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (nowWeight + w[layer] &lt;= limitedWeight) <br><span class="hljs-built_in">dfs</span>(layer+<span class="hljs-number">1</span>,c,nowWeight+w[layer],leftWeight-w[layer]);<br>c[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (nowWeight+leftWeight&gt;limitedWeight) <br><span class="hljs-built_in">dfs</span>(layer+<span class="hljs-number">1</span>,c,nowWeight,leftWeight-w[layer]);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> nowChoose[N+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(nowChoose, <span class="hljs-literal">false</span>, N+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, N+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> leftWeight = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>leftWeight += w[i];<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,nowChoose,<span class="hljs-number">0</span>,leftWeight);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) <br><span class="hljs-keyword">if</span>(choose[i])<br>cout &lt;&lt; <span class="hljs-string">&quot;\nobject &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; selected,weight:&quot;</span> &lt;&lt; w[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;\nEngross: &quot;</span> &lt;&lt; maxWeight;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>复杂装载问题：若有两艘船，找出方案使得所有货物能被运走。在一般装载问题的基础上，先只考虑承重大的那艘船，记为船A，尽可能多地装载，对于没有选中的货物默认装载在第二艘船，记为船B，最终再判断船B能否承受剩余的货物，若能则方案可行，否则没有任何方案能够做到带走这些货物。难点在于证明这个思路的正确性：</p><p>反证法：假如能够运走所有货物，但船A却不是最佳方案（承重尽可能最大）。</p><p>货物总重不变，记最终方案中：船A装载货物总重为L<sub>a</sub>，船B为L<sub>b</sub>，L<sub>a</sub>+L<sub>b</sub>&#x3D;&#x3D;&#x3D;Sum(W<sub>i</sub>) ,如果方案行得通，说明船B能承受L<sub>b</sub>，那对于比L<sub>b</sub>更小的它自然也能承受，而此时完全可以把货物调度到船A上。</p><p>有了思路后实现就很简单了，在原来的基础上修饰一下就好了。我就不写了，欣赏下书上的写法吧！(#^_^#)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 20<span class="hljs-comment">//最多集装箱个数</span></span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> w[] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">40</span>,<span class="hljs-number">40</span> &#125;;<span class="hljs-comment">//各集装箱重量,不用下标0的元素</span><br><span class="hljs-type">int</span>n = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> c1 = <span class="hljs-number">50</span>, c2 = <span class="hljs-number">50</span>;<br><span class="hljs-type">int</span> maxw = <span class="hljs-number">0</span>;<span class="hljs-comment">//存放第一艘轮船最优解的总重量</span><br><span class="hljs-type">int</span> x[MAXN];<span class="hljs-comment">//存放第一艘轮船最优解向量</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> tw, <span class="hljs-type">int</span> rw, <span class="hljs-type">int</span> op[], <span class="hljs-type">int</span> i)</span> <span class="hljs-comment">//求第一艘轮船的最优解</span><br>&#123;<br><span class="hljs-keyword">if</span> (i &gt; n)<span class="hljs-comment">//找到一个叶子结点</span><br>&#123;<br><span class="hljs-keyword">if</span> (tw &lt;= c1 &amp;&amp; tw &gt; maxw)<br>&#123;<br>maxw = tw;<span class="hljs-comment">//找到一个满足条件的更优解,保存它</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-comment">//复制最优解</span><br>x[j] = op[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//尚未找完所有集装箱</span><br>&#123;<br>op[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//选取第i个集装箱</span><br><span class="hljs-keyword">if</span> (tw + w[i] &lt;= c1)<span class="hljs-comment">//左孩子结点剪枝：装载满足条件的集装箱</span><br>dfs(tw + w[i], rw - w[i], op, i + <span class="hljs-number">1</span>);<br>op[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//不选取第i个集装箱,回溯</span><br><span class="hljs-keyword">if</span> (tw + rw &gt; c1)<span class="hljs-comment">//右孩子结点剪枝</span><br>dfs(tw, rw - w[i], op, i + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dispasolution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//输出一个解</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (x[j] == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t将第%d个集装箱装上第一艘轮船\n&quot;</span>, j);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t将第%d个集装箱装上第二艘轮船\n&quot;</span>, j);<br><br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span><span class="hljs-comment">//求解复杂装载问题</span><br>&#123;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-comment">//累计第一艘轮船装完后剩余的集装箱重量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br><span class="hljs-keyword">if</span> (x[j] == <span class="hljs-number">0</span>)<br>sum += w[j];<br><span class="hljs-keyword">if</span> (sum &lt;= c2)<span class="hljs-comment">//第二艘轮船可以装完</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//第二艘轮船不能装完</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> op[MAXN];<span class="hljs-comment">//存放临时解</span><br><span class="hljs-built_in">memset</span>(op, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(op));<br><span class="hljs-type">int</span> rw = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>rw += w[i];<br>dfs(<span class="hljs-number">0</span>, rw, op, <span class="hljs-number">1</span>);<span class="hljs-comment">//求第一艘轮船的最优解</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果\n&quot;</span>);<br><span class="hljs-keyword">if</span> (solve())<span class="hljs-comment">//输出结果</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    最优方案\n&quot;</span>);<br>dispasolution(n);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    没有合适的装载方案\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p>典中典。抽象为子集问题。回溯在于某坐标是否放置了皇后，难点在于建模，这个问题只有在第一次见的时候会觉得无从下手。</p><blockquote><p>分析：问题建模，用一维数组就可以描述棋盘，下标是行，元素值为列，下标+元素值确定一个坐标。用二维数组也可以，但是不简洁而且浪费空间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">total</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;No.&quot;</span> &lt;&lt; ++total&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (chess[i] != j)<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&quot;O&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlace</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//同对角线的处理:|x2-x1|==|y2-y1|!!!! 千万不要写成了|x1-y1|==|x2-y2|!!!</span><br><span class="hljs-comment">//后者在正对角线（\，捺）成立是最恶心的，对左对角线不成立！！！！！</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++)<br><span class="hljs-keyword">if</span> (chess[i]==y || (<span class="hljs-built_in">abs</span>(i-x)==<span class="hljs-built_in">abs</span>(chess[i]-y)))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> chess[], <span class="hljs-type">int</span> layer, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n)<br><span class="hljs-built_in">display</span>(chess,n);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;n;i++ )<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">canPlace</span>(chess, n, layer - <span class="hljs-number">1</span>, i))<br>&#123;<br>chess[layer - <span class="hljs-number">1</span>] = i;<br><span class="hljs-built_in">dfs</span>(chess, layer + <span class="hljs-number">1</span>, n);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">n</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input N:\n&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-comment">//一维数组作为棋盘，下标为行，元素值为列</span><br><span class="hljs-type">int</span>* chess = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br><span class="hljs-built_in">dfs</span>(chess,<span class="hljs-number">1</span>,n);<br>cout &lt;&lt; <span class="hljs-string">&quot;Engross:&quot;</span> &lt;&lt; total&lt;&lt;<span class="hljs-string">&quot; solutions&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Sum100"><a href="#Sum100" class="headerlink" title="Sum100"></a>Sum100</h3><blockquote><p>设计一个算法在1,2,3..9(顺序不能变)数字之间插入 + 或 - 或什么也不插，使得计算结果为100，并输出所有方案。</p><p>分析：输出时机：处理完9且所得结果为100。决策：+ - 空。回溯点：处理完9但结果不为100.<br>三选一的子集问题抽象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">9</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span> op[],<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> preAdd,<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> layer)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer == N)<br>&#123;<br><span class="hljs-keyword">if</span> (sum == <span class="hljs-number">100</span>)<br>&#123;<br>cout &lt;&lt; a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; N; j++) &#123;<br><span class="hljs-keyword">if</span> (op[j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>cout &lt;&lt; op[j];<br>cout &lt;&lt; a[j];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot; = 100\n&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>op[layer] = <span class="hljs-string">&#x27;+&#x27;</span>;<br>sum += a[layer];<br><span class="hljs-built_in">dfs</span>(op, sum, a[layer], a, layer + <span class="hljs-number">1</span>);<br>sum -= a[layer];<span class="hljs-comment">//恢复状态 回溯处理</span><br>op[layer] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>sum -= a[layer];<br><span class="hljs-built_in">dfs</span>(op, sum, -a[layer], a, layer + <span class="hljs-number">1</span>);<br>sum += a[layer];<span class="hljs-comment">//恢复状态 回溯处理</span><br>op[layer] = <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-comment">//重点：怎么使得：-5_6=》-56 而5_6=》56 </span><br><span class="hljs-comment">//因此需要获取前面的值 为正：pre*10+now 为负：pre*10-now 同时 还要考虑对sum的影响 毕竟替换了一组值</span><br><span class="hljs-comment">//可以通过先减去preAdd，处理后形成新的preAdd，再加给sum即可</span><br>sum -= preAdd;<br><span class="hljs-type">int</span> newAdd=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (preAdd &gt; <span class="hljs-number">0</span>)<br>&#123;<br>newAdd = preAdd * <span class="hljs-number">10</span> + a[layer];<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>newAdd = preAdd * <span class="hljs-number">10</span> - a[layer];<br>&#125;<br>sum += newAdd;<br><span class="hljs-built_in">dfs</span>(op, sum, newAdd, a, layer + <span class="hljs-number">1</span>);<br>sum -= newAdd;<span class="hljs-comment">//此时的恢复也需要引起重视</span><br>sum += preAdd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//要插入的运算符或者空操作可以用N-1长度数组存起来</span><br><span class="hljs-type">char</span> op[N];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>a[i] = i + <span class="hljs-number">1</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;result:\n&quot;</span>;<br><span class="hljs-comment">//从2开始处理，第一个要处理的操作符也是1和2之间的。</span><br><span class="hljs-built_in">dfs</span>(op, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">0</span>], a, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="子集和"><a href="#子集和" class="headerlink" title="子集和"></a>子集和</h3><blockquote><p>经典子集问题，比01背包还简单</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> aimSum = <span class="hljs-number">31</span>;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> n = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">24</span>,<span class="hljs-number">7</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">bool</span> choose[],<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> nowSum,<span class="hljs-type">int</span> leftSum)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; n) &#123;<br><span class="hljs-keyword">if</span> (nowSum == aimSum)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n&#123;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (choose[i] == <span class="hljs-literal">true</span>)<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;&#125;&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (nowSum+a[layer]&lt;=aimSum) &#123;<br>choose[layer] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs</span>(choose,layer+<span class="hljs-number">1</span>,nowSum+a[layer],leftSum-a[layer]);<br>&#125;<br><span class="hljs-comment">//也就是说，如果当前处理的元素不选的话，且以后就算全选也达不到要求，那么就必须选！对于不选的方案，剪掉！</span><br><span class="hljs-comment">//注意！！就算不选，leftSum也要减，不选就是错过了，错过了就错过了。。至少在当前世界回不来了，~回溯触发平行时空O(∩_∩)O哈哈~~</span><br><span class="hljs-keyword">if</span> (nowSum+leftSum&gt;=aimSum) &#123;<br>choose[layer] = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">dfs</span>(choose, layer + <span class="hljs-number">1</span>, nowSum, leftSum-a[layer]);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">bool</span> choose[n+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(choose, <span class="hljs-literal">false</span>, n);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n + <span class="hljs-number">1</span>; i++)<br>sum += a[i];<br>cout &lt;&lt; <span class="hljs-string">&quot;tactics:&quot;</span>;<br><span class="hljs-built_in">dfs</span>(choose, <span class="hljs-number">1</span>,<span class="hljs-number">0</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h3><blockquote><p>n个任务n个人，人和任务的分配只能是1对1的，每个人处理每个任务花费不同，求出最优分配方案。</p><p>分析：可抽象为子集型问题。用二维数组存储任务对应的处理人的开销，再设1个一维bool数组存储任务是否分配了，1个一维数组people，下标为人员编号，元素值为任务编号。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> cost[N + <span class="hljs-number">1</span>][N + <span class="hljs-number">1</span>] = &#123;<br>&#123;<span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>&#125;,<br>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>&#125;<br>&#125;;<br><br><span class="hljs-type">int</span> minCost = <span class="hljs-number">99999</span>;<br><span class="hljs-type">bool</span> work[N + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> peopleWithTask[N + <span class="hljs-number">1</span>];<br><br><span class="hljs-comment">//layer表示处理的人员编号</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> layer,<span class="hljs-type">int</span> nowCost,<span class="hljs-type">int</span> tactic[])</span> </span>&#123;<br><span class="hljs-keyword">if</span> (layer &gt; N) &#123;<br><span class="hljs-keyword">if</span> (nowCost &lt; minCost)<br>&#123;<br>minCost = nowCost;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; N + <span class="hljs-number">1</span>; ++i)<br>peopleWithTask[i] = tactic[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//依次考虑任务1-N</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i) &#123;<br><span class="hljs-keyword">if</span> (!work[i]) &#123;<br>work[i] = <span class="hljs-literal">true</span>;<br>tactic[layer] = i;<br><span class="hljs-built_in">dfs</span>(layer + <span class="hljs-number">1</span>,nowCost+cost[layer][i],tactic);<br>work[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//决策影响了work 和 tactic ，因此都要恢复。</span><br>tactic[layer] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//注意：如果这里把nowCost+=cost[][]后，才传入参数，则后面也需要恢复。</span><br><span class="hljs-comment">//这里直接把nowCost+cost[][]作为参数，则不用回复。</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//最优解初始化</span><br><span class="hljs-built_in">memset</span>(work, <span class="hljs-literal">false</span>, N + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">memset</span>(peopleWithTask, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span>);<br><span class="hljs-comment">//临时解声明和初始化</span><br><span class="hljs-type">int</span> nowCost = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> nowPeopleWithTask[N + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">memset</span>(nowPeopleWithTask, <span class="hljs-number">0</span>, N + <span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,nowCost,nowPeopleWithTask);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;allocation strategy：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>cout &lt;&lt; <span class="hljs-string">&quot;\ntask: &quot;</span> &lt;&lt; i &lt;&lt; <br><span class="hljs-string">&quot; allocated to peopel &quot;</span> &lt;&lt; peopleWithTask[i] &lt;&lt; <br><span class="hljs-string">&quot; costs for: &quot;</span> &lt;&lt; cost[i][peopleWithTask[i]];<br>cout &lt;&lt; <span class="hljs-string">&quot;\nEngross:&quot;</span> &lt;&lt; minCost;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="涂色"><a href="#涂色" class="headerlink" title="涂色"></a>涂色</h3><blockquote></blockquote><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><h3 id="活动安排"><a href="#活动安排" class="headerlink" title="活动安排"></a>活动安排</h3><blockquote><p>n个活动，每个活动有各自的开始时间和结束时间，活动串行，求最优安排方案——使得能安排最多数量的活动。即求出活动的排列。约束是排列合理（满足串行），优化是排列的数量尽可能多。感觉不如贪心…</p><p>分析：在主要决策体中，考虑活动layer—N，分别将layer与其后的活动交换位置，然后判断是否兼容，若兼容则选取更新兼容时间，进入下一层…当回溯到本层，换回位置，执行恢复。</p><p>慢到爆炸!对于活动安排问题还是去考虑贪心吧!!!</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Activity</span> &#123;<br><span class="hljs-type">int</span> begin;<br><span class="hljs-type">int</span> end;<br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">12</span>;<br>Activity activity[n + <span class="hljs-number">1</span>] = &#123; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">19</span>&#125;,&#123;<span class="hljs-number">15</span>,<span class="hljs-number">20</span>&#125;,&#123;<span class="hljs-number">10</span>,<span class="hljs-number">15</span>&#125;, &#123;<span class="hljs-number">8</span>,<span class="hljs-number">18</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">12</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">4</span>,<span class="hljs-number">14</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">9</span>&#125; &#125;;<br><span class="hljs-type">int</span> maxSum = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> bestSequence[n + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;;<br><br><span class="hljs-type">int</span> lastEnd = <span class="hljs-number">0</span>;<span class="hljs-comment">//上一个活动的结束时间</span><br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> sequence[n+<span class="hljs-number">1</span>]= &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//搜索活动问题最优解</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (i &gt; n)<span class="hljs-comment">//到达叶结点,产生一种调度方案</span><br>&#123;<br><span class="hljs-keyword">if</span> (sum &gt; maxSum)<br>&#123;<br>maxSum = sum;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)<br>bestSequence[k] = sequence[k];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++)<span class="hljs-comment">//没有到达叶结点,考虑i到n的活动</span><br>&#123;<span class="hljs-comment">//第i层结点选择活动x[j]</span><br><span class="hljs-type">int</span> sum1 = sum;<span class="hljs-comment">//保存sum，laste以便回溯</span><br><span class="hljs-type">int</span> laste1 = laste;<br><span class="hljs-keyword">if</span> (activity[sequence[j]].begin &gt;= laste)<span class="hljs-comment">//活动x[j]与前面兼容</span><br>&#123;<br>sum++;<span class="hljs-comment">//兼容活动个数增1</span><br>laste = activity[sequence[j]].end;<span class="hljs-comment">//修改本方案的最后兼容时间</span><br>&#125;<br><span class="hljs-built_in">swap</span>(sequence[i], sequence[j]);<span class="hljs-comment">//排序树问题递归框架:交换x[i],x[j]</span><br><span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<span class="hljs-comment">//排序树问题递归框架:进入下一层</span><br><span class="hljs-built_in">swap</span>(sequence[i], sequence[j]);<span class="hljs-comment">//排序树问题递归框架:交换x[i],x[j]</span><br>sum = sum1;<span class="hljs-comment">//回溯</span><br>laste = laste1;<span class="hljs-comment">//即撤销第i层结点对活动x[j]的选择,以便再选择其他活动</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> nowSequence[n + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>nowSequence[i] = i;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;result:&quot;</span>;<br><span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (activity[bestSequence[i]].begin &gt;= end) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n Activity: &quot;</span> &lt;&lt; bestSequence[i] &lt;&lt;<br><span class="hljs-string">&quot; executed began in &quot;</span> &lt;&lt; activity[bestSequence[i]].begin &lt;&lt;<br><span class="hljs-string">&quot; ended in &quot;</span> &lt;&lt; activity[bestSequence[i]].end;<br>end = activity[bestSequence[i]].end;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;\nEngross: &quot;</span>&lt;&lt;maxSum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流水线作业调度"><a href="#流水线作业调度" class="headerlink" title="流水线作业调度"></a>流水线作业调度</h3><blockquote><p>n个作业，都要先在机器M1再在M2上进行加工，不同任务在不同机器上加工时间有所不同，确定最佳加工顺序，使得从第一个任务在M1上开始到最后一个任务在M2上结束之间的时间间隔最短。</p><p>分析：可抽象为排列类的问题，求一种作业的排列，使得按这样的排列顺序得到的时间间隔最短。作业在M1上是连续的，只要上一个作业执行完毕后，下一个作业就可以去M1上执行了，但是M2的执行可能需要等待，当作业A在M1执行后，进入M2，作业B接着进入M1执行，可能会有作业B在M1上执行完了，作业A在M2上还在执行，因此M2上的时间不连续，存在<em><strong>等待时间</strong></em>.因此花在M2上的总时间需要利用数组，而M1不用。重点在于处理等待时间。若要等待，则当前作业i在m2上执行结束的时间time<sub>2</sub>[i]为：time<sub>2</sub>[i]&#x3D;time<sub>2</sub>[i-1]+m<sub>2</sub>[i]；若不需要等待,则为：time<sub>2</sub>[i]&#x3D;time<sub>1</sub>[i]+m<sub>2</sub>[i];而真正执行结束的时间应该取二者最大值。即：**time<sub>2</sub>[i]&#x3D;max{ time<sub>2</sub>[i-1]+m<sub>2</sub>[i] , time<sub>1</sub>[i]+m<sub>2</sub>[i] }**。稍微剪枝一下：若当前方案下的作业i的time2已经超过了之前记录的较优解，则可以直接剪掉了。进一步剪枝：记当前处理的作业为i，已知作业i的time<sub>2</sub>，则time<sub>2</sub>就是前i个作业全部执行完毕的时间，再记录他们在m2上花费的总时间iSum和所有作业在m2上的总时间allSum，则确定一个值：time<sub>2</sub>[i]+allSum-iSum.从i往后确定的每一种方案（叶节点）的最终完成时间一定大于等于该值。因此当确定出该值&gt;目前的bestTime就可以知道，接下来的所有叶子节点对应的值都不可能为打破当前的bestTime，因此可以直接剪掉。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f<span class="hljs-comment">//最大整数∞//最多的作业数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">4</span>;<span class="hljs-comment">//作业数</span><br><span class="hljs-comment">//int m1[n+1] = &#123; 0,5,12,4,8 &#125;;//M1上的执行时间,不用下标0的元素</span><br><span class="hljs-comment">//int m2[n+1] = &#123; 0,6,2,14,7 &#125;;//M2上的执行时间,不用下标0的元素</span><br><br><span class="hljs-comment">//验证升级后的剪枝函数重新设计用例，升级后的剪枝函数能够滤掉大于当前best的值</span><br><span class="hljs-comment">//但是不巧，上一组用例的依次求出的best正好都是递减的，42-36-34-33 因此不能过滤</span><br><span class="hljs-comment">//如果交换42 36 的位置就可以使得42被滤掉 因此根据方案挂了一下用例的顺序，发现成功了。</span><br><span class="hljs-type">int</span> m1[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span> &#125;;<br><span class="hljs-type">int</span> m2[n + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span> &#125;;<br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> bestTime;<span class="hljs-comment">//存放最优调度时间</span><br><span class="hljs-type">int</span> time1;<span class="hljs-comment">//M1的执行时间</span><br><span class="hljs-type">int</span> time2[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//M2的执行时间</span><br><span class="hljs-type">int</span> x[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//当前调度方案</span><br><span class="hljs-type">int</span> bestx[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//存放当前作业最佳调度</span><br><br><span class="hljs-type">int</span> allM2Sum = <span class="hljs-number">6</span> + <span class="hljs-number">2</span> + <span class="hljs-number">14</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span><span class="hljs-comment">//交换x和y</span><br>&#123;<br><span class="hljs-type">int</span> tmp = x;<br>x = y; y = tmp;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">disparr</span><span class="hljs-params">(<span class="hljs-type">int</span> x[])</span><span class="hljs-comment">//输出数组的元素</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, x[i]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bound</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-type">int</span> iM2Sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>iM2Sum += m2[x[j]];<br><span class="hljs-keyword">return</span> time2[i] + allM2Sum - iM2Sum;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><span class="hljs-comment">//从第i层开始搜索</span><br>&#123;<br><span class="hljs-keyword">if</span> (i &gt; n)<span class="hljs-comment">//到达叶结点,产生一种调度方案</span><br>&#123;<br><span class="hljs-keyword">if</span> (time2[n] &lt; bestTime)<span class="hljs-comment">//找到更优解</span><br>&#123;<br>bestTime = time2[n];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   一个解: bestf=%d&quot;</span>, bestTime);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 调度方案: &quot;</span>); disparr(x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, time2: &quot;</span>); disparr(time2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-comment">//复制解向量</span><br>bestx[j] = x[j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++)<span class="hljs-comment">//没有到达叶结点,考虑i到n的作业</span><br>&#123;<br>time1 += m1[x[j]];<span class="hljs-comment">//在第i层选择执行作业x[j],在M1上执行完的时间</span><br>time2[i] = max(time1, time2[i - <span class="hljs-number">1</span>]) + m2[x[j]];<br><span class="hljs-comment">//if (time2[i] &lt; bestTime)//初步剪枝:仅仅扩展当前总时间小于bestf的结点</span><br>swap(x[i], x[j]);<br><span class="hljs-keyword">if</span>(bound(i)&lt;=bestTime)<span class="hljs-comment">//下界函数剪枝</span><br>&#123;<br><br>dfs(i + <span class="hljs-number">1</span>);<br><br>&#125;<span class="hljs-comment">//关于下界函数剪枝：他需要实时的x数组方案。因此当使用这种方式剪枝时，swap应该放在if外面。</span><br>swap(x[i], x[j]);<br>time1 -= m1[x[j]];<span class="hljs-comment">//回溯，即撤销第i层对作业x[j]的选择,以便再选择其他作业</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>time1 = <span class="hljs-number">0</span>;<br>bestTime = INF;<br><span class="hljs-built_in">memset</span>(time2, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(time2));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)  <span class="hljs-comment">//设置初始调度为作业1,2,…,n的顺序</span><br>x[k] = k;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解过程:\n&quot;</span>);<br>dfs(<span class="hljs-number">1</span>);<span class="hljs-comment">//从作业1开始搜索</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    最少时间: %d&quot;</span>, bestTime);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 最优调度方案: &quot;</span>);<br>disparr(bestx); <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="见解"><a href="#见解" class="headerlink" title="见解"></a>见解</h2><p>在设计dfs时关于回溯恢复的考虑：如果将数据作为函数参数，则可以自动恢复，若不作为参数，而是全局变量，则要手动恢复。</p><h2 id="非递归回溯"><a href="#非递归回溯" class="headerlink" title="非递归回溯"></a>非递归回溯</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>回溯</tag>
      
      <tag>backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典算法问题</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/ClassicProblem/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/ClassicProblem/</url>
    
    <content type="html"><![CDATA[<h1 id="经典算法问题"><a href="#经典算法问题" class="headerlink" title="经典算法问题"></a>经典算法问题</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p>01背包问题：有数件物品，每样物品均有不同的价值和重量，先给定一个背包容量大小，求背包能装下的最大价值。</p><p>分数背包问题：在01背包问题的基础上，每样物品可以只拿一部分。</p><p>完全背包问题：在01背包问题的基础上，每样物品有无限个（即可重复装包），求背包能装下的最大价值。</p><p>分组背包问题：在01背包问题的基础上，把数样物品改为数组物品，每组物品中只能选择一件，求背包能装下的最大价值。</p><p>dp或贪心算法来解决，贪心算法有时不一定能求出最优解，分数背包问题用贪心算法一定能高效求出最优解，其他背包问题用dp最稳妥。</p></blockquote><h2 id="字符串序列问题"><a href="#字符串序列问题" class="headerlink" title="字符串序列问题"></a>字符串序列问题</h2><blockquote><p>与字符串序列有关的问题：</p><p>最大连续子串和：</p><p>最长公共子序列：</p><p>序列编辑问题：</p><p>最长递增子序列：</p><p>整数拆分问题：</p><p>序列问题用dp解决最好，定义好合适的dp数组，列出转移方程就如喝水般容易了，最重要的还是dp数组的设计。</p></blockquote><h2 id="流水线作业调度问题"><a href="#流水线作业调度问题" class="headerlink" title="流水线作业调度问题"></a>流水线作业调度问题</h2><blockquote><p>有一批作业，都需要分别在A机器上处理，然后再到B机器上处理，如作业处理顺序安排不当，则容易出现作业总是要等待上一个作业在B机器上处理完毕的情况，因此合理的调度很重要。请求出最佳调度方案，使得处理完所有作业花费时间最短。</p><p>通过贪心johnson算法，分支限界算法，回溯法来完成。</p></blockquote><h2 id="任务分配问题"><a href="#任务分配问题" class="headerlink" title="任务分配问题"></a>任务分配问题</h2><blockquote><p>有一组任务，一组人员，不同人员处理不同的任务有不同费用，请合理安排任务分配方案，使得总花费最少。</p><p>通过蛮力法，回溯法，分支限界法来解决。</p></blockquote><h2 id="多机调度问题"><a href="#多机调度问题" class="headerlink" title="多机调度问题"></a>多机调度问题</h2><blockquote><p>有一组机器，一组作业，每个作业都有对应的执行时长，如何调度作业才能使得最短时间内完成所有作业。</p><p>贪心法完成</p></blockquote><h2 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h2><blockquote><p>求一组数据的Huffman编码</p><p>贪心法完成</p></blockquote><h2 id="资源分配问题"><a href="#资源分配问题" class="headerlink" title="资源分配问题"></a>资源分配问题</h2><blockquote><p>有一组资源，将不同的资源分配给不同的使用者有不同的收益，求最大收益，和任务分配问题反过来有点像，但资源分配问题本身就是个抽象概括，根据问题的不同，资源的数量和种类都可以是多个或单个。</p><p>采用dp最好</p></blockquote><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><blockquote><p>有一组活动，每个活动都有起始时间，如何安排活动，才能在一天内完成最多的活动？</p><p>回溯和贪心法来解决，贪心法真的高效！</p></blockquote><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><blockquote><p>这里进一步讨论N皇后问题 并加以优化</p><p>回溯法或Las Vegas算法<s>当乐子看看，不过思想还是挺巧妙的</s></p></blockquote><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><blockquote><p>递归的话简直秒杀，这里讨论一下非递归的情况。</p></blockquote><h2 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h2><blockquote><p>分治秒了，但是因为这问题之前恶心过我，有必要报仇雪恨，在这里再码一遍他！</p></blockquote><h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><blockquote><p>排序问题及其衍生问题：以快排的第K大&#x2F;小数为主。</p><p>深度分析快排和归并排序在边界上的处理细节。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>算法基础</tag>
      
      <tag>经典算法问题</tag>
      
      <tag>背包</tag>
      
      <tag>序列</tag>
      
      <tag>字符串</tag>
      
      <tag>流水线作业调度</tag>
      
      <tag>任务分配</tag>
      
      <tag>多机调度</tag>
      
      <tag>Huffman编码</tag>
      
      <tag>资源分配</tag>
      
      <tag>活动安排</tag>
      
      <tag>n皇后</tag>
      
      <tag>汉诺塔</tag>
      
      <tag>棋盘覆盖问题</tag>
      
      <tag>排序问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Divide&amp;Conquer</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Divide&amp;Conquer/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Divide&amp;Conquer/</url>
    
    <content type="html"><![CDATA[<h1 id="Divide-Conquer"><a href="#Divide-Conquer" class="headerlink" title="Divide&amp;Conquer"></a>Divide&amp;Conquer</h1><blockquote><p>思想只能作为指导 实践中的细节才是魔鬼藏身之处——二分边界问题 </p></blockquote><span id="more"></span><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>变式：第K 大&#x2F;小 数</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>两种写法:</p><ol><li><p>自顶向下：简洁 可读性好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> NUM[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (i &lt; n)<br>cout &lt;&lt; a[i++] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-type">int</span>* b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[r - l + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> b_index = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> left = l; <span class="hljs-type">int</span> right = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//判断并复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid <span class="hljs-keyword">and</span> right &lt;= r) &#123;<br><span class="hljs-keyword">if</span> (a[left] &lt; a[right]) b[b_index++] = a[left++];<br><span class="hljs-keyword">else</span>  b[b_index++] = a[right++];<br>&#125;<br><span class="hljs-comment">//多余元素全部复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid)b[b_index++] = a[left++];<br><span class="hljs-keyword">while</span> (right &lt;= r)b[b_index++] = a[right++];<br><span class="hljs-comment">//复制临时数组序列给原数组</span><br><span class="hljs-type">int</span> start = l;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b_index_this = <span class="hljs-number">0</span>; start &lt;= r; start++)<br>a[start] = b[b_index_this++];<br><span class="hljs-keyword">delete</span>[] b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &lt; r) &#123;<br><span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-built_in">MergeSort</span>(a,l,mid);<br><span class="hljs-built_in">MergeSort</span>(a,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">Merge</span>(a,l,mid,r);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">MergeSort</span>(NUM, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-built_in">display</span>(NUM,<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自底向上：高效 但要考虑的细节多 较繁琐</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> NUM[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> times = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> j)</span> </span>&#123;<br><span class="hljs-type">int</span>* b = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[j - i + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> b_index = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> left = i; <span class="hljs-type">int</span> right = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//判断并复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid <span class="hljs-keyword">and</span> right &lt;= j) &#123;<br><span class="hljs-keyword">if</span> (a[left] &lt; a[right]) b[b_index++] = a[left++];<br><span class="hljs-keyword">else</span>  b[b_index++] = a[right++];<br>&#125;<br><span class="hljs-comment">//多余元素全部复制</span><br><span class="hljs-keyword">while</span> (left &lt;= mid)<br>b[b_index++] = a[left++];<br><span class="hljs-keyword">while</span> (right &lt;= j)<br>b[b_index++] = a[right++];<br><span class="hljs-comment">//复制临时数组序列给原数组</span><br><span class="hljs-type">int</span> start = i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b_index_this = <span class="hljs-number">0</span>; start &lt;= j; start++)<br>a[start] = b[b_index_this++];<br><span class="hljs-keyword">delete</span>[] b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergePass</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">index</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//合并相邻表，若能够合并，当前表下标，加上连续两个表长后的下标小于末尾下标，则合并。</span><br><span class="hljs-keyword">for</span> (; index + <span class="hljs-number">2</span> * len - <span class="hljs-number">1</span> &lt; n; index += <span class="hljs-number">2</span> * len)<br><span class="hljs-built_in">merge</span>(a, index, index + len - <span class="hljs-number">1</span>, index + <span class="hljs-number">2</span> * len - <span class="hljs-number">1</span>);<br><span class="hljs-comment">//考虑最后一个轮空的表，其长度会较小，因此当满足index+2*len-1&gt;n and index + len -1&lt;n 则说明有小表，小表的末尾就是n-1.</span><br><span class="hljs-keyword">if</span> (index + len - <span class="hljs-number">1</span> &lt; n)<br><span class="hljs-built_in">merge</span>(a, index, index + len - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-comment">//循环的增长与归并算法的趟数有关</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt; n; len *= <span class="hljs-number">2</span>)<br><span class="hljs-built_in">mergePass</span>(a, len, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">while</span> (i &lt; n)<br>cout &lt;&lt; a[i++] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">mergeSort</span>(NUM,<span class="hljs-number">10</span>);<br><span class="hljs-built_in">display</span>(NUM, <span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="第K小"><a href="#第K小" class="headerlink" title="第K小"></a>第K小</h3><p>用快排的思想写是最好的。</p><p>画数轴确定递归的判断条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> q[l];<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (j - l + <span class="hljs-number">1</span> &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(q, l, j, k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r, k - (j - l + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="等长有序序列中位数"><a href="#等长有序序列中位数" class="headerlink" title="等长有序序列中位数"></a>等长有序序列中位数</h3><blockquote><p>两个等长序列A B，求他们的中位数。（递增序列）</p></blockquote><p>分析：</p><ol><li>若A B只有一个元素， 取较小者； </li><li>若A B有多个元素，则分别求出A B的中位数，若二者中位数相同，那就是最终答案，若不同：<ol><li>若A的中位数&gt;B的中位数：限制AB序列，取A前半段，B后半段，然后递归；</li><li>若A的中位数&lt;B的中位数：限制AB序列，取A后半段，B前半段，然后递归；</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">prepart</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;s,<span class="hljs-type">int</span> &amp;t)</span><span class="hljs-comment">//求a[s..t]序列的前半子序列</span><br>&#123;<span class="hljs-type">int</span> m=(s+t)/<span class="hljs-number">2</span>;<br>t=m;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">postpart</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;s,<span class="hljs-type">int</span> &amp;t)</span><span class="hljs-comment">//求a[s..t]序列的后半子序列</span><br>&#123;<span class="hljs-type">int</span> m=(s+t)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> ((s+t)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<span class="hljs-comment">//序列中有奇数个元素</span><br>s=m;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//序列中有偶数个元素</span><br>s=m+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=s;i&lt;=t;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">midnum</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> s1,<span class="hljs-type">int</span> t1,<span class="hljs-type">int</span> b[],<span class="hljs-type">int</span> s2,<span class="hljs-type">int</span> t2)</span><br>&#123;<span class="hljs-comment">//求两个有序序列a[s1..t1]和b[s2..t2]的中位数</span><br><span class="hljs-type">int</span> m1,m2;<br><span class="hljs-keyword">if</span> (s1==t1 &amp;&amp; s2==t2)<span class="hljs-comment">//两序列只有一个元素时返回较小者</span><br><span class="hljs-keyword">return</span> a[s1]&lt;b[s2]?a[s1]:b[s2];<br><span class="hljs-keyword">else</span><br>&#123;m1=(s1+t1)/<span class="hljs-number">2</span>;<span class="hljs-comment">//求a的中位数</span><br>m2=(s2+t2)/<span class="hljs-number">2</span>;<span class="hljs-comment">//求b的中位数</span><br><span class="hljs-keyword">if</span> (a[m1]==b[m2])<span class="hljs-comment">//两中位数相等时返回该中位数</span><br><span class="hljs-keyword">return</span> a[m1];<br><span class="hljs-keyword">if</span> (a[m1]&lt;b[m2])<span class="hljs-comment">//当a[m1]&lt;b[m2]时</span><br>&#123;postpart(s1,t1);<span class="hljs-comment">//a取后半部分</span><br>prepart(s2,t2);<span class="hljs-comment">//b取前半部分</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:&quot;</span>); display(a,s1,t1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b:&quot;</span>); display(b,s2,t2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> midnum(a,s1,t1,b,s2,t2);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//当a[m1]&gt;b[m2]时</span><br>&#123;prepart(s1,t1);<span class="hljs-comment">//a取前半部分</span><br>postpart(s2,t2);<span class="hljs-comment">//b取后半部分</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a:&quot;</span>); display(a,s1,t1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b:&quot;</span>); display(b,s2,t2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> midnum(a,s1,t1,b,s2,t2);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span> b[]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">//int a[]=&#123;1,3,4,6,9&#125;;</span><br><span class="hljs-comment">//int b[]=&#123;2,3,5,8,10&#125;;</span><br><span class="hljs-type">int</span> n=<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;中位数:%d\n&quot;</span>,midnum(a,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,b,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h4><p>区间是 [L,MID-1]  则mid&#x3D;l+r+1&gt;&gt;1 满足条件 L&#x3D;mid 因为右侧是[mid,R]</p><p>区间是[L,MID] 则mid&#x3D;l+r&gt;&gt;1 满足条件 R&#x3D;mid 因为左侧是[L,mid]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><h3 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h3><blockquote><p>2<sup>n</sup>规模的棋盘中，有一个特殊块，用L型骨牌填满棋盘，围住特殊块。</p></blockquote><p>分析：为什么用分治法可以完成？因为当棋盘很小时，可以很简单的求出来，那么问题就在于划分棋盘，每次都将棋盘划分为四个小棋盘，说着很简单，但其实最重要的不在于单纯的划分，因为按照一开始所说，棋盘很小时问题很容易解决(一个特殊块的2*2棋盘 只需要一个L型骨牌即可)，这其实意味着棋盘即使很小，但也要<strong>存在</strong>那个特殊块，但目前只有一个特殊块，而棋盘却又很大，因此不仅需要划分，还要在每次划分时选定一个特殊块，而对于本问题，L型骨牌其实就是我们手动构造出来的特殊块了，因为每次划分为4份小棋盘，而其中一份必然是特殊块所在的，其余三个棋盘就没有特殊块了，因此需要为他们添加特殊块，问题来了，构造的特殊块应该放在哪里呢？实际上，放在三个棋盘的交接处即可，这样也就构造了L型骨牌，依次类推..最终一定能填满。</p><p>最复杂的就是分析交接处，要判断不同的象限，将特殊块放在不同的位置：右下，左下，右上，左上。但其实在构造的过程中很容易发现规律，发现规律后就可以直接套了，规律见注释<code>确定是否+1</code>处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">1024</span>;<br><span class="hljs-type">int</span> Board[MAX][MAX];<br><span class="hljs-type">int</span> num= <span class="hljs-number">1</span>;<br><span class="hljs-comment">//棋盘问题总结，根据所在区域不同，确定不同操作。</span><br><span class="hljs-comment">//较复杂的是定位，但是在分析过程中，发现很多定位信息是共通的。</span><br><span class="hljs-comment">//脑海中要有草图，特别是三个临界点， 因此其实每种情况都可以根据草图由其他情况的坐标确定是否+1来决定</span><br><span class="hljs-comment">//关于坐标，不要想着x轴y轴，去想行和列，同一行，则行坐标不变，同一列，则列坐标不变！</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ChessBoard</span><span class="hljs-params">(<span class="hljs-type">int</span> speRow, <span class="hljs-type">int</span> speCol, <span class="hljs-type">int</span> relaRow, <span class="hljs-type">int</span> relaCol, <span class="hljs-type">int</span> size)</span> </span>&#123;<br><span class="hljs-type">int</span> t=num++;<br><span class="hljs-type">int</span> smallSize = size / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//if在左上区域</span><br><span class="hljs-keyword">if</span> (speCol &lt; relaCol + smallSize <span class="hljs-keyword">and</span> speRow &lt; relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow, relaCol, smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在左上区域的右下角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow+smallSize<span class="hljs-number">-1</span>][relaCol+smallSize<span class="hljs-number">-1</span>] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize - <span class="hljs-number">1</span>, relaCol + smallSize - <span class="hljs-number">1</span>,relaRow,relaCol,smallSize);<br>&#125;<br><span class="hljs-comment">//if在右上区域</span><br><span class="hljs-keyword">if</span> (speCol &gt;= relaCol + smallSize <span class="hljs-keyword">and</span> speRow &lt; relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow, relaCol + smallSize,smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在右上区域的左下角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow + smallSize - <span class="hljs-number">1</span>][relaCol + smallSize] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize - <span class="hljs-number">1</span>, relaCol + smallSize, relaRow, relaCol + smallSize, smallSize);<br>&#125;<br><span class="hljs-comment">//if在左下区域</span><br><span class="hljs-keyword">if</span> (speCol &lt; relaCol + smallSize <span class="hljs-keyword">and</span> speRow &gt;= relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow + smallSize, relaCol, smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在左下区域的右上角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow + smallSize ][relaCol + smallSize - <span class="hljs-number">1</span>] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize, relaCol + smallSize - <span class="hljs-number">1</span>, relaRow + smallSize, relaCol, smallSize);<br>&#125;<br><span class="hljs-comment">//if在右下区域</span><br><span class="hljs-keyword">if</span> (speCol &gt;= relaCol + smallSize <span class="hljs-keyword">and</span> speRow &gt;= relaRow + smallSize) &#123;<br><span class="hljs-built_in">ChessBoard</span>(speRow, speCol, relaRow + smallSize, relaCol + smallSize, smallSize);<br>&#125;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//在右下区域的左上角添加假的特殊骨牌，并且对这个骨牌求解</span><br>&#123;<br>Board[relaRow + smallSize][relaCol + smallSize ] = t;<br><span class="hljs-built_in">ChessBoard</span>(relaRow + smallSize, relaCol + smallSize, relaRow + smallSize, relaCol + smallSize, smallSize);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;input size(),x,y:&quot;</span>;<br>cin &gt;&gt; size &gt;&gt; x &gt;&gt; y;<br>size = <span class="hljs-number">1</span> &lt;&lt; size;<br><span class="hljs-built_in">ChessBoard</span>(x, y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, size);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; size; j++)<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>) &lt;&lt; Board[i][j];<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环日程"><a href="#循环日程" class="headerlink" title="循环日程"></a>循环日程</h3><blockquote><p>n&#x3D;2<sup>k</sup>个选手，在n-1天内彼此都比赛一次，求日程表。</p><p>设表格行代表第i个 选手 行的下标从1开始，列代表天数 下标从0开始 那么日程二维表的第一列（下标为0）用来显示行号，以此来表示选手的编号，从第二列（下标为1）开始，元素值表示选手的对手，下标代表比赛的天数。</p><p>比如S[0][0] 代表第一个选手第0天 第0天没有意义 此时为第一列 不如填入选手的编号1</p><p>S[1][1]代表第二个选手第1天要对阵的人 S[4][6]代表第五个选手 第六天要对阵的人</p><p>为什么说此问题可以用递归解决呢，首先问题规模很小时，当然可以解决，于是第一个性质就满足了，那如何由小问题推出大问题呢？实际上本题的选手数为2的幂，因此选手规模只能成2倍的增长，而对于两倍的增长，这个二维表数据是可以复用的。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 101</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> k;<br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> a[MAX][MAX];<span class="hljs-comment">//存放比赛日程表（行列下标为0的元素不用）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Plan</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,j,n,t,temp;<br>n=<span class="hljs-number">2</span>;<span class="hljs-comment">//n从2^1=2开始</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>; a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;   <span class="hljs-comment">//求解2个选手比赛日程,得到左上角元素</span><br>a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>; a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (t=<span class="hljs-number">1</span>;t&lt;k;t++)<span class="hljs-comment">//迭代处理,依次处理2^2(t=1)…,2^k(t=k-1)个选手</span><br>&#123;<br>temp=n;<span class="hljs-comment">//temp=2^t</span><br>n=n*<span class="hljs-number">2</span>; <span class="hljs-comment">//n=2^(t+1)</span><br><span class="hljs-keyword">for</span> (i=temp+<span class="hljs-number">1</span>;i&lt;=n;i++ )<span class="hljs-comment">//填左下角元素</span><br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j&lt;=temp; j++)<br>a[i][j]=a[i-temp][j]+temp; <span class="hljs-comment">//左下角元素和左上角元素的对应关系</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=temp; i++)<span class="hljs-comment">//填右上角元素</span><br><span class="hljs-keyword">for</span> (j=temp+<span class="hljs-number">1</span>; j&lt;=n; j++)<br>a[i][j]=a[i+temp][(j+temp)% n];<br><span class="hljs-keyword">for</span> (i=temp+<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-comment">//填右下角元素</span><br><span class="hljs-keyword">for</span> (j=temp+<span class="hljs-number">1</span>; j&lt;=n; j++)<br>a[i][j]=a[i-temp][j-temp];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>k=<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;k;<span class="hljs-comment">//n等于2的k次方即n=2^k</span><br><span class="hljs-built_in">Plan</span>(k);<span class="hljs-comment">//产生n个选手的比赛日程表</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<span class="hljs-comment">//输出比赛日程表</span><br>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4d&quot;</span>,a[i][j]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h3><blockquote><p>用dp最好 但还是介绍一下DC吧</p></blockquote><p>分析：对于一个序列，将它分为左右两边，那么那段最大连续子序列要么在纯左侧，要么在纯右侧，要么就横跨左右两侧，对于横跨左右两侧的情况，只需要从中点开始，往左右两侧蔓延判断即可。这是宏观上的划分。具体而言，真正能一口气确定要不要选择某个元素是在只有一个元素时，元素&gt;0就选择，否则就不选，当序列稍微有点长，就要开始斟酌了，但这是计算机需要考虑的，因为每一次递归，都要在divided的序列中求这三种情况，疯狂套娃，直到能轻而易举地conquer，最终再合并，就能conquer最终的大问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br><span class="hljs-keyword">return</span> c &gt; (a &gt; b ? a : b) ? c : (a &gt; b ? a : b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MaxSubSeq</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leftSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">rightSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">midSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">maxMid_leftSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">maxMid_rightSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">if</span> (low == high)<br>&#123;<br><span class="hljs-keyword">if</span> (a[low] &gt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> a[low];<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> mid = ( low + high )/ <span class="hljs-number">2</span>;<br>leftSum = <span class="hljs-built_in">MaxSubSeq</span>(a, low, mid );<br>rightSum = <span class="hljs-built_in">MaxSubSeq</span>(a, mid + <span class="hljs-number">1</span>, high);<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mid_leftSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span>, <span class="hljs-title">mid_rightSum</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-comment">//i=mid 往左侧蔓延</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &gt;= low; i--)<br>&#123;<br>mid_leftSum += a[i];<br><span class="hljs-keyword">if</span> (mid_leftSum &gt; maxMid_leftSum)<br>maxMid_leftSum = mid_leftSum;<br>&#125;<br><span class="hljs-comment">//i=mid+1 往右侧蔓延</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid+<span class="hljs-number">1</span>; i &lt;= high; i++) &#123;<br>mid_rightSum += a[i];<br><span class="hljs-keyword">if</span> (mid_rightSum &gt; maxMid_rightSum)<br>maxMid_rightSum = mid_rightSum;<br>&#125;<br>midSum = maxMid_leftSum + maxMid_rightSum;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max3</span>(leftSum, rightSum, midSum);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a[] = &#123; <span class="hljs-number">-2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">13</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">-2</span> &#125;,n=<span class="hljs-number">6</span>;<br>cout &lt;&lt; <span class="hljs-built_in">MaxSubSeq</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h2><blockquote><p>求两个二进制的数的乘积（这两个二进制数很长很大）</p><p>分析：将两个二进制数分为两段。记这两个二进制数分别为A,B则要求A*B 可以把A的高n&#x2F;2位取出，记为a1，低n&#x2F;2位取出，记为a2，因此A&#x3D;a1*2<sup>n&#x2F;2</sup>+a2,同理B&#x3D;b1*2<sup>n&#x2F;2</sup>+b2,因此A*B&#x3D;(a1*2<sup>n&#x2F;2</sup>+a2)*(b1*2<sup>n&#x2F;2</sup>+b2)&#x3D;a1*b1*2<sup>n</sup>+(a1*b2+a2*b1)*2<sup>n&#x2F;2</sup>+a2*b2。</p><p>思路：</p><ol><li>初始化A B的字符串 并将字符串转为整数数组。</li><li>递归将两个数组分别拆为前后两段，代表高位和低位。出口：数组长度为1，此时可以计算出结果并返回给上一层。回归处理：将得到的四个结果转为10进制并做分析中的计算A*B&#x3D;(a1*2<sup>n&#x2F;2</sup>+a2)*(b1*2<sup>n&#x2F;2</sup>+b2)&#x3D;a1*b1*2<sup>n</sup>+(a1*b2+a2*b1)*2<sup>n&#x2F;2</sup>+a2*b2；再将该结果转换为2进制。层层返回，最终得到一个二进制的结果。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求解大整数乘法的算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 2000<span class="hljs-comment">//最多的位数</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Left</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> B[],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//取A的左边（高位）n/2位</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<br>B[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i=n/<span class="hljs-number">2</span>;i&lt;=n;i++)<br>B[i-n/<span class="hljs-number">2</span>]=A[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Right</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> B[],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//取A的右边（低位）n/2位</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<br>B[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;i++)<br>B[i]=A[i];<br>B[i]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">Trans2to10</span><span class="hljs-params">(<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//二进制数转换成十进制数</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> s=A[<span class="hljs-number">0</span>],x=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>;i&lt;MAXN;i++)<br>&#123;x=<span class="hljs-number">2</span>*x;<br>s+=A[i]*x;<br>&#125;<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Trans10to2</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//将十进数转换成二进制数</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (x&gt;<span class="hljs-number">0</span>)<br>&#123;A[j]=x%<span class="hljs-number">2</span>;j++;<br>x=x/<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (i=j;i&lt;MAXN;i++)<br>A[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp</span><span class="hljs-params">(<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//从高位到低位输出二进制数A</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=MAXN<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,A[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MULT</span><span class="hljs-params">(<span class="hljs-type">int</span> X[],<span class="hljs-type">int</span> Y[],<span class="hljs-type">int</span> Z[],<span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//求Z=X*Y</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-type">long</span> e,e1,e2,e3,e4;<br><span class="hljs-type">int</span> A[MAXN],B[MAXN],C[MAXN],D[MAXN];<br><span class="hljs-type">int</span> m1[MAXN],m2[MAXN],m3[MAXN],m4[MAXN];<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;MAXN;i++)<span class="hljs-comment">//Z初始化为0</span><br>Z[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (n==<span class="hljs-number">1</span>)<span class="hljs-comment">//递归出口</span><br>&#123;<span class="hljs-keyword">if</span> (X[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span> &amp;&amp; Y[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)Z[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> Z[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<span class="hljs-built_in">Left</span>(X,A,n);<span class="hljs-comment">//A取X的左边n/2位</span><br><span class="hljs-built_in">Right</span>(X,B,n);<span class="hljs-comment">//B取X的右边n/2位;</span><br><span class="hljs-built_in">Left</span>(Y,C,n);<span class="hljs-comment">//C取Y的左边n/2位;</span><br><span class="hljs-built_in">Right</span>(Y,D,n);<span class="hljs-comment">//D取Y的右边n/2位;</span><br><span class="hljs-built_in">MULT</span>(A,C,m1,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m1=AC</span><br><span class="hljs-built_in">MULT</span>(A,D,m2,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m2=AD</span><br><span class="hljs-built_in">MULT</span>(B,C,m3,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m3=BC</span><br><span class="hljs-built_in">MULT</span>(B,D,m4,n/<span class="hljs-number">2</span>);<span class="hljs-comment">//m4=DB</span><br>e1=<span class="hljs-built_in">Trans2to10</span>(m1);<span class="hljs-comment">//将m1转换成十进制数e1</span><br>e2=<span class="hljs-built_in">Trans2to10</span>(m2);<span class="hljs-comment">//将m2转换成十进制数e2</span><br>e3=<span class="hljs-built_in">Trans2to10</span>(m3);<span class="hljs-comment">//将m3转换成十进制数e3</span><br>e4=<span class="hljs-built_in">Trans2to10</span>(m4);<span class="hljs-comment">//将m4转换成十进制数e4</span><br>e=e1*(<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n)+(e2+e3)*(<span class="hljs-type">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,n/<span class="hljs-number">2</span>)+e4;<br><span class="hljs-built_in">Trans10to2</span>(e,Z);<span class="hljs-comment">//将e转换成二进制数Z</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-type">char</span> a[],<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> A[])</span><span class="hljs-comment">//将字符串a转换为整数数组A</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>A[i]=<span class="hljs-built_in">int</span>(a[n<span class="hljs-number">-1</span>-i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><span class="hljs-keyword">for</span> (i=n;i&lt;MAXN;i++)<br>A[i]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-type">long</span> e;<br><span class="hljs-type">char</span> a[]=<span class="hljs-string">&quot;10101100&quot;</span>;<span class="hljs-comment">//两个参与运算的二进制数</span><br><span class="hljs-type">char</span> b[]=<span class="hljs-string">&quot;10010011&quot;</span>;<br><span class="hljs-type">int</span> X[MAXN],Y[MAXN],Z[MAXN];<br><span class="hljs-type">int</span> n=<span class="hljs-number">8</span>;<br><span class="hljs-built_in">trans</span>(a,n,X);<span class="hljs-comment">//将a转换成整数数组X</span><br><span class="hljs-built_in">trans</span>(b,n,Y);<span class="hljs-comment">//将b转换成整数数组Y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;X:&quot;</span>); <span class="hljs-built_in">disp</span>(X);<span class="hljs-comment">//输出X</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Y:&quot;</span>); <span class="hljs-built_in">disp</span>(Y);<span class="hljs-comment">//输出Y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Z=X*Y\n&quot;</span>);<br><span class="hljs-built_in">MULT</span>(X,Y,Z,n);<span class="hljs-comment">//求Z=X*Y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Z:&quot;</span>); <span class="hljs-built_in">disp</span>(Z);<span class="hljs-comment">//输出Z</span><br>e=<span class="hljs-built_in">Trans2to10</span>(Z);<span class="hljs-comment">//将Z转换成十进制数e</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Z对应的十进制数:%ld\n&quot;</span>,e);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;验证正确性:\n&quot;</span>);<br><span class="hljs-type">long</span> x,y,z;<br>x=<span class="hljs-built_in">Trans2to10</span>(X);<span class="hljs-comment">//将X转换成十进制数x</span><br>y=<span class="hljs-built_in">Trans2to10</span>(Y);<span class="hljs-comment">//将X转换成十进制数y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;X对应的十进制数x:%ld\n&quot;</span>,x);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Y对应的十进制数y:%ld\n&quot;</span>,y);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z=x*y\n&quot;</span>);<br>z=x*y;<span class="hljs-comment">//求z=x*y</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果z:%d\n&quot;</span>,z);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>思路：</p><blockquote><p>宏观划分（在这里不需要思考太多具体实现）</p><p>递归出口（问题在什么地步可以轻而易举地解决）</p><p>问题合并（大问题是怎样由小问题得到的）</p></blockquote><p>这三大步分别从大问题 小问题 和大问题与小问题之间的联系 着手考虑，好美的思想，有点哲学惹…</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>分治</tag>
      
      <tag>DC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Greedy Algorithm</title>
    <link href="/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Greed/"/>
    <url>/zyq.github.io/2025/03/04/%E7%AE%97%E6%B3%95/Greed/</url>
    
    <content type="html"><![CDATA[<h1 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h1><blockquote><p>怎么贪才不会翻车？也是一种艺术。</p></blockquote><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>并非所有问题用贪心都能找到最优解。需要满足两个性质：1.<strong>贪心选择性质</strong>：问题的整体最优解可以通过一系列局部最优的选择来达到，由数学归纳法证明。2.<strong>最优子结构性质</strong>：问题的最优解包含其子问题的最优解，由反证法证明。</p><p>解题要点：正确找出贪心的原则。一般是最值优先，因此经常需要排序或者使用优先级队列。</p><h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><blockquote><p>无脑列出四个最值：1.最早开始时间优先；2.最晚开始时间优先；3.最早结束时间优先；4.最晚结束时间优先。第2和第4显然不对。考虑方案1和方案3。对于模棱两可的决策，直接考虑对应的极端情况。若有2个活动A：A1[0,24] A2[1,2];若用方案1则最终只能安排一个活动，若用方案2则能完成两个活动。因此这里的贪心原则为：最早结束时间优先。定义一个活动结构体，根据end属性排序即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">11</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Action</span><br>&#123;<br><span class="hljs-type">int</span> beginTime;<br><span class="hljs-type">int</span> endTime;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> Action&amp; a) &#123;<br><span class="hljs-keyword">return</span> endTime &lt;= a.endTime;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(Action a[],<span class="hljs-type">bool</span> s[])</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + NUM);<span class="hljs-comment">//1.按贪心原则排序</span><br><span class="hljs-type">int</span> preEndTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; NUM; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[i].beginTime &gt;= preEndTime)<br>&#123;<br>s[i] = <span class="hljs-literal">true</span>;<br>preEndTime = a[i].endTime;<span class="hljs-comment">//2.其他设计</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Action a[],<span class="hljs-type">bool</span> s[])</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; NUM; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (s[i])<br>cout &lt;&lt; <span class="hljs-string">&quot;Action[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]选取，开始时间:&quot;</span> &lt;&lt; a[i].beginTime &lt;&lt; <span class="hljs-string">&quot;结束时间：&quot;</span> &lt;&lt; a[i].endTime&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Action test1[NUM] = &#123; &#123;<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">11</span>&#125;,&#123;<span class="hljs-number">8</span>,<span class="hljs-number">12</span>&#125; ,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">13</span>&#125; &#125;;<br>    <span class="hljs-comment">//supposed:&#123;1,4&#125;-&gt;&#123;5,7&#125;-&gt;&#123;8,11&#125;</span><br>Action test2[NUM] = &#123; &#123;<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">9</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">12</span>,<span class="hljs-number">20</span>&#125;,&#123;<span class="hljs-number">22</span>,<span class="hljs-number">23</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; &#125;;<br>    <span class="hljs-comment">//supposed:&#123;0,1&#125;-&gt;&#123;1,2&#125;-&gt;&#123;2,3&#125;-&gt;&#123;4,5&#125;-&gt;&#123;6,7&#125;-&gt;&#123;12,20&#125;-&gt;&#123;22,23&#125;</span><br><span class="hljs-type">bool</span> selected1[NUM] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-type">bool</span> selected2[NUM] = &#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-built_in">solution</span>(test1,selected1);<br><span class="hljs-built_in">display</span>(test1,selected1);<br>cout &lt;&lt; <span class="hljs-string">&quot;//////////////////&quot;</span>&lt;&lt;endl;<br><span class="hljs-built_in">solution</span>(test2, selected2);<br><span class="hljs-built_in">display</span>(test2, selected2);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><blockquote><p>1.最高价值优先；2.最低重量优先；3.最高性价比优先。无脑3.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//0.背包数据结构，重量和价值，按单位重量价值排序；</span><br><span class="hljs-comment">//1.对排序好的序列依次取得书包；</span><br><span class="hljs-comment">//2.对于最后一个书包，可能会出现无法全拿走的情况，因此需要计算能拿走的最大比例；</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">//notes:这里是按单位重量价值降序排序，但原生的sort函数是升序排列的， 因此需要自定义operator 但是这样会导致语义混乱，因此可以定义一个compare函数，作为sort的参数。</span><br><span class="hljs-comment">//拿走最后一份（或者比例份）要把MAXWEIGHT归零。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span> &#123;<br><span class="hljs-type">double</span> value;<br><span class="hljs-type">double</span> weight;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Take</span><br>&#123;<br><span class="hljs-type">bool</span> isTaken=<span class="hljs-literal">false</span>;<br><span class="hljs-type">double</span> proportion=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(Bag a, Bag b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.value/a.weight&gt;b.value/b.weight;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(Bag b[],Take t[], <span class="hljs-type">int</span> M)</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(b, b + NUM,compare);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;;++i)<br>&#123;<br><span class="hljs-keyword">if</span> (M &gt;= b[i].weight)<br>&#123;<br>t[i].isTaken = <span class="hljs-literal">true</span>;<br>t[i].proportion = <span class="hljs-number">1</span>;<br>M -= b[i].weight;<br><br>&#125;<span class="hljs-comment">//以上为能全部拿走的物品</span><br><span class="hljs-comment">//当背包剩余质量低于当前考虑的物品，则只能尽全力充满背包了，</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (M != <span class="hljs-number">0</span>)<br>&#123;<br>t[i].isTaken = <span class="hljs-literal">true</span>;<br>t[i].proportion = M / b[i].weight;<br>M = <span class="hljs-number">0</span>;<span class="hljs-comment">//别忘了M置零！</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(Bag b[], Take t[])</span> </span>&#123;<br><span class="hljs-type">double</span> sumValue = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; t[i].isTaken; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Bag:&quot;</span> &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot;价值：&quot;</span>&lt;&lt;b[i].value&lt;&lt;<span class="hljs-string">&quot; 重量:&quot;</span>&lt;&lt;b[i].weight &lt;&lt; <span class="hljs-string">&quot;被拿走&quot;</span> &lt;&lt; t[i].proportion &lt;&lt; <span class="hljs-string">&quot;份&quot;</span> &lt;&lt; endl;<br>sumValue += b[i].value * t[i].proportion;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;总价值为：&quot;</span> &lt;&lt; sumValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>Bag Bagtest1[NUM] = &#123; &#123;<span class="hljs-number">20</span>,<span class="hljs-number">10</span>&#125;,&#123;<span class="hljs-number">30</span>,<span class="hljs-number">20</span>&#125;,&#123;<span class="hljs-number">66</span>,<span class="hljs-number">30</span>&#125;,&#123;<span class="hljs-number">40</span>,<span class="hljs-number">40</span>&#125;,&#123;<span class="hljs-number">60</span>,<span class="hljs-number">50</span>&#125; &#125;;<br>Take Taketest1[NUM] = &#123;&#125;;<br><span class="hljs-type">int</span> MaxWeight = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">solution</span>(Bagtest1,Taketest1, MaxWeight);<br><span class="hljs-built_in">display</span>(Bagtest1,Taketest1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="田忌赛马"><a href="#田忌赛马" class="headerlink" title="田忌赛马"></a>田忌赛马</h2><blockquote><p>田忌与齐威王赛马，每一局的赢家+1积分 输家-1积分 平局无事发生，田忌如何安排才能获得最多的积分？田忌和齐威王的马们可以用分别用两个数组表示，下标为马的编号，元素值为对应马的速度。先对两组马速度排序，两组双指针，分别指向本组最速のhorse和最慢的马。那么有4种情况：</p><p>1.田最速の马&gt;齐最速の马 （这种情况会出现在齐浪费了他本来最速の马，导致他当前最速の马不如田的）</p><p>此时直接让这两匹马比赛，田田+1.</p><p>2.田最速の马&lt;齐最速の马</p><p>此时让田最拉の马和齐最速の马比，田田-1.</p><p>3.田最速の马&#x3D;齐最速の马</p><p>这时狗一下，考虑最拉の马：</p><p>​3.1 田最拉の马&gt;齐最拉の马 </p><p>​此时直接让这两匹马比赛，田田+1.</p><p>​3.2 田最拉の马&lt;&#x3D;齐最拉の马 </p><p>​此时让田最拉の马和齐最速の马比！田田-1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//1.Tmax&gt;Qmax::Tmax vs Qmax</span><br><span class="hljs-comment">//2.Tmax&lt;Qmax:Tmin vs Qmax</span><br><span class="hljs-comment">//3.Tmax=Qmax:</span><br><span class="hljs-comment">//3.1 Tmin&gt;Qmin Tmin vs Qmin</span><br><span class="hljs-comment">//3.2 Tmin&lt;Qmin Tmin vs Qmax</span><br><span class="hljs-comment">//3.3 Tmin=Qmin Tmin vs Qmax</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> t[],<span class="hljs-type">int</span> q[])</span> </span>&#123;<br><span class="hljs-built_in">sort</span>(t,t+NUM);<br><span class="hljs-built_in">sort</span>(q,q+NUM);<br><span class="hljs-type">int</span> tl = <span class="hljs-number">0</span>, tr = NUM - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> ql = <span class="hljs-number">0</span>, qr = NUM - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> score = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (tl &lt;= tr)<br>&#123;<br><span class="hljs-keyword">if</span> (t[tr] &gt; q[qr])<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tr] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[qr] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score += <span class="hljs-number">200</span>;<br>tr--;<br>qr--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[tr] &lt; q[qr])<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tl] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[qr] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score -= <span class="hljs-number">200</span>;<br>tl++;<br>qr--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (t[tl] &gt; q[ql])<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tl] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[ql] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score += <span class="hljs-number">200</span>;<br>tl++;<br>ql++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;田忌的&quot;</span> &lt;&lt; t[tl] &lt;&lt; <span class="hljs-string">&quot;与齐王的&quot;</span> &lt;&lt; q[qr] &lt;&lt; <span class="hljs-string">&quot;比赛&quot;</span> &lt;&lt; endl;<br>score -= <span class="hljs-number">200</span>;<br>tl++;<br>qr--;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; score;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> Tian[NUM] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//1 2 3 4 5 </span><br><span class="hljs-type">int</span> Qi[NUM] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">//2 3 4 5 6     score:1-6 2-5 ::-400/// 3-2 4-3 5-4::+600/===+200</span><br><span class="hljs-built_in">solution</span>(Tian, Qi);<br>cout &lt;&lt; endl;<br><span class="hljs-type">int</span> T2[NUM] = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> Q2[NUM] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;<br><span class="hljs-built_in">solution</span>(T2, Q2);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多机调度问题"><a href="#多机调度问题" class="headerlink" title="多机调度问题"></a>多机调度问题</h2><blockquote><p>n个作业 m台相同的机器 每个作业都有各自的处理用时 并且作业和作业的处理都是原子化的 怎么安排才能在最短时间内完成所有作业的加工？1.最短作业优先 2.最长作业优先 我一开始竟然还认为是最短作业！但其实不是啊，应该是长作业优先！</p><p>分析：给所有作业按执行时长降序排序，然后按照贪心原则依次分配给机器们，这里就考虑到了，倘若机器数大于作业数，那直接将作业分别分配给每个机器就行，如果机器数少于作业数才需要慢慢做，如果将作业，机器，执行时长独立起来将会很乱！也不便于叙述，不如直接将他们对应绑定作为一个数据结构：分配方案allocation。那么最初的排序也要改动成为对allocation数组按照属性time降序排序，然后每一次处理新作业，就将机器编号+1，但是这就考虑到了，如果已经分配完了所有机器，而后续作业将分配给率先完成的那些之前分配的短作业所在的机器号，那么这里的处理就不必+1，而是直接将完成的allocation的机器编号赋值给当前待处理的作业即可。有点乱，整理后，清晰的思路如下：</p><p>思路：数据结构：先定义一个数据结构表示分配方案：作业编号-作业执行时长-为其分配的机器的编号。将分配方案按作业执行时长降序排序。执行算法：先判断作业数量和机器数量的大小关系，如果机器数量更多，可以直接将每个作业分配给这些机器，此情况最终的执行时长就是max <sub>i in all</sub>(allocation[i].time);如果作业更多，那就要先按贪心原则排好序，再一一入队（从0开始，遍历到machineAmount-1），此过程不需要考虑别的，第一轮分配完毕后，为了分配其余的作业（从machineAmount开始，遍历到jobAmount），考虑已经执行完毕了的短作业，最短的作业最先执行完，因此优先出队短作业（这里的队列就要设计成小根堆了），并做相应的数据处理（分析中提到的机器编号的处理），数据处理完毕后再让一个待处理作业入队即可…</p><p>三部曲：1.定义数据结构和compare函数 2.排序和必要处理 3.展示结果</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> jobAmount = <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> machineAmount = <span class="hljs-number">3</span>;<br><span class="hljs-comment">//作业和机器的分配关系</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">allocation</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//作业序号</span><br><span class="hljs-type">int</span> t;<span class="hljs-comment">//执行时间</span><br><span class="hljs-type">int</span> mno;<span class="hljs-comment">//机器序号</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> allocation&amp; s) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> t &gt; s.t;<br>&#125;<span class="hljs-comment">//按t越小越优先出队 注意这个出队指的是短作业完成的时间顺序，越短越早出队。</span><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">allocation</span> A[] = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">2</span>,<span class="hljs-number">14</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">16</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">7</span>,<span class="hljs-number">3</span>&#125; &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>allocation e;<br><span class="hljs-keyword">if</span> (jobAmount &lt;= machineAmount)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;为每一个作业分配一台机器\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">sort</span>(A, A + jobAmount);<br>priority_queue&lt;allocation&gt; qu;<span class="hljs-comment">//小根堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; machineAmount; i++)<br>&#123;<br>A[i].mno = i + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  给机器%d分配作业%d,执行时间为%2d,占用时间段:[%d,%d]\n&quot;</span>,<br>A[i].mno, A[i].no, A[i].t, <span class="hljs-number">0</span>, A[i].t);<br>qu.<span class="hljs-built_in">push</span>(A[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = machineAmount; j &lt; jobAmount; j++)<br>&#123;<br>e = qu.<span class="hljs-built_in">top</span>(); qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队e</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  给机器%d分配作业%d,执行时间为%2d,占用时间段:[%d,%d]\n&quot;</span>,<br>e.mno, A[j].no, A[j].t, e.t, e.t + A[j].t);<br>e.t += A[j].t;<br>qu.<span class="hljs-built_in">push</span>(e);<span class="hljs-comment">//e进队</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tactic:\n&quot;</span>);<br><span class="hljs-built_in">solution</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Huffman-编码"><a href="#Huffman-编码" class="headerlink" title="Huffman 编码"></a>Huffman 编码</h2><blockquote><p>字符集{d1…dn} 他们的对应的频率：{f1…fn}。求最优编码方案。</p><p>分析：先根据初始数据构造huffman树，再根据树求出编码。离散数学和数据结构中都学了huffman树的生成过程：每次选择两个最小频率元素作为叶子，再将它们的和作为根，将这个根作为一个叶子，而构造成此叶子的两个元素不再考虑。循环此过程。根据huffman树的生成过程可以发现贪心策略是：优先考虑最低频率的元素作为叶子节点。可以设置huffman树的节点数据结构TreeNode：包含weight，LC，RC，Parent，aChar。字符aChar和它的权值是最初就能初始化的，其它数据的初始化需要考虑建树的过程,最开始会将三个树结构属性全置为-1。在构造树的过程中再详细赋值。考虑树的构造过程，实际上会频繁比较，如果用排序会很低效，每次构造一个新节点后就排序，而且还要除去之前的两个节点，显然， 用优先级队列可以很轻松地解决，重载&lt;使得按照weight小者优先的 原则进行。首先将所有节点进队(0~n-1),然后构造(n~2*n-1),每次构造一个新节点，就将两个节点出队，处理好数据后将新节点入队，就不再需要手动排序了。至此，树就构造好了，接下来就要根据树求编码，对于每一个叶子节点，从它开始依次找到根节点，每当寻根的过程中作为了左孩子，就将编码链接1，否则链接0，最终将这个节点的aChar和构造出的string编码建立映射关系，存入map中，循环如此求出所有字符的编码。最后分别输出。还可以求出wpl，wpl&#x3D;每个叶子*他的深度。 </p><p>思路：</p><p>0.数据结构定义：TreeNode { aChar, weight, LC, RC, Parent}和 NodeType{ no, aChar ,weight, override &lt;}</p><p>1.初始化：TreeNode nodes[N]{xxxx};for(nodes 0 to 2n-1){LC&#x3D;RC&#x3D;Parent&#x3D;-1}</p><p>2.建树：for(leaves 0 to n-1){setData push} for(constructor Nodes n to 2n-1){e1pop; e2pop; e1&amp;e2 setData e; push e}</p><p>3.求编码：for(leaves 0 to n-1){ judge(as LC:1 or 0) &#x3D;&gt;until(root)}, set Map(char,string)}</p><p>4.求wpl：for(leaves 0 to n-1){Sum leafWeight*height }</p><p>5.输出结果：display</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">100000</span>;<br><span class="hljs-comment">//四大模块：初始化数据；建树和输出树；建编码并输出编码；计算wpl；</span><br><span class="hljs-comment">//准备条件：初始化一组编码和他对应的频率（权值）。</span><br><span class="hljs-comment">//1.构造huffman树：首先将初始化的编码全部入队（0~n），然后从（n~2*n-1）依次构造出整个树，</span><br><span class="hljs-comment">// 此循环中每次出队（因为以后在构造其他节点时不再考虑）两个最小weight的节点，并利用他们构造出新节点，最为他们的父亲节点</span><br><span class="hljs-comment">// 2.通过huffman树构造编码：每个字符有其对应的编码，因此用map存放对应关系，</span><br><span class="hljs-comment">// 从huffman树的叶子开始依次寻到（until）根节点，每次作为左子节点则将编码连接1，否则连接0...每处理一个就建立mapping</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span><br>&#123;<br><span class="hljs-type">char</span> aChar;<span class="hljs-comment">//字符</span><br><span class="hljs-type">int</span> weight;<span class="hljs-comment">//权值：频率</span><br><span class="hljs-type">int</span> parent;<br><span class="hljs-type">int</span> lChild;<br><span class="hljs-type">int</span> rChild;<br>&#125;;<br><br>TreeNode nodes[MAX];<br>map&lt;<span class="hljs-type">char</span>, string&gt; huffmanCode;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><span class="hljs-comment">//优先队列结点类型</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//对应哈夫曼树ht中的位置</span><br><span class="hljs-type">char</span> aChar;<span class="hljs-comment">//字符</span><br><span class="hljs-type">int</span>  weight;<span class="hljs-comment">//权值</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> NodeType&amp; s) <span class="hljs-type">const</span><br>&#123;<span class="hljs-comment">//用于创建大根堆</span><br><span class="hljs-keyword">return</span> s.weight &lt; weight;<span class="hljs-comment">//weight越小越优先。</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">//构造哈夫曼树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHTree</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>NodeType e, e1, e2;<span class="hljs-comment">//由最小weight的e1 e2 构造e </span><br>priority_queue&lt;NodeType&gt; qu;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; k++)<span class="hljs-comment">//设置所有结点的指针域</span><br>nodes[k].lChild = nodes[k].rChild = nodes[k].parent = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-comment">//将n个结点进队qu</span><br>&#123;<br>e.no = i;<br>e.aChar = nodes[i].aChar;<br>e.weight = nodes[i].weight;<br>qu.<span class="hljs-built_in">push</span>(e);<br>&#125;<br><span class="hljs-comment">//关于此处的n 2*n-1 数据结构上有推导</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; j++)<span class="hljs-comment">//构造哈夫曼树的n-1个非叶结点</span><br>&#123;<br>e1 = qu.<span class="hljs-built_in">top</span>();  qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队权值最小的结点e1</span><br>e2 = qu.<span class="hljs-built_in">top</span>();  qu.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出队权值次小的结点e2</span><br>nodes[j].weight = e1.weight + e2.weight; <span class="hljs-comment">//构造哈夫曼树的非叶结点j</span><br>nodes[j].lChild = e1.no;<br>nodes[j].rChild = e2.no;<br>nodes[e1.no].parent = j;<span class="hljs-comment">//修改e1.no的双亲为结点j</span><br>nodes[e2.no].parent = j;<span class="hljs-comment">//修改e2.no的双亲为结点j</span><br>e.no = j;<span class="hljs-comment">//构造队列结点e</span><br>e.weight = e1.weight + e2.weight;<br>qu.<span class="hljs-built_in">push</span>(e);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHCode</span><span class="hljs-params">()</span><span class="hljs-comment">//构造哈夫曼编码</span></span><br><span class="hljs-function"></span>&#123;<br>string code;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-comment">//构造叶结点i的哈夫曼编码</span><br>&#123;<br>code = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">int</span> nowNo = i;<br><span class="hljs-type">int</span> f = nodes[nowNo].parent;<br><span class="hljs-keyword">while</span> (f != <span class="hljs-number">-1</span>)<span class="hljs-comment">//循环到根结点</span><br>&#123;<br><span class="hljs-keyword">if</span> (nodes[f].lChild == nowNo)<span class="hljs-comment">//当前节点作为父节点的左孩子</span><br>code = <span class="hljs-string">&#x27;0&#x27;</span> + code;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//当前节点作为父节点的右孩子</span><br>code = <span class="hljs-string">&#x27;1&#x27;</span> + code;<br>nowNo = f; f = nodes[nowNo].parent;<br>&#125;<br>huffmanCode[nodes[i].aChar] = code;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispHCode</span><span class="hljs-params">()</span><span class="hljs-comment">//输出哈夫曼编码</span></span><br><span class="hljs-function"></span>&#123;<br>map&lt;<span class="hljs-type">char</span>, string&gt;::iterator it;<br><span class="hljs-keyword">for</span> (it = huffmanCode.<span class="hljs-built_in">begin</span>(); it != huffmanCode.<span class="hljs-built_in">end</span>(); ++it)<br>cout &lt;&lt; <span class="hljs-string">&quot;    &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DispHTree</span><span class="hljs-params">()</span><span class="hljs-comment">//输出哈夫曼树</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    data=%c, weight=%d, lchild=%d, rchild=%d, parent=%d\n&quot;</span>,<br>nodes[i].aChar, nodes[i].weight, nodes[i].lChild, nodes[i].rChild, nodes[i].parent);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">WPL</span><span class="hljs-params">()</span><span class="hljs-comment">//求WPL</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> wpl = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>wpl += nodes[i].weight * huffmanCode[nodes[i].aChar].<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">return</span> wpl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n = <span class="hljs-number">5</span>;<br>nodes[<span class="hljs-number">0</span>].aChar = <span class="hljs-string">&#x27;a&#x27;</span>; nodes[<span class="hljs-number">0</span>].weight = <span class="hljs-number">4</span>;<span class="hljs-comment">//置初值即n个叶子结点</span><br>nodes[<span class="hljs-number">1</span>].aChar = <span class="hljs-string">&#x27;b&#x27;</span>; nodes[<span class="hljs-number">1</span>].weight = <span class="hljs-number">2</span>;<br>nodes[<span class="hljs-number">2</span>].aChar = <span class="hljs-string">&#x27;c&#x27;</span>; nodes[<span class="hljs-number">2</span>].weight = <span class="hljs-number">1</span>;<br>nodes[<span class="hljs-number">3</span>].aChar = <span class="hljs-string">&#x27;d&#x27;</span>; nodes[<span class="hljs-number">3</span>].weight = <span class="hljs-number">7</span>;<br>nodes[<span class="hljs-number">4</span>].aChar = <span class="hljs-string">&#x27;e&#x27;</span>; nodes[<span class="hljs-number">4</span>].weight = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">CreateHTree</span>();<span class="hljs-comment">//建立哈夫曼树</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;构造的哈夫曼树:\n&quot;</span>);<br><span class="hljs-built_in">DispHTree</span>();<br><span class="hljs-built_in">CreateHCode</span>();<span class="hljs-comment">//求哈夫曼编码</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;产生的哈夫曼编码如下:\n&quot;</span>);<br><span class="hljs-built_in">DispHCode</span>();<span class="hljs-comment">//输出哈夫曼编码</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WPL=%d\n&quot;</span>, <span class="hljs-built_in">WPL</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="流水线作业调度"><a href="#流水线作业调度" class="headerlink" title="流水线作业调度"></a>流水线作业调度</h2><blockquote><p>一批作业，他们都需要先在机器A上执行，然后再到B上执行，不同作业在不同机器上执行时间不同。该如何贪心呢？假设只有两个作业JobA JobB 他们在AB上的执行时间分别是(a1,b1)和(a2,b2)</p><ol><li><p>作业A先执行</p></li><li><p>作业B不必等待&#x3D;&gt;总时间为a1+a2+b1+b2-b1&#x3D;&gt;不等待是因为a2&gt;b1</p></li><li><p>作业B需要等待&#x3D;&gt;总时间为a1+a2+b1+b2-a2&#x3D;&gt;等待是因为a2&lt;b1</p></li></ol><p>  因此：A先执行的最短时间：a1+a2+b1+b2-min(b1,a2)</p><ol start="2"><li><p>作业B先执行</p></li><li><p>作业A不必等待&#x3D;&gt;总时间为a1+a2+b1+b2-b2&#x3D;&gt;不等待是因为a1&gt;b2</p></li><li><p>作业A需要等待&#x3D;&gt;总时间为a1+a2+b1+b2-a1&#x3D;&gt;等待是因为a1&lt;b2</p></li></ol><p>  因此：B先执行的最短时间：a1+a2+b1+b2-min(b2,a1)</p><p>综上：最短时间为：a1+a2+b1+b2+max( min(b1,a2) , min(b2,a1) ).根据此思路推导出贪心策略：</p><p>1.若a&gt;b 则让b较大的先执行</p><p>2.若a&lt;&#x3D;b 则让a较小的先执行</p><p>Johnson算法：</p><p>1.将所有作业按照a时间和b时间的大小关系分为两组，一组的作业a&lt;&#x3D;b，记为G1， 另一组作业a&gt;b，记为G2；</p><p>2.G1按a升序排序（最先执行最小a的作业），G2按b降序排序（最先执行最大b的作业）;</p><p>3.先执行完毕所有G1组，再执行完所有G2组。</p><p>（2.确定组内顺序，3.确定组间顺序，确定顺序后直接执行就能得到最佳调度方案）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(x,y) ((x)&gt;(y)?(x):(y))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-comment">//问题表示</span><br><span class="hljs-type">int</span> n=<span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> a[N]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">12</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-comment">//对应M1的时间</span><br><span class="hljs-type">int</span> b[N]=&#123;<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">7</span>&#125;;<span class="hljs-comment">//对应M2的时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NodeType</span><br>&#123;<br><span class="hljs-type">int</span> no;<span class="hljs-comment">//作业序号</span><br>    <span class="hljs-type">bool</span> group;<span class="hljs-comment">//1代表第一组G1,0代表第二组G2</span><br>    <span class="hljs-type">int</span> time;<span class="hljs-comment">//a,b的最小时间</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> NodeType &amp;s) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> time&lt;s.time;<span class="hljs-comment">//按time递增排序</span><br>&#125;<br>&#125;;<br><span class="hljs-comment">//求解结果表示</span><br><span class="hljs-type">int</span> best[N];<span class="hljs-comment">//最优调度序列</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span><span class="hljs-comment">//求解流水作业调度问题</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,j,k;<br>NodeType c[N];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//n个作业中,求出每个作业的最小加工时间 </span><br>&#123;<br>c[i].no=i;<br>c[i].group=(a[i]&lt;=b[i]);<span class="hljs-comment">//a[i]&lt;=b[i]对应第1组G1,a[i]&gt;b[i]对应第0组G2</span><br>c[i].time=a[i]&lt;=b[i]?a[i]:b[i];<span class="hljs-comment">//第1组存放a[i],第0组存放b[i]</span><br>&#125;<br><span class="hljs-built_in">sort</span>(c,c+n);<span class="hljs-comment">//c元素按time递增排序</span><br>j=<span class="hljs-number">0</span>; k=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//扫描c所有元素,产生最优调度方案</span><br>&#123;<br><span class="hljs-keyword">if</span>(c[i].group==<span class="hljs-number">1</span>)<span class="hljs-comment">//第1组,按time递增排列放在best的前面部分</span><br>best[j++]=c[i].no;<br><span class="hljs-keyword">else</span><span class="hljs-comment">//第0组,按time递减排列放到best的后面部分</span><br>best[k--]=c[i].no;<br>&#125;<br><span class="hljs-type">int</span> f1=<span class="hljs-number">0</span>;<span class="hljs-comment">//累计M1上的执行时间</span><br><span class="hljs-type">int</span> f2=<span class="hljs-number">0</span>;<span class="hljs-comment">//最优调度下的消耗总时间</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>f1+=a[best[i]];<br>f2=<span class="hljs-built_in">max</span>(f2,f1)+b[best[i]];<br>    &#125;<br><span class="hljs-keyword">return</span> f2;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;求解结果\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    总时间: %d\n&quot;</span>,<span class="hljs-built_in">solve</span>());<span class="hljs-comment">//输出:33</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    调度方案: &quot;</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,best[i]+<span class="hljs-number">1</span>);<span class="hljs-comment">//输出:3 1 4 2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基础</tag>
      
      <tag>贪心</tag>
      
      <tag>greed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/zyq.github.io/2025/03/04/hello-world/"/>
    <url>/zyq.github.io/2025/03/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>2023-11-19 12:00</p><p>Hello World…</p><blockquote><p>Lawyers, I suppose, were children once.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue构建</title>
    <link href="/zyq.github.io/2025/03/04/%E5%89%8D%E7%AB%AF/VueStart/"/>
    <url>/zyq.github.io/2025/03/04/%E5%89%8D%E7%AB%AF/VueStart/</url>
    
    <content type="html"><![CDATA[<h1 id="Learning-Vue"><a href="#Learning-Vue" class="headerlink" title="Learning Vue"></a>Learning Vue</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>准备工作分为 大部分：1.初始化项目；2.安装其他依赖和插件；3.自动导入优化和联想</p></blockquote><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>进入文件夹，npm init vue@latest –npm install –进入VScode npm run dev</p><h3 id="安装依赖和插件"><a href="#安装依赖和插件" class="headerlink" title="安装依赖和插件"></a>安装依赖和插件</h3><p>npm i axios–npm i element-plus –save – npm i @element-plus&#x2F;icon-vue<br>npm install -D unplugin-vue-components unplugin-icons unplugin-auto-import :<br>对于ICON还需要注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementPlusIconsVue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@element-plus/icons-vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><span class="hljs-comment">//注册所有ICON图标</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, component] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(<span class="hljs-title class_">ElementPlusIconsVue</span>)) &#123;<br>    app.<span class="hljs-title function_">component</span>(key, component)<br>&#125;<br></code></pre></td></tr></table></figure><p>注册完毕后，后续使用自动导入，因此不必再html页上作全局导入</p><h3 id="自动导入和联想"><a href="#自动导入和联想" class="headerlink" title="自动导入和联想"></a>自动导入和联想</h3><p>自动导入<strong>ele的组件和icon，vue的重要对象</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vite.config.js</span><br><span class="hljs-keyword">import</span> &#123; fileURLToPath, <span class="hljs-variable constant_">URL</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:url&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Icons</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">IconsResolver</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-icons/resolver&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-auto-import/vite&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Components</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/vite&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ElementPlusResolver</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;unplugin-vue-components/resolvers&#x27;</span><br><br><span class="hljs-keyword">const</span> pathSrc = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-title class_">AutoImport</span>(&#123;<br>      <span class="hljs-comment">// Auto import functions from Vue, e.g. ref, reactive, toRef...</span><br>      <span class="hljs-comment">// 自动导入 Vue 相关函数，如：ref, reactive, toRef 等</span><br>      <span class="hljs-attr">imports</span>: [<span class="hljs-string">&#x27;vue&#x27;</span>],<br><br>      <span class="hljs-comment">// Auto import functions from Element Plus, e.g. ElMessage, ElMessageBox... (with style)</span><br>      <span class="hljs-comment">// 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式)</span><br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br><br>        <span class="hljs-comment">// Auto import icon components</span><br>        <span class="hljs-comment">// 自动导入图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">prefix</span>: <span class="hljs-string">&#x27;Icon&#x27;</span>,<br>        &#125;),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;auto-imports.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Components</span>(&#123;<br>      <span class="hljs-attr">resolvers</span>: [<br>        <span class="hljs-comment">// Auto register icon components</span><br>        <span class="hljs-comment">// 自动注册图标组件</span><br>        <span class="hljs-title class_">IconsResolver</span>(&#123;<br>          <span class="hljs-attr">enabledCollections</span>: [<span class="hljs-string">&#x27;ep&#x27;</span>],<br>        &#125;),<br>        <span class="hljs-comment">// Auto register Element Plus components</span><br>        <span class="hljs-comment">// 自动导入 Element Plus 组件</span><br>        <span class="hljs-title class_">ElementPlusResolver</span>(),<br>      ],<br><br>      <span class="hljs-attr">dts</span>: path.<span class="hljs-title function_">resolve</span>(pathSrc, <span class="hljs-string">&#x27;components.d.ts&#x27;</span>),<br>    &#125;),<br><br>    <span class="hljs-title class_">Icons</span>(&#123;<br>      <span class="hljs-attr">autoInstall</span>: <span class="hljs-literal">true</span>,<br>    &#125;),<br><br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: pathSrc<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="开始编写代码"><a href="#开始编写代码" class="headerlink" title="开始编写代码"></a>开始编写代码</h2><p>分为界面部分和逻辑部分，逻辑部分主要是axios的调用等</p><blockquote><p>界面部分：</p><ul><li>登录前页面：组件:暂无</li></ul><ol><li>登录</li><li>注册</li></ol><ul><li>登录后页面：组件:导航栏 footer</li></ul><ol><li>主页（信息编辑页） </li><li>事务页</li></ol></blockquote><p>###界面设计<br>在进行页面设计前，需要重写<em><strong>全局样式</strong></em>：global.css并导入到main.js中<br>一般要修改的有：app html body三个部分 p,m&#x3D;0;display:flex;height&#x3D;100vh等<br>否则将会出现页面混乱如无法控制布局，无法铺上背景等诸多问题<br>###登录界面设计<br>####mode1：单一卡片风</p><blockquote><p>1.外部容器存放背景图和内部容器</p><blockquote><p>2.卡片容器：通常包括卡片头header存放logo或欢迎语</p><blockquote><p>3.表单:主体部分</p></blockquote><ul><li>uid</li><li>psw</li><li>recap</li><li>login_btn</li><li>about&amp;register&amp;findPsw<br>4.说明：常常需要考虑居中和靠左靠右的布局问题：<br>居中：父元素display:flex;align-item:center;justify_content:center;<br>靠左靠右：父元素display:flex;justify_content:flex_end;靠右的子元素：margin-left:auto</li></ul></blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus复习</title>
    <link href="/zyq.github.io/2025/03/04/%E5%89%8D%E7%AB%AF/EP_Use/"/>
    <url>/zyq.github.io/2025/03/04/%E5%89%8D%E7%AB%AF/EP_Use/</url>
    
    <content type="html"><![CDATA[<h1 id="Element-Plus"><a href="#Element-Plus" class="headerlink" title="Element Plus"></a>Element Plus</h1><h2 id="菜单（导航栏）"><a href="#菜单（导航栏）" class="headerlink" title="菜单（导航栏）"></a>菜单（导航栏）</h2><blockquote><p>Menu可以设计为导航栏，无论左侧还是顶部，放在对应的容器即可，下一次考虑导航栏的设计，可以采用此思路，设计好布局后，将menu组件放入对应的地方即可，这一次的设计不熟悉EP的组件，因此导航栏的设计并没有规划，导致走了不少弯路，自己也做了一些无用功。</p></blockquote><h3 id="菜单的使用技巧"><a href="#菜单的使用技巧" class="headerlink" title="菜单的使用技巧"></a>菜单的使用技巧</h3><blockquote><p>包括默认打开，折叠菜单，子菜单，菜单项组，打开方式（更多可以参见官网的API 此处给出一些常用的）（注意API的使用所能支持的模式）</p></blockquote><p>默认打开菜单：default-active；default-openeds<br>折叠菜单：collapse（vertical only）collapse-transition<br>子菜单（组件）：el-sub-menu<br>菜单项组（组件）：el-menu-item-group<br>打开方式：menu-trigger（horizontal only）：string(hover &#x2F; click)</p><blockquote><p>又发现了当折叠后，弹出子菜单选项的时间默认值有点慢，显得很卡不丝滑，因此更改响应时间是很有必要的<br>子菜单响应时间：show-timeout hide-timeout100ms不错</p></blockquote><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><blockquote><p>今天想要修改按钮的宽度，但ep并没有给出width属性，因此要么用style改，要么用vue控制style改，当然选择动态性的后者：<br>于是需要知道vue如何绑定style：</p></blockquote><blockquote><p>今天想通过行为更改按钮ICON 嘻嘻用v-if 代码如下</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;switchSize&quot;</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;&#123;width:Sidewidth&#125;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Fold</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-icon</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;Btnstate&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Expand</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-icon</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>v-bind：style&#x3D;“{width：xxxx}”</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ElementPlus布局</title>
    <link href="/zyq.github.io/2025/03/04/%E5%89%8D%E7%AB%AF/Layout/"/>
    <url>/zyq.github.io/2025/03/04/%E5%89%8D%E7%AB%AF/Layout/</url>
    
    <content type="html"><![CDATA[<h1 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h1><blockquote><p>先介绍布局思路，再介绍布局组件化</p></blockquote><h2 id="布局思路"><a href="#布局思路" class="headerlink" title="布局思路"></a>布局思路</h2><p>最重要的是关于el-container的理解：<br>el-container：当包含header或footer时会垂直排放子元素，否则水平，再利用多个container嵌套可以实现自己想要的布局：<br>比如我想要h a m式的布局head aside main</p><p>考虑container包括一个header和一个小的container<br>这样header和小container垂直<br>然后小container内包含aside和main aside和main水平</p><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>很多时候都是主要区域变化，导航区不变，因此很有必要在主要区域添加二级路由，将其他部分封装成组件比如LayoutHead LayoutAside，在ep中，由于container的性质已经规定好了（如上） 因此即使封装，也仍要在最外层写上container结构，然后对于具体的内容进行封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;script setup&gt;<br><span class="hljs-comment">//使用ep，为了工程化，目前可以封装成这样，在主界面还是要考虑编写最基本的框架，即嵌套的container，container的具体内容可以封装</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutHead</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/home/components/LayoutHead.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">LayoutAside</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/LayoutAside.vue&#x27;</span>;<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutHead</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutHead</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-header</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">LayoutAside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LayoutAside</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">el-main</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RouterView</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 二级路由 --&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- 设计思路：此处为localhost：3000/home，因此在路由home中设置children，然后在home.vue中对应的地方设置router-view --&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">el-main</span>&gt;</span>    </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span>   </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">el-container</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>如代码所示，即使把header封装成了layoutheader，但封装的是内容，外部的container没有封装进去，因此还要写上，即使封装进去了也不会实现，因为当使用组件时，在外部，他已经不具备container的性质了。也就要求在进行开发的时候，先确定好布局，写好容器排版，再将主要内容封装成组件并写在对应的位置。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>ElementPlus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
      <tag>ElementPlus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb基础实例1</title>
    <link href="/zyq.github.io/2025/03/04/%E5%90%8E%E7%AB%AF/JavaWebInstance/"/>
    <url>/zyq.github.io/2025/03/04/%E5%90%8E%E7%AB%AF/JavaWebInstance/</url>
    
    <content type="html"><![CDATA[<h1 id="员工部门管理系统——后端"><a href="#员工部门管理系统——后端" class="headerlink" title="员工部门管理系统——后端"></a>员工部门管理系统——后端</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>创建一个spring项目，添加4个依赖：spring web，mybatis framework，mysql driver，lombok。</li><li>数据库配置文件：application.properties:数据库连接经典四件套 和 两个经典mybatis优化配置 log和camelCase</li><li>MVC代码框架：<ol><li>pojo：Emp，Dept，Result</li><li>controller：@restController @autowired class:EmpController DeptController</li><li>service：@service interface:EmpService DepService class:EmpServiceImp DeptServiceImp</li><li>mapper：@mapper interface</li><li>mapper.XML：执行动态SQL必不可少的文件</li></ol></li><li>其他：<ol><li>@Slf4j 用于类中日志操作</li><li>RequestMapping(“&#x2F;api”):设置统一父路径</li><li>@GetMapping @DeleteMapping @PostMapping @PutMapping 约束数据交流方法</li><li>@data @allArgxxx @noArgxxx </li><li>动态SQL的相关知识点：各种标签的使用和处理</li></ol></li><li>注：代码初步框架如上，但在开发过程中，为了实现需求，还会增加其他的类和依赖和配置文件。</li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>实现员工-部门的小型后台管理系统：</p><blockquote><ol><li>实现员工和部门的增删查改；</li><li>登录校验和异常处理。</li></ol></blockquote><p>具体分析：</p><ol><li>为了完成员工和部门的增删查改。<strong>动态SQL</strong>是必须的，因此在上述代码框架中还要增加相应的XML文件完成动态SQL。员工的属性有头像，因此涉及到<strong>文件的上传</strong>，可以考虑用本地存储或阿里云OSS，若为阿里云OSS还必须创建aliOSSUtil类，两种方法都要创建一个uploadController来完成上传文件的控制。<strong>分页查询</strong>也是必要的，因此需要创建一个PageBean类存储返回的数据和数据条目数。</li><li>为了完成登录校验，可以利用JWT和拦截器，因此需要一个jwt的工具类专门来生成和转换jwt，需要一个登录拦截器类和拦截器的注册类，而登录操作也可以创建一个loginController。为了完成异常处理，定义一个全局异常处理类。</li><li>为了完成上述功能，除了定义额外的类，还需要必要的依赖和配置文件。而这些都是在具体的开发过程中慢慢完善的。在本阶段先分析到这一步。</li></ol><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><h3 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h3><p>考虑到需要返回信息给前端，因此可以设置一个返回结果类，封装返回码，状态和数据，数据直接用最泛的Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer code;<span class="hljs-comment">//响应码，1 代表成功; 0 代表失败</span><br>    <span class="hljs-keyword">private</span> String msg;  <span class="hljs-comment">//响应信息 描述字符串</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//返回的数据</span><br><br>    <span class="hljs-comment">//增删改 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,<span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-comment">//查询 成功响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;success&quot;</span>,data);<br>    &#125;<br>    <span class="hljs-comment">//失败响应</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,msg,<span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由开发过程的分析：依次从controller,service interface,service class,mapping interface(or with XML)完成业务的实现。</p><h3 id="简短的增删查改（部门增删查改）"><a href="#简短的增删查改（部门增删查改）" class="headerlink" title="简短的增删查改（部门增删查改）"></a>简短的增删查改（部门增删查改）</h3><p>对于简短的增删查改，可以行云流水地实现在mapper层，不必写在xml中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">deptController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> deptService deptService;<br><br>    <span class="hljs-comment">//getMapping,对于get请求的映射 等价于---@RequestMapping(value = &quot;/depts&quot; , method = RequestMethod.GET)</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptList</span><span class="hljs-params">()</span>&#123;<br>        log.info(<span class="hljs-string">&quot;查询所有部门数据&quot;</span>);<br>        List&lt;Dept&gt; deptList=deptService.deptList();<br>        <span class="hljs-keyword">return</span> Result.success(deptList);<br>    &#125;<br><br>    <span class="hljs-comment">//获取路径参数 pathVariable注解</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptDel</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;删除部门，id：&quot;</span>+id);<br>        deptService.deptDel(id);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptIns</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;添加部门:&quot;</span>+dept.getName());<br>        deptService.deptIns(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>    <span class="hljs-meta">@PutMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deptMod</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Dept dept)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;修改部门:&quot;</span>+dept.getId());<br>        deptService.deptMod(dept);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个函数对应一种业务，从controller开始，层层定义，实现。具体实现中值得注意的地方有：</p><blockquote><ol><li>@RequestBody</li><li>@RequestMapping</li><li>Result.success()和Result.success(object)</li><li>特殊属性记得每次都更新：updateTime</li></ol></blockquote><p>当设计较为复杂的业务时：分页查询，动态sql，文件处理。可以按以下策略进行：</p><h3 id="动态增删查改（员工增删查改）"><a href="#动态增删查改（员工增删查改）" class="headerlink" title="动态增删查改（员工增删查改）"></a>动态增删查改（员工增删查改）</h3><p>对于“查”，不仅是动态的，而且是分页的。当数据很多的时候，总不能够全都塞在页面吧，因此要设计分页的机制。前端向后端提供页码和每页的大小。</p><p>后端根据页码和每页的大小，算出每页显示的元素的范围，用select limit完成操作。同时，前端尝尝还需要统计总的数据量给用户，因此需要用到sql中的count函数。后端将具体的信息和总的数据数返回给前端，这样一看，需要返回两种数据了，因此考虑专门设计一个类来返回这些数据。于是PageBean类由此诞生，当然，它属于pojo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageBean</span> &#123;<br><span class="hljs-comment">//    List&lt;Emp&gt; empList;</span><br>   <span class="hljs-comment">/* 这里不要用EmpList，因为将来所有的分页查询都会用到这个类，不能在这里限定泛型*/</span><br>    <span class="hljs-keyword">private</span> List rows;<br>    <span class="hljs-keyword">private</span> Long total;<br>&#125;<br></code></pre></td></tr></table></figure><p>那后端还需要获取到前端传过来的参数：页码，每页大小，并且考虑实际运用，还需要设定默认值从第一页开始默认页码为xx，这些业务的实现需要用到：</p><blockquote><p>@RequestParam(defaulValue&#x3D;“xxx”)</p></blockquote><p>再接着思考，查询时添加条件是完全必要的，动态添加条件更是重要，因此考虑动态sql，因此，为了一次实现，万金油的利用，如果可以的话，将所有表属性作为参数执行动态SQL将会是一劳永逸的。当然还是得结合实际情况，要是根本不可能去根据某些属性来查询，那就确实没必要编写含有它的动态SQL了。因此可以设计出如下的controller代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里是根据分页，姓名，性别，入职日期几个属性完成的条件查询</span><br><span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">selectEmpFilter</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(defaultValue = &quot;1&quot;)</span> Integer page,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@RequestParam(defaultValue = &quot;10&quot;)</span> Integer pageSize,</span><br><span class="hljs-params">                                  String name, Short gender,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate begin,</span><br><span class="hljs-params">                                  <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> LocalDate end)</span><br>    &#123;<br>        log.info(<span class="hljs-string">&quot;条件查询对应的员工&quot;</span>);<br>        PageBean pageBean=empService.selectEmpFilter(page,pageSize,name,gender,begin,end);<br>        <span class="hljs-keyword">return</span> Result.success(pageBean);<br>    &#125;<br><span class="hljs-meta">@DeleteMapping(&quot;/&#123;ids&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">delEmp</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer[] ids)</span>&#123;<br>        empService.delEmp(ids);<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br></code></pre></td></tr></table></figure><p>对应的XML实现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.instance.mapper.empMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterRows&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.instance.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>            <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                    name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                    and gender = #&#123;gender&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                    and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>                <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>            limit #&#123;startIndex&#125;,#&#123;pageSize&#125;<br>--             order by update_time desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectEmpFilterTotal&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;long&quot;</span>&gt;</span><br>        select count(*) from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name!=null and name!=&#x27;&#x27;&quot;</span>&gt;</span><br>                name like concat (&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender!=null&quot;</span>&gt;</span><br>                and gender = #&#123;gender&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin!=null and end!=null&quot;</span>&gt;</span><br>                and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delEmp&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的几个点：</p><blockquote><ol><li><p>name like concat (‘%’,#{name},’%’) ：利用concat 既能实现拼接又能防止sql注入！</p></li><li><p>name !&#x3D;null and name!&#x3D;‘’ 这里是空的引号，千万不要加空格，否则会出现很<del>傻逼</del>的错误：NumberFormatException: For input string:“xx”&lt;-这里是你输入的name，他认为你输入了number；</p></li><li><p>最重要的还得是动态sql到底是如何实现的，那几个关键字一定要学会使用<foreach> <where> <if>……</p></li><li><p>还有一点就是XML建立时，确定对应的函数的那几个对应，一定也要记住；</p></li><li><p>对于日期的处理，可以使用@DateTimeFormat(pattern&#x3D;“yyyy-MM-dd”)来规范，前端不按照这个格式传，就会返回对应的提示警告。</p></li></ol></blockquote><h3 id="文件上传（带头像的员工的增改）"><a href="#文件上传（带头像的员工的增改）" class="headerlink" title="文件上传（带头像的员工的增改）"></a>文件上传（带头像的员工的增改）</h3><p>上传文件，由于文件与其他一般数据不同，需要在前段端和后端都进行额外处理。</p><p>前端：form表格中 method&#x3D;“post” enctype&#x3D;“multipart&#x2F;form-data” input中type&#x3D;‘file’ name&#x3D;‘xxx(设为image)’</p><p>设置好这些后，前端通过post方法传给后端的body中就会包含一般数据和类型为MultipartFile的文件，名称为：xxx（image），后端接受时应保持名称的一致，若是非要不同，可以采用：@RequestParam(“image”) MultipartFile file)来映射名称。</p><p>为了实现文件上传，不如将其考虑为单独的一个controller层，因此设置：uploadController类，然后在这个类中编写相应的代码。</p><p>至此，后端可以接受到前端传来的文件数据，但若不将其存储下来，他将是ephemeral的，存放在本地，数据量少尚可如此，倘若数据量大了就不现实也不安全，可以考虑阿里云的oos服务。</p><blockquote><p>为文件上传专门定义一个接口，在添加或修改员工头像时调用并自动回显，这并不与添加或修改操作本身冲突，因为在选择文件的那瞬间就调用了upload接口，而另外的是另外的接口&#x2F;emps &#x2F;emps&#x2F;update</p></blockquote><h4 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h4><p>先创建一个文件夹专门存放这些数据，在这里就已经提前想到了，可能会有同名文件的存在，可以通过uuid来解决这个问题。为了存放文件，必须知道（获取）文件的名称，大小，内容，输入流，和存储具体的方法。MultipartFile 常见方法中包括了这些： </p><blockquote><ul><li>String  getOriginalFilename();  &#x2F;&#x2F;获取原始文件名</li><li>void  transferTo(File dest);     &#x2F;&#x2F;将接收的文件转存到磁盘文件中</li><li>long  getSize();     &#x2F;&#x2F;获取文件的大小，单位：字节</li><li>byte[]  getBytes();    &#x2F;&#x2F;获取文件内容的字节数组</li><li>InputStream  getInputStream();    &#x2F;&#x2F;获取接收到的文件内容的输入流</li></ul></blockquote><p>还要考虑到文件大小，上传一个较大的文件(超出1M)时会报错，因为springBoot默认最大单个大小为1MB。</p><p>为了扩大一点，需要在application.properties中添加配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#配置单个文件最大上传大小</span><br><span class="hljs-attr">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-comment">#配置单个请求最大上传大小(一次请求可以上传多个文件)</span><br><span class="hljs-attr">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">100MB</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        log.info(<span class="hljs-string">&quot;文件上传：&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,image);<br>        <span class="hljs-comment">//获取原始文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>        <span class="hljs-comment">//构建新的文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">extname</span> <span class="hljs-operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<span class="hljs-comment">//文件扩展名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString()+extname;<span class="hljs-comment">//随机名+文件扩展名</span><br>        <span class="hljs-comment">//将文件存储在服务器的磁盘目录</span><br>        image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;E:/images/&quot;</span>+newFileName));<br>        <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此可以进一步完成新增员工和修改员工的功能。</p><p>修改员工的实现：为了增强用户体验，在前端点击修改员工时，表格中应默认提供目前的员工信息，也就是要先返回一次按id的查询，然后再进行一次update操作，因此为了完成这一功能实际上要完成两部分，后端分别写与这些功能对应的接口即可，分别的调用由前端完成。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null and username != &#x27;&#x27;&quot;</span>&gt;</span><br>                username = #&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null and password != &#x27;&#x27;&quot;</span>&gt;</span><br>                password = #&#123;password&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>                name = #&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender = #&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null and image != &#x27;&#x27;&quot;</span>&gt;</span><br>                image = #&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job = #&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate = #&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id = #&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time = #&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;注意&#x3D;&#x3D;在empServiceImp中还应设置updateTime，对于这一点一定要注意，只要涉及改动就要默认更新updateTime，添加员工时还需要注意设置creteTime。</p><h4 id="阿里云OSS"><a href="#阿里云OSS" class="headerlink" title="阿里云OSS"></a>阿里云OSS</h4><p>可以创建一个util类，当然，不要忘记@component。</p><p>要提前购买和开通oss服务，创建一个bucket，这里有四个关键信息需要保存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>; ---&gt;对应着外网访问的endpoint<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后再根据官方给出的示例程序，修改这四个信息即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://oss-cn-wuhan-lr.aliyuncs.com&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;web-framework01&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);<br>        ossClient.putObject(bucketName, fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>若在项目中每涉及到一个第三方技术服务，就将其参数硬编码，那参数变化时要动源码，这是要避免的。难以寻找而且很不优雅。</p><h4 id="参数配置化"><a href="#参数配置化" class="headerlink" title="参数配置化"></a>参数配置化</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#自定义的阿里云OSS配置信息</span><br><span class="hljs-attr">aliyun.oss.endpoint</span>=<span class="hljs-string">https://oss-cn-wuhan-lr.aliyuncs.com</span><br><span class="hljs-attr">aliyun.oss.accessKeyId</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.accessKeySecret</span>=<span class="hljs-string">xxxxxx</span><br><span class="hljs-attr">aliyun.oss.bucketName</span>=<span class="hljs-string">springbear-instance1</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.endpoint&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeyId&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeyId;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.accessKeySecret&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;aliyun.oss.bucketName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br> <br> <span class="hljs-comment">//省略其他代码...</span><br> &#125; <br></code></pre></td></tr></table></figure><h4 id="yml"><a href="#yml" class="headerlink" title="yml"></a>yml</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-attr">server.address</span>=<span class="hljs-string">127.0.0.1</span><br>=<span class="hljs-attr">&gt;</span><br><span class="hljs-attr">server</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">port</span>: <span class="hljs-string">8080</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-string">127.0.0.1 #注意数据和属性之间的空格！！</span><br></code></pre></td></tr></table></figure><p>可以看到配置同样的数据信息，yml格式的数据有以下特点：</p><ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心，重数据轻格式</li></ul><p>yml配置文件的基本语法：</p><blockquote><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li><code>#</code>表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul></blockquote><p>yml文件中常见的数据格式：</p><p>对象&#x2F;Map集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>数组&#x2F;List&#x2F;Set集合</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">hobby:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">java</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">game</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">sport</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/tlias</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">1234</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">multipart:</span><br>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span><br>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span><br>      <br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-attr">aliyun:</span><br>  <span class="hljs-attr">oss:</span><br>    <span class="hljs-attr">endpoint:</span> <span class="hljs-string">https://oss-cn-hangzhou.aliyuncs.com</span><br>    <span class="hljs-attr">accessKeyId:</span> <span class="hljs-string">LTAI4GCH1vX6DKqJWxd6nEuW</span><br>    <span class="hljs-attr">accessKeySecret:</span> <span class="hljs-string">yBshYweHOpqDuhCArrVHwIiBKpyqSL</span><br>    <span class="hljs-attr">bucketName:</span> <span class="hljs-string">web-397</span><br></code></pre></td></tr></table></figure><h4 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h4><p>对于@value注解，当处理成批的配置文件属性时会很臃肿；可以通过@ConfigurationProperties注解来优化：</p><p>首先要在maven中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>需要创建一个实现类xxxProperties来专门存放这些配置信息，且实体类中的属性名和配置文件当中key的名字必须要一致</p><blockquote><p>比如：配置文件当中叫endpoints，实体类当中的属性也得叫endpoints，另外实体类当中的属性还需要提供 getter &#x2F; setter方法</p></blockquote></li><li><p>需要将实体类交给Spring的IOC容器管理，成为IOC容器当中的bean对象</p></li><li><p>在实体类上添加<code>@ConfigurationProperties</code>注解，并通过perfix属性来指定配置参数项的前缀</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//AliOSSProperties.java</span><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*阿里云OSS相关配置*/</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSProperties</span> &#123;<br>    <span class="hljs-comment">//区域</span><br>    <span class="hljs-keyword">private</span> String endpoint;<br>    <span class="hljs-comment">//身份ID</span><br>    <span class="hljs-keyword">private</span> String accessKeyId ;<br>    <span class="hljs-comment">//身份密钥</span><br>    <span class="hljs-keyword">private</span> String accessKeySecret ;<br>    <span class="hljs-comment">//存储空间</span><br>    <span class="hljs-keyword">private</span> String bucketName;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终完成的AliOSSUtils工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//当前类对象由Spring创建和管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;<br><br>    <span class="hljs-comment">//注入配置参数实体类对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AliOSSProperties aliOSSProperties;-----------&gt;把原来的各种属性改成了专门存储属性的类<br>   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现上传图片到OSS</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile multipartFile)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 获取上传的文件的输入流</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> multipartFile.getInputStream();<br><br>        <span class="hljs-comment">// 避免文件覆盖</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> multipartFile.getOriginalFilename();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));<br><br>        <span class="hljs-comment">//上传文件到 OSS</span><br>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(aliOSSProperties.getEndpoint(),<br>                aliOSSProperties.getAccessKeyId(), aliOSSProperties.getAccessKeySecret());<br>        ossClient.putObject(aliOSSProperties.getBucketName(), fileName, inputStream);<br><br>        <span class="hljs-comment">//文件访问路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span>aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + aliOSSProperties.getBucketName() + <span class="hljs-string">&quot;.&quot;</span> + aliOSSProperties.getEndpoint().split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;<br><br>        <span class="hljs-comment">// 关闭ossClient</span><br>        ossClient.shutdown();<br>        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>还可以通过设置环境变量来完成配置文件的处理。环境变量是在操作系统级别设置的全局变量。它们包含有关操作系统和正在运行的应用程序的信息。应用程序可以读取环境变量以获取配置参数。在大多数操作系统中，可以使用特定的命令来设置和获取环境变量。例如，在Linux和Mac上，可以使用<code>export</code>命令设置环境变量，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">MY_VAR</span>=value<br></code></pre></td></tr></table></figure><p>应用程序可以通过读取<code>MY_VAR</code>环境变量来获取值。</p><blockquote><p>关于配置文件的处理，无非是从程序的可维护性和安全性出发的。<del>非常好程序，这使我的屁股旋转。</del></p></blockquote><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p>根据需求：在访问网站时，如果没有登录，则不能进入子路径url，这一点通过&#x3D;&#x3D;过滤器或拦截器&#x3D;&#x3D;来完成，也就是需要对除了&#x2F;login路径外的其他访问，在访问前进行拦截验证，如果已经登录了，则可以完成api的请求，否则不提供服务，为了识别是否登录过了，这一点通过&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;来完成。因此,“登录”不能仅仅只是执行一个查询检验那么简单。</p><h4 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h4><p>关于会话、会话跟踪，需要知道：</p><p>&#x3D;&#x3D;会话&#x3D;&#x3D;指的是浏览器与服务器之间的一次连接，我们就称为一次会话。</p><blockquote><p>在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p><ul><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p><code>会话</code>:在用户打开浏览器第一次访问服务器的时候，这个会话就建立了，直到有任何一方断开连接，此时会话就结束了。在一次会话当中，是可以包含多次请求和响应的。</p><p>比如：打开了浏览器来访问web服务器上的资源（浏览器不能关闭、服务器不能断开）</p></li><li><p>第1次：访问的是登录的接口，完成登录操作</p></li><li><p>第2次：访问的是部门管理接口，查询所有部门数据</p></li><li><p>第3次：访问的是员工管理接口，查询员工数据</p></li></ul><p>只要浏览器和服务器都没有关闭，以上3次请求都属于一次会话当中完成的。</p></blockquote><p>&#x3D;&#x3D;会话跟踪&#x3D;&#x3D;：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</p><blockquote><p>服务器会接收很多的请求，但是服务器是需要识别出这些请求是不是同一个浏览器发出来的。比如：1和2这两个请求是不是同一个浏览器发出来的，3和5这两个请求不是同一个浏览器发出来的。如果是同一个浏览器发出来的，就说明是同一个会话。如果是不同的浏览器发出来的，就说明是不同的会话。而识别多次请求是否来自于同一浏览器的过程，我就称为会话跟踪。</p></blockquote><p>使用会话跟踪技术就是要完成在同一个会话中多个请求之间数据的共享。</p><blockquote><p>为什么要共享数据呢？</p><p>由于HTTP是无状态协议，在后面请求中怎么拿到前一次请求生成的数据呢？此时就需要在一次会话的多次请求之间进行数据共享</p></blockquote><p>题外话：有没有想过在刷微博或者其他客户端软件时，你所看到的表象是你的账号会显示你所个性化的内容，而别人的账号显示的是别人的个性化内容（关注，粉丝等等等），这都是数据，根据你的ID，这些数据都已存入相应的表中了，根据你的id唯一标识，将这些绑定着id的个性化内容全部连根拔起显示给你。有没有想过为什么网页版会保持登录状态，这个就是会话跟踪技术实现的，他会在一定期限内保留住登录状态。</p><p>可以通过JWT,cookie,session来实现会话跟踪。</p><h5 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h5><p>json web token（官网：<a href="https://jwt.io/%EF%BC%89">https://jwt.io/）</a></p><ul><li><p>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</p><blockquote><p>简洁：是指jwt就是一个简单的字符串。可以在请求参数或者是请求头当中直接传递。</p><p>自包含：指的是jwt令牌，看似是一个随机的字符串，但是可以根据自身的需求在jwt令牌中存储自定义的数据内容。如：可以直接在jwt令牌中存储用户的相关信息。</p><p>简单来讲，jwt就是将原始的json数据格式进行了安全的封装，这样就可以直接基于jwt在通信双方安全的进行信息传输了。</p></blockquote></li></ul><p>JWT的组成： （JWT令牌由三个部分组成，三个部分之间用点来分割）</p><ul><li><p>第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{“alg”:”HS256”,”type”:”JWT”}</p></li><li><p>第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{“id”:”1”,”username”:”Tom”}</p></li><li><p>第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。</p><blockquote><p>签名的目的就是为了防jwt令牌被篡改，而正是因为jwt令牌最后一个部分数字签名的存在，整个jwt令牌是非常安全可靠的。一旦jwt令牌当中任何一个部分、任何一个字符被篡改了，整个令牌在校验的时候都会失败。</p></blockquote></li></ul><p>JWT是如何将原始的JSON格式数据，转变为字符串的呢？</p><p>在生成JWT令牌时，会对JSON格式的数据进行一次编码————base64编码</p><p>Base64：是一种基于64个可打印的字符来表示二进制数据的编码方式。既然能编码，那也就意味着也能解码。所使用的64个字符分别是A到Z、a到z、 0- 9，一个加号，一个斜杠，加起来就是64个字符。任何数据经过base64编码之后，最终就会通过这64个字符来表示。当然还有一个符号，那就是等号。等号它是一个补位的符号</p><p>需要注意的是Base64是编码方式，而不是加密方式。</p><p>JWT令牌最典型的应用场景就是登录认证：</p><ol><li>在浏览器发起请求来执行登录操作，此时会访问登录的接口，如果登录成功之后，我们需要生成一个jwt令牌，将生成的 jwt令牌返回给前端。</li><li>前端拿到jwt令牌之后，会将jwt令牌存储(浏览器localStorage)起来。在后续的每一次请求中都会将jwt令牌携带到服务端。</li><li>服务端统一拦截请求之后，先来判断一下这次请求有没有把令牌带过来，如果没有带过来，直接拒绝访问，如果带过来了，还要校验一下令牌是否是有效。如果有效，就直接放行进行请求的处理。</li></ol><p>在JWT登录认证的场景中我们发现，整个流程当中涉及到两步操作：</p><ol><li>在登录成功之后，要生成令牌。</li><li>每一次请求当中，要接收令牌并对令牌进行校验。</li></ol><p>为此定义一个工具类JWTutil。</p><p>当然，首先要引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JWTutil：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTutil</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String signKey=<span class="hljs-string">&quot;springbear&quot;</span>;<br>    <span class="hljs-comment">//有效期30天</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">24</span>*<span class="hljs-number">30L</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">genJWT</span><span class="hljs-params">(Map&lt;String,Object&gt; claims)</span>&#123;<br>        String jwt= Jwts.builder()<br>                .addClaims(claims)    <span class="hljs-comment">//自定义消息--有效载荷---有效载荷中存放什么数据也要和前端沟通好。这个项目中是id username 和 name</span><br>                .signWith(SignatureAlgorithm.HS256, signKey)    <span class="hljs-comment">//签名算法</span><br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis()+expire))<br>                .compact();<br>        <span class="hljs-keyword">return</span> jwt;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseJWT</span><span class="hljs-params">(String jwt)</span>&#123;<br>        Claims claims=Jwts.parser()<br>                .setSigningKey(signKey)<br>                .parseClaimsJws(jwt)<br>                .getBody();<br>        <span class="hljs-keyword">return</span> claims;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在使用JWT令牌时需要注意：</p><ul><li>JWT校验时使用的签名秘钥，必须和生成JWT令牌时使用的秘钥是配套的。</li><li>如果JWT令牌解析校验时报错，则说明 JWT令牌被篡改 或 失效了，令牌非法。</li></ul><p>因此登录功能的实现又清晰了：登录成功则生成token，执行业务则校验token，若非法，则拦截，合法就放行。</p><p>具体在项目中：前端请求登录，先验证账密是否合法（select），如果登陆成功了，就生成JWT，并将其返回，并且这使得用户在一定时间段内（token有效期间且没有清理浏览器localstorage）不必重复进行登录验证。</p><p>登录功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> empService empService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">loginTry</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span>&#123;<br>        Emp empExist=empService.loginTry(emp);<br>        <span class="hljs-keyword">if</span>(empExist!=<span class="hljs-literal">null</span>)&#123;<br>            log.info(<span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            Map&lt;String,Object&gt; claims=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            claims.put(<span class="hljs-string">&quot;id&quot;</span>,empExist.getId());<br>            claims.put(<span class="hljs-string">&quot;username&quot;</span>,empExist.getUsername());<br>            claims.put(<span class="hljs-string">&quot;name&quot;</span>,empExist.getName());<br>            <span class="hljs-comment">//假如登录成功，生成token（一个能被唯一转化的字符串）返回给前端，前端将会获取它并存储。</span><br>            <span class="hljs-comment">//在此后的操作，前端都会携带这个token来进行操作，只要token还在有效期，就能够放行，否则被拦截器拦截。</span><br>            String token=JWTutil.genJWT(claims);<br>            <span class="hljs-keyword">return</span> Result.success(token);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;登录失败&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>cookie是客户端会话跟踪技术，存储在客户端浏览器中。用cookie来跟踪会话，可以在浏览器第一次发起服务器请求时，在服务器端来设置一个cookie。</p><p>比如第一次请求了登录接口，登录接口执行完成之后，就可以设置一个cookie，在cookie中就可以来存储用户相关的数据信息。比如在cookie中存储当前登录用户的用户名，ID。</p><p>服务器端给客户端响应数据时会<strong>自动</strong>将cookie响应给浏览器，浏览器接收到此cookie后，会<strong>自动</strong>将cookie的值存储在浏览器本地。接下来在后续的每一次请求当中，都会将浏览器本地所存储的cookie<strong>自动</strong>地携带到服务端。</p><p>接下来服务端就可以获取到cookie的值。因此只需要判断这个cookie的值是否存在，如果不存在这个cookie，就说明客户端之前是没有访问登录接口的；如果存在，就说明客户端之前已经登录完成了。这样就可以基于cookie在同一次会话的不同请求之间来共享数据。</p><p>3个自动：</p><ul><li>服务器<strong>自动</strong>将cookie响应给浏览器。</li><li>浏览器接收到响应回来的数据之后，<strong>自动</strong>将cookie存储在浏览器本地。</li><li>在后续的请求当中，浏览器会<strong>自动</strong>将cookie携带到服务器端。</li></ul><p><strong>为什么这一切都是自动化进行的？</strong></p><p>因为cookie是HTTP协议中所支持的技术，而各大浏览器厂商都支持了这一标准。协议官方给我们提供了一个响应头和请求头：</p><ul><li>响应头 Set-Cookie ：设置Cookie数据</li><li>请求头 Cookie：携带Cookie数据</li></ul><p><strong>优缺点</strong></p><ul><li>优点：HTTP协议中支持的技术（像Set-Cookie 响应头的解析以及 Cookie 请求头数据的携带都由浏览器自动进行，无需手动操作）</li><li>缺点：<ul><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>不安全，用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><h5 id="session"><a href="#session" class="headerlink" title="session"></a>session</h5><p>服务器端会话跟踪技术，存储在服务器端的。Session就是基于Cookie来实现的</p><p><strong>优缺点</strong></p><ul><li>优点：Session是存储在服务端的，安全</li><li>缺点：<ul><li>服务器集群环境下无法直接使用Session</li><li>移动端APP(Android、IOS)中无法使用Cookie</li><li>用户可以自己禁用Cookie</li><li>Cookie不能跨域</li></ul></li></ul><blockquote><p>PS：Session 底层是基于Cookie实现的会话跟踪，如果Cookie不可用，则该方案也就失效了。</p></blockquote><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>什么是拦截器？</p><ul><li>是一种动态拦截方法调用的机制，类似于过滤器。</li><li>拦截器是Spring框架中提供的，用来动态拦截控制器方法的执行。</li></ul><p>拦截器的作用：</p><ul><li>拦截请求，在指定方法调用前后，根据业务需要执行预先设定的代码。</li></ul><p>在拦截器中通常做一些通用性操作，比如：通过拦截器来拦截前端发起的请求，将登录校验的逻辑全部编写在拦截器当中。在校验的过程当中，如发现用户登录了(携带JWT令牌且是合法令牌)，就可以直接放行，去访问spring当中的资源。如果校验时发现并没有登录或是非法令牌，就可以直接给前端响应未登录的错误信息。</p><h5 id="拦截路径"><a href="#拦截路径" class="headerlink" title="拦截路径"></a>拦截路径</h5><p>在注册拦截器时要指定拦截器的拦截路径，通过<code>addPathPatterns(&quot;要拦截路径&quot;)</code>指定要拦截的请求路径，<code>excludePathPatterns</code>指定不拦截的请求路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-comment">//拦截器对象</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginCheckInterceptor loginCheckInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//注册自定义拦截器对象</span><br>        registry.addInterceptor(loginCheckInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<span class="hljs-comment">//设置拦截器拦截的请求路径（ /** 表示拦截所有请求）</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<span class="hljs-comment">//设置不拦截的请求路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在拦截器中除了可以设置<code>/**</code>拦截所有资源外，还有一些常见拦截路径设置：</p><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>一级路径</td><td>能匹配&#x2F;depts，&#x2F;emps，&#x2F;login，不能匹配 &#x2F;depts&#x2F;1</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2</td></tr><tr><td>&#x2F;depts&#x2F;*</td><td>&#x2F;depts下的一级路径</td><td>能匹配&#x2F;depts&#x2F;1，不能匹配&#x2F;depts&#x2F;1&#x2F;2，&#x2F;depts</td></tr><tr><td>&#x2F;depts&#x2F;**</td><td>&#x2F;depts下的任意级路径</td><td>能匹配&#x2F;depts，&#x2F;depts&#x2F;1，&#x2F;depts&#x2F;1&#x2F;2，不能匹配&#x2F;emps&#x2F;1</td></tr></tbody></table><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><p>基本使用主要包括：定义拦截器，注册拦截器。</p><p>定义拦截器：一个项目中可能有多个拦截器，不妨建立一个拦截器包，对于登录功能中的拦截，定义LoginInterceptor类,(别忘了@component),该类需要实现HandlerInterceptor，并重写其三个方法，特别是prehandle这一方法，他决定着能否放行，因此jwt的验证也在此方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        String token=request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span>(token==<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//若存在 则验证合法性</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            JWTutil.parseJWT(token);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            log.info(<span class="hljs-string">&quot;非法token&quot;</span>);<br>            <span class="hljs-comment">//设置返回消息并转json</span><br>            Result result=Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(result);<br>            <span class="hljs-comment">//设置响应头（告知浏览器：响应的数据类型为json、响应的数据编码表为utf-8）</span><br>            response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>            <span class="hljs-comment">//响应</span><br>            response.getWriter().write(json);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*分析此实例的流程：</span><br><span class="hljs-comment">* 1. 登录页面不拦截，其他页面拦截，这一点在注册拦截器时控制拦截路径实现。</span><br><span class="hljs-comment">* 2. 其他路径的资源请求，需要携带token(位于请求头中)来若不存在则拒绝并返回相应的信息(json)，若存在则进行验证，合法则放行，否则拒绝并返回相应信息。</span><br><span class="hljs-comment">* 注：为了实现object到json的转换，可以导入阿里的fastjson依赖</span><br><span class="hljs-comment">* 注：返回的erro信息也是有讲究的，不能瞎写，前端需要根据erro中的信息来重定向或者进行其他操作的。比如这里是not_longin,前端获取到就会执行重定向到登录页面</span><br><span class="hljs-comment">* */</span><br></code></pre></td></tr></table></figure><p>注册拦截器：定义一个类WebConfig，该类需要实现webMvcConfigurer，该类中需要重写addInterceptor方法，也是在此类中完成注册拦截器和拦截路径的设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(loginInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<br>        <span class="hljs-comment">//为除了登录页外的其他页面注册拦截器。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="登录业务"><a href="#登录业务" class="headerlink" title="登录业务"></a>登录业务</h4><p>再次梳理登录业务：登录时，根据账密判断登录是否成功（select），成功则返回token和成功消息（jwt），否则返回错误信息，在token有效期内，该浏览器中的路径访问不会被阻拦（interceptor放行）。</p><p><img src="https://s3.bmp.ovh/imgs/2023/11/20/b18f88897cc0af29.png"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>项目编写到这里，以为已经OK了？？实际上忽略了异常处理这一点，因此下次在设计项目时，可以提前考虑。</p><p>当添加部门或者员工时，如果客户端输入的重名了，而数据库又不能完成插入语句，如果没有异常处理，那么前后端将无法完成相应的错误操作，而用户也最好能够得到对应的解释或者哪怕只是简短的提示，也可以通过异常处理来实现，捕获异常后，后端向前端返回额外的消息，前端再经过处理提示给用户。</p><p>异常处理很简单，在每一处可能会出现异常的地方都try catch显然太杂乱臃肿。因此可以定义一个类，专门处理异常，即：全局异常处理器。</p><ol><li><p>定义全局异常处理器非常简单，定义一个类，为此类加上@RestControllerAdvice，加上这个注解就代表定义了一个全局异常处理器。</p></li><li><p>在类中定义一个方法来捕获异常，此方法需要加注解@ExceptionHandler。通过@ExceptionHandler注解当中的value属性来指定要捕获异常的类型。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-comment">//处理异常</span><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span> <span class="hljs-comment">//指定能够处理的异常类型</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception e)</span>&#123;<br>        e.printStackTrace();<span class="hljs-comment">//打印堆栈中的异常信息</span><br>        <span class="hljs-comment">//捕获到异常之后，响应一个标准的Result</span><br>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;对不起,操作失败,请联系管理员&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@RestControllerAdvice &#x3D; @ControllerAdvice + @ResponseBody</p><p>处理异常的方法返回值会转换为json后再响应给前端</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>Mybatis</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis基础</title>
    <link href="/zyq.github.io/2025/03/04/%E5%90%8E%E7%AB%AF/MyBatis/"/>
    <url>/zyq.github.io/2025/03/04/%E5%90%8E%E7%AB%AF/MyBatis/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="construction"><a href="#construction" class="headerlink" title="construction"></a>construction</h3><p>创建spring项目，添加项目依赖，选择SQL大选项，选择里面的mybatis framework和mysql driver</p><h3 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h3><p>在application.properties中添加数据库四大件和必要的配置：日志显示和自动处理命名风格</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">zyq2004zyq</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatisstudy</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#mybatis log:mybatislog-impl std</span><br><span class="hljs-attr">mybatis.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#camel :mybatis naming map</span><br><span class="hljs-attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>安装mybatisX插件</p><h3 id="structure"><a href="#structure" class="headerlink" title="structure"></a>structure</h3><p>根据分层解耦，创建mapper包，并创建mapper接口添加mapper注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span><br></code></pre></td></tr></table></figure><p>创建实体类以及其所在的包pojo，可以利用lombok方便生成其构造方法 getter setter tostring等基本方法,使用前需要在pom.xml中添加依赖,其实也可以不这么做，直接在创建项目时就勾选开发依赖lombok，其实这两种方法没什么本质区别，熟练后直接在创建的时候添加就好了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Emp</span><br></code></pre></td></tr></table></figure><hr><blockquote><p>在mybatis中，主要以两种形式完成与数据库的信息交换，一种是映射注释的风格，另一种是XML文件的风格。对于简单的SQL语句，直接用映射的形式，对于复杂的SQL语句更建议用XML的形式</p></blockquote><h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><p>每种SQL语句都有其对应的注释。在mapper接口中添加public方法，对这个方法添加相应的注释，注释后的括号就是要执行的sql语句。</p><p>更多细节：为了方便在设计时不必取别名，必须始终严格遵守pojo类的属性与数据库中表的属性相同，下划线式转驼峰即可。因此对于涉及到多个属性的SQL语句，可以直接用对象的形式封存，mybatis自动完成了存取，你只需要保持一切都能对应上即可。</p><ol><li><p>通过参数进行SQL语句的执行是必不可少的，比如删除某个id为xx的数据。因此这里涉及到传参，通过#{id}实现即可。另外还有￥{}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//#&#123;&#125;预编译 换成？ 用于参数传递</span><br><span class="hljs-comment">//$&#123;&#125; 直接拼接 存在sql注入问题 表名和列表动态设置时使用</span><br><span class="hljs-meta">@Delete(&quot;delete from emp where id=#&#123;id  &#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行某些sql语句后，时常需要返回他的主键，进行更进一步的sql操作，<em><strong>主键返回</strong></em>：需要用到option注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//主键返回</span><br><span class="hljs-comment">//useGeneratedKeys获取生成的属性 赋予给keyProperty属性</span><br><span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span><br><span class="hljs-meta">@Insert(&quot;insert into emp(username,name,gender,image,job,entrydate,dept_id,create_time,update_time)&quot;+</span><br><span class="hljs-meta">        &quot;values(#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert2</span><span class="hljs-params">(Emp emp)</span>;<br></code></pre></td></tr></table></figure></li><li><p>查询语句是有返回值的，只要为上述函数定义返回对应的类型即可，对于查询语句，一般是pojo类的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from emp&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">select</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//above is in test</span><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMappingSelect</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Emp&gt; empList=empMapper.select();<br>        System.out.println(empList);<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果整个项目都这样写，特别是当SQL语句较复杂时，将不利于维护和编写，因此XML风格的写法是很重要的，而且XML风格能针对一些issue提供有效的solution。</p><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h3><p>在resource文件夹中新建与mapper相同名称路径的目录，建立时记得要&#x3D;&#x3D;<strong>用斜杠</strong>&#x3D;&#x3D;来一次性建立目录，不能用点，然后在此文件夹中创建与mapper接口相同名称的&#x3D;&#x3D;xml&#x3D;&#x3D;文件。然后写入基本的配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mbbasic.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sb&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mbbasic.pojo.Emp&quot;</span>&gt;</span><br>    select * from emp<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用时，需要用mapper标签中的namespace属性来标记出对应的mapper接口路径，路径&#x3D;&#x3D;包括接口本身&#x3D;&#x3D;，并且，在执行对应的SQL语句时，需要在sql标签中的id属性设置与mapper接口中方法的同名，只有这样让程序才能能精准定位。对于又返回结果集的select语句，还需要添加resultType标签，并往里写入返回结果集基本元素的pojo类路径，&#x3D;&#x3D;包括类本身&#x3D;&#x3D;。</p><p>总结：有四大要素：</p><ol><li><p>xml文件名和文件路径与mapper接口和mapper包路径对应；</p></li><li><p>mapper标签namespace属性与mapper接口路径对应；</p></li><li><p>sql语句id与mapper接口方法对应；</p></li><li><p>对于查询语句，resultType与pojo类路径对应。</p></li></ol><h3 id="CommonSQL"><a href="#CommonSQL" class="headerlink" title="CommonSQL"></a>CommonSQL</h3><p>对于一般SQL，就是所有属性都能一一对应的比较死板的SQL。这样的SQL很基础，更多用到的是动态SQL，考虑一种情况，当你需要select实体集合时，你编写了sql语句，sql语句中的属性，有时是基于表项属性中的1个，2个，3个…而且还不知道是哪几个，要么你写很多组查询方法，这太麻烦了，肯定不回去考虑，要么你一次性写出基于多个属性的查询，但实际在用的时候你还是可能只基于其中的某一个或多个属性来查询，因此多余的属性将会以null参数的形式传入，这样你将无法得到你想要的结果。查询如此，更新等语句更是如此，要是有一种机制能够帮助你完成类似java中的不定参数函数的功能就会很方便：这就是动态SQL。</p><h3 id="DynamicSQL"><a href="#DynamicSQL" class="headerlink" title="DynamicSQL"></a>DynamicSQL</h3><p>动态SQL对以上issue的solution是提供更多封装好了功能的标签，你只要学会去使用，将思维深度转换为广度，将脑力转换为记忆，以此助人登阶，何其浪漫~</p><p>mybatis提供的标签：<if> <foreach> <where> <set> &#x2F; <sql> <include>分别适用于不同场景，前组是‘关键字’，后两者是‘函数‘。</p><p>更方便的是，在mapper接口的方法的参数中，可以十分笼统地编写形参！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteByIds</span><span class="hljs-params">(List&lt;Integer&gt; ids)</span>;<br>    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Emp emp)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Emp emp)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>必须多练才能牢固记忆。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;条件表达式&quot;</span>&gt;</span><br>   要拼接的sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;集合名称&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;集合遍历出来的元素/项&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;每一次遍历使用的分隔符&quot;</span> </span><br><span class="hljs-tag">         <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;遍历开始前拼接的片段&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><br>------------------------------<br>实现delete from emp where id in (1,2,3);<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--删除操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteByIds&quot;</span>&gt;</span><br>        delete from emp where id in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>            #&#123;id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>------------------------------<br>实现不会出现and(单属性查询是不会出现and了 中间间隔的情况也会导致多余and的出现)或者where(select *是没有where字句的)干扰的查询<br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR<br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>        select * from emp<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>             <span class="hljs-comment">&lt;!-- if做为where标签的子元素 --&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                 and gender = #&#123;gender&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>             <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>------------------------------<br>实现不会有逗号干扰的update操作，用set标签替换set语句<br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）<br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--更新操作--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><br>        update emp<br>        <span class="hljs-comment">&lt;!-- 使用set标签，代替update语句中的set关键字 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>                username=#&#123;username&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>                name=#&#123;name&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>                gender=#&#123;gender&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span><br>                image=#&#123;image&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span><br>                job=#&#123;job&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span><br>                entrydate=#&#123;entrydate&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id=#&#123;deptId&#125;,<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span><br>                update_time=#&#123;updateTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>        where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>&gt;</span><br> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br><br>---------------------------------<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commonSelect&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span><br>            and gender = #&#123;gender&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span><br>            and entrydate between #&#123;begin&#125; and #&#123;end&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>    order by update_time desc<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOAD期末复习</title>
    <link href="/zyq.github.io/2023/12/12/%E6%9C%9F%E6%9C%AB/OOAD%E6%9C%9F%E6%9C%AB/OOAD/"/>
    <url>/zyq.github.io/2023/12/12/%E6%9C%9F%E6%9C%AB/OOAD%E6%9C%9F%E6%9C%AB/OOAD/</url>
    
    <content type="html"><![CDATA[<h1 id="OOAD期末复习"><a href="#OOAD期末复习" class="headerlink" title="OOAD期末复习"></a>OOAD期末复习</h1><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><blockquote><p>要素：</p><ol><li><p>类类型和类名 &lt;&lt;interface&gt;&gt; or &lt;&lt;entity&gt;&gt;</p></li><li><p>属性和方法及其修饰符：+ - # _ propertyName : type</p></li><li><p>关系：依赖 关联 聚合 组合 继承 实现（耦合程度递增）</p><p>A依赖B 即A的对象使用B的对象，这个使用很有灵性：调方法，将B对象做参数,局部变量</p><p><strong>虚线箭头</strong></p><p><img src="/zyq.github.io/./images/media/image1.jpeg">{width&#x3D;”5.262860892388451in”<br>height&#x3D;”0.90667104111986in”}</p><p>A关联B 即A类包含B类 手机:华为</p><p><strong>实线箭头</strong></p><p><img src="/zyq.github.io/./images/media/image2.jpeg">{width&#x3D;”5.4789566929133855in”<br>height&#x3D;”1.0518744531933508in”}</p><p>A聚合B 即B类包含A类 而且A类B类都能独当一面 磁盘:计算机 “聚散终有时”</p><p><strong>实线空菱形</strong><img src="/zyq.github.io/./images/media/image3.jpeg">{width&#x3D;”5.4185433070866145in”<br>height&#x3D;”0.9281244531933508in”}</p><p>A组合B 即B类包含A类 但A类B类不可分离 否则无法生存 翅膀:大雁</p><p><strong>实线实菱形</strong></p><p><img src="/zyq.github.io/./images/media/image4.jpeg">{width&#x3D;”5.5001498250218726in”<br>height&#x3D;”1.9618744531933507in”}A继承B 字面意思extends<strong>实线三角空箭头</strong> A实现B字面意思implements<strong>虚线三角空箭头</strong></p><p><img src="/zyq.github.io/./images/media/image5.jpeg"><img src="/zyq.github.io/./images/media/image6.png"></p></li></ol></blockquote><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><blockquote><p>要素：</p><ol><li><p>角色和对象：系统使用者为角色</p></li><li><p>生命线和控制焦点：控制焦点在被创建时 他的上端应该和消息持平</p></li><li><p>消息：创建 返回 自关联 异步消息<strong>实线箭头</strong> 同步消息为<strong>实线三角实箭头</strong> 返回消息为<strong>虚线箭头</strong></p></li></ol></blockquote><p><img src="/zyq.github.io/./images/media/image7.jpeg">{width&#x3D;”5.965866141732284in”<br>height&#x3D;”5.81614501312336in”}</p><h3 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h3><blockquote><p>要素：</p><ol><li><p>角色：使用系统的人</p></li><li><p>用例：具体的系统功能</p></li><li><p>关系：角色X用例：关联 角色X角色：泛化 用例X用例：包含，扩展<strong>虚线箭头</strong>&lt;&lt;includes&gt;&gt; &lt;&lt;extends&gt;&gt;</p></li><li><p>系统容器和标签</p></li></ol></blockquote><p><img src="/zyq.github.io/./images/media/image8.jpeg">{width&#x3D;”5.8030424321959755in”<br>height&#x3D;”3.615624453193351in”}</p><h3 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h3><blockquote><p>要素：</p><ol><li><p>节点：起终点，起点唯一终点可以有多个。状态(圆角矩形，可嵌套)，分支(菱形)</p></li><li><p>转换：状态图的关键：自转换，触发事件，监护条件[]，动作</p></li></ol></blockquote><p><img src="/zyq.github.io/./images/media/image9.jpeg">{width&#x3D;”6.139738626421697in”<br>height&#x3D;”4.05864501312336in”}</p><h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><blockquote><p>要素：</p><ol><li><p>结点：结点是存在与运行时的代表计算机资源的物理元素，可以是硬件也可以是运行其上的软件系统，比如64主机、Windows server2008操作系统、防火墙等。结点实例：更具体地表示 Node Instance :node.一个结点可以包含其他节点和节点实例：结点容器。物件：软件开发过程中的产物，包括过程模型（比如用例图、设计图等等）、源代码、可执行程序、设计文档、测试报告、需求原型、用户手册等等。物件表示如下，带有关键字«artifact»和文档图标。</p></li><li><p>功能程序：计算机中的功能 一个功能就画一个</p></li><li><p>连接：计算机之间的连接：HTTP TCP&#x2F;IP等等</p></li></ol></blockquote><p><img src="/zyq.github.io/./images/media/image10.jpeg">{width&#x3D;”6.068345363079615in”<br>height&#x3D;”4.375in”}</p><h2 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a>Design Patterns</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>要素：</p><blockquote><ol><li><p>工厂类：一般类，通过接受产品类型创建具体产品类</p></li><li><p>抽象产品类：抽象类或接口</p></li><li><p>具体产品类：一般类</p></li><li><p>产品类型：枚举类</p></li><li><p>客户端使用：将工厂类中的创建产品方法设置为静态方法，这样就不必创建工厂对象，客户端只需要传入产品类型即可获得对应的具体产品。</p></li></ol><p><img src="/zyq.github.io/./images/media/image11.png">{width&#x3D;”1.5520833333333333in”<br>height&#x3D;”1.8125in”}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Factory f=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>();<br>        Product aProduct= f.createProduct(ProductType.B);<br>        Product moreProduct= f.createProduct(ProductType.A);<br>        aProduct.aMethod();<br>        moreProduct.aMethod();<br>&#125;<br>&#125;<br><span class="hljs-comment">//工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-comment">//可设置为静态方法 用类名调用</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(ProductType type)</span>&#123;<br>            <span class="hljs-keyword">switch</span> (type)&#123;<br>            <span class="hljs-keyword">case</span> A :<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span> ();<br>            <span class="hljs-keyword">case</span> B :<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductB</span>();<br>            <span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//产品类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ProductType</span> &#123;<br>A,B;<br>&#125;<br><span class="hljs-comment">//抽象产品</span><br><span class="hljs-keyword">interface</span><br><span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;aMethod&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//具体产品</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Product</span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Method of Product A&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优点：</p><p>​实现了创建对象和使用对象的职责分离，客户端无需知道创建对象的细节，只需要传入正确的对象类型就能获取到对应的具体对象，有利于软件体系结构的优化。</p><p>缺点：</p><ol><li><p>工厂类中包含了某一类抽象类的所有子类的创建，违反了高内聚的责任分配原则；</p></li><li><p>如果要添加新的子类，则必须改变工厂类的代码，违背了开闭原则，因此系统的拓展性和可维护性较差。</p></li></ol></blockquote><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>要素：</p><blockquote><ol><li><p>抽象工厂：接口 泛型</p></li><li><p>具体工厂：具体类型 一般类</p></li><li><p>抽象产品：接口</p></li><li><p>具体产品：实现接口 一般类</p></li><li><p>客户端使用：工厂分权 具体产品对应一个具体工厂 因此先创建具体工厂<br>再用它来创建产品</p><p><img src="/zyq.github.io/./images/media/image12.png">{width&#x3D;”1.552082239720035in”<br>height&#x3D;”2.0in”}</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//client</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Factory&lt;Product&gt; factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryA</span>();<br>        Product aProduct=factory.createProduct();<br>        factory=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FactoryB</span>();<br>        Product moreProduct=factory.createProduct();<br>        aProduct.aMethod();<br>        moreProduct.aMethod();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//factory</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Factory</span> &lt;T&gt;&#123;<br>T <span class="hljs-title function_">createProduct</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//con factory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Factory</span>&#123;<br>    <span class="hljs-keyword">public</span> ProductA <span class="hljs-title function_">createProduct</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProductA</span>();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//product</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;aMethod&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//con product</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Product</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;A method&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>优点：</p><ol><li><p>克服了简单工厂模式不易于扩展的弊端，即<br>工厂方法模式符合开闭原则，便于添加新的具体类的创建功能；</p></li><li><p>具有简单工厂模式的优点，即将对象的创建过程封装在一个类中，因此客户端不需要知道具<br>体的创建过程就能创建出对应的对象</p></li></ol><p>缺点：</p><ol><li><p>类膨胀。每出现一个新的具体对象，就要为其定义他的类和对应的工厂类，因此当系统中要考虑的具体对象太多时，系统将变得较为复杂；</p></li><li><p>性能影响。由于类膨胀，因此创建对象的开销也会变大，同时，频繁地使用反射技术也会对系统性能造成影响。</p></li></ol></blockquote><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote><p>要素：</p><ol><li><p>抽象策略：接口</p></li><li><p>具体策略：实现接口 一般类</p></li><li><p>上下文：关联策略</p></li><li><p>客户端使用：以具体策略作为参数构造对应上下文然后执行策略</p></li></ol><p><img src="/zyq.github.io/./images/media/image13.png">{width&#x3D;”1.5729166666666667in”<br>height&#x3D;”1.53125in”}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//client</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Context c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyAdd</span>());<br>        System.out.println(c.executeStrategy(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));<br>        c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Context</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategySub</span>());<br>        System.out.println(c.executeStrategy(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br><span class="hljs-comment">//context</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> Strategy s;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy s)</span>&#123;<br>    <span class="hljs-built_in">this</span>.s=s;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeStrategy</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> s.doStrategy(a,b);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//strategy</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-title function_">doStrategy</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>;<br>&#125;<br><span class="hljs-comment">//con strategy</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyAdd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doStrategy</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优点：</p><ol><li><p>策略模式提供了管理相关的算法族的办法，可以通过继承将公有的代码放到父类Strategy中,从而避免代码重复；</p></li><li><p>减少了if else switch这类分支语句的使用,提高了项目的可维护性；</p></li><li><p>支持开闭原则,可以在不修改原代码的情况下,灵活增加新的算法策略；</p></li><li><p>实现了算法的使用和实现的分离，算法的使用放到环境类中,算法的实现放到具体策略类中。</p></li></ol><p>缺点：</p><ol><li><p>类膨胀，每个新的算法都要为其创建对应的策略类，因此增加了系统的复杂度；</p></li><li><p>客户端必须知道所有的策略类，从而才能自主决定要”实施”哪一个策略。</p></li></ol></blockquote><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><blockquote><p>要素：</p><ol><li>命令接受(执行)者:一般类 厨师</li><li>命令调用者：关联抽象命令 前台</li><li>抽象命令：关联接受者</li><li>具体命令：继承抽象命令</li><li>客户端使用：创建出服务员，然后调用服务员的方法，也就是让服务员去调用命令。<img src="/zyq.github.io/./images/media/image14.png">{width&#x3D;”1.65625in”<br>height&#x3D;”1.78125in”}</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//client</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Reciever r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Reciever</span>();<br>        Invoker i=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Invoker</span>();<br>        Command c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandA</span>(r);<br>        i.setCommand(c);<br>        i.executeCommand();<br>        i.setCommand(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandB</span>(r));<br>        i.executeCommand();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//receiver</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reciever</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionA</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Cook Vegetable&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionB</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Cook Fish&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//invoker</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoker</span> &#123;<br><span class="hljs-keyword">private</span> Command c;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCommand</span><span class="hljs-params">(Command c)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;There&#x27;s new Order !&quot;</span>);<br>        <span class="hljs-built_in">this</span>.c=c;<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeCommand</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Waiter Record Order&quot;</span>);<br>        c.execute();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//command</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">protected</span> Reciever r;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Command</span><span class="hljs-params">(Reciever r)</span>&#123;<br>    <span class="hljs-built_in">this</span>.r=r;<br>    &#125;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//con command</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommandA</span><span class="hljs-params">(Reciever r)</span>&#123;<br>    <span class="hljs-built_in">super</span>(r);<br>&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Vegetable Order committed&quot;</span>);<br>        r.actionA();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优点：</p><ol><li><p>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦；</p></li><li><p>符合”开闭原则”。增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，易于扩展；</p></li><li><p>方便实现 Undo 和 Redo操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复；</p></li></ol><p>缺点：</p><ol><li><p>类膨胀，使用命令模式可能会导致某些系统有过多的具体命令类，每有一个新的命令就要为其创建一个类，当命令过多时，系统中的类也会变多；</p></li><li><p>使用频率低、理解难度大，为了以命令的形式进行架构，解耦请求与实现，引入了额外类型结构，增加了理解上的困难，只在非常特定的应用场景下才会用到。</p></li></ol></blockquote><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote><p>要素：</p><ol><li>适配器：把被适配的类封装进来<br>暴露出一个正常的方法，但其实这个方法调用的是奇怪的方法，这样在客户端中就不会看到奇怪的方法了。</li><li>被适配类：第三方类 因此他在某些类似或者相同的业务处理上<br>方法名称等风格会有所不同， 需要让他融入当前的大家庭。</li><li>其他类：只是做一个参考 展示适配器模式的使用时机</li><li>客户端使用：创建一个适配器(xxxAdapter) 调用统一风格的api即可</li></ol><p><img src="/zyq.github.io/./images/media/image15.png">{width&#x3D;”1.84375in” height&#x3D;”1.25in”}</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//client</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Adapter a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Adapter</span>();<br>        CommonTarget c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonTarget</span>();<br>        a.aAPI();<br>        c.aAPI();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//adapter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CommonTarget</span>&#123;<br>    <span class="hljs-keyword">private</span> Adaptee a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Adaptee</span>();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aAPI</span><span class="hljs-params">()</span> &#123;<br>    a.otherModelApi();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//commonTarget</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonTarget</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aAPI</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;CommonApi&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//adaptee</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherModelApi</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;adaptee api&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优点：</p><ol><li><p>符合开闭原则，在不修改原有类代码的基础上，为其添加对应的适配器类；</p></li><li><p>复用性高，扩展型好。可以让本不兼容的类协作完成系统业务，十分灵活；</p></li><li><p>对客户端友好，不必知道被适配的类的具体逻辑，只需要调用其对应的适配器类的接口即可。</p></li></ol><p>缺点：</p><ol><li><p>增加了系统的复杂度，对于每个被适配的类，都需要创建其适配器类，造成类膨胀；</p></li><li><p>频繁或不当地使用适配器模式容易导致代码可读性变差，使得系统凌乱不易于整体把握，比如为了定义某类的适配器类，有时有产生矛盾或者难以理解的实现逻辑。</p></li></ol></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>OOAD</tag>
      
      <tag>软件工程</tag>
      
      <tag>期末</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java期末</title>
    <link href="/zyq.github.io/2023/12/10/%E6%9C%9F%E6%9C%AB/java%E6%9C%9F%E6%9C%AB/JAVA%E6%9C%9F%E6%9C%AB/"/>
    <url>/zyq.github.io/2023/12/10/%E6%9C%9F%E6%9C%AB/java%E6%9C%9F%E6%9C%AB/JAVA%E6%9C%9F%E6%9C%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Java期末"><a href="#Java期末" class="headerlink" title="Java期末"></a>Java期末</h1><h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><p>程序改错和程序分析题。侧重于OOP部分细节的理解</p><blockquote><ul><li><p>类中静态属性和静态方法和其他属性和方法的互相访问</p></li><li><p>super this关键字的使用情形多态：重载和重写的区别</p></li><li><p>抽象类</p></li><li><p>接口和继承的细节差异</p></li><li><p>内部类的类型和基本使用</p></li></ul></blockquote><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>java类的生命周期中，总是先创建静态属性和静态方法，因此在创建静态属性和静态方法时，其他的属性和方法可能还没有创建出来，因此可以知道，其他类型的属性和方法可以访问静态属性和静态方法，而静态方法只能访问静态属性，对于<strong>多个静态方法之间的互相调用</strong>要考虑他们的执行顺序，因为在类的生成过程中，多个静态方法是按顺序生成的，同一个类中按<code>定义顺序</code>，不同类的静态方法则按类的<code>加载顺序</code></p><h3 id="super-this"><a href="#super-this" class="headerlink" title="super this"></a>super this</h3><blockquote><p>不可在静态上下文中使用该关键字</p></blockquote><ol><li><p>构造函数：用super和this引用父类或本类构造函数时，必须要将表达式作为构造方法的第一条语句,因此可以推知：super和this访问构造函数时不能同时出现在一个构造函数中，也不能有多个super或this出现在同一构造函数中，即：<strong>this和super访问构造函数时，在本构造函数体中至多有一个会出现至多一次</strong></p></li><li><p>一般引用：supe和this还可以获取被隐藏了的属性，用于继承机制中访问被隐藏了的同名变量和方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>()&#123;<br>    ...<br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;....<br>    sout(<span class="hljs-string">&quot;i am a&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>()&#123;<br>    ...<br>    <span class="hljs-comment">//重写父类的方法:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aMethod</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//若父类方法中的一些步骤是必要的 或者想要复用代码 可以通过super调用同名方法(父类中的实现)</span><br>        <span class="hljs-built_in">super</span>.aMethod();<br>        sout(<span class="hljs-string">&quot;Man&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态即：同名方法不同实现。通过<strong>继承</strong>的重写（覆盖）和<strong>同一类</strong>中的重载来完成，重载是由参数来标志的，跟返回类型无关，同名函数，同一返回类型的不同参数数量 类型 顺序为同一方法的重载。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol><li><p>abstract修饰符，只能修饰方法和类，修饰方法时 与 <code>static | final | private</code>不能同时存在 即只能是 <code>abstract public</code></p></li><li><p>抽象类的成员和方法都可以是静态和非静态的</p></li><li><p>抽象类可以不包含抽象方法，可以包含非抽象方法，但包含抽象方法的类一定要被声明为抽象类</p></li><li><p>尽管抽象类不能被new出来，但他仍然有自己的构造器</p></li></ol><h3 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h3><ol><li><p>一个类最多只能继承一个父类但却可以实现不止一个接口；</p></li><li><p>接口之间也可以继承；</p></li><li><p>当一个具体类实现一个接口时，应当实现该接口中，包括该接口父接口的所有方法，若无需实现，<br>也需要给出空方法体。</p></li><li><p>接口的方法和属性都是默认public 可以不写但不能更改，在实现接口的方法时，必须显式写出public修饰符，否则将被视为缺省的访问符，此时产生了访问权限降级，因此必须写出public！</p></li><li><p>接口中的变量默认是public static final 可以不写但不能更改</p></li><li><p>抽象类可以不实现接口的方法</p></li><li><p>接口中的方法可以用default修饰 默认方法可以不被重写 并且可以直接调用</p></li><li><p>若一个类实现了多个接口 而着多个接口存在重名方法 则只需要实现一次即可</p></li><li><p>接口中可以出现重写的静态方法因为调用时也必须要加接口名和成员运算符调用</p></li><li><p>接口没有静态代码块</p></li><li><p>类和父类中的方法优先级高于任何默认方法的优先级，即当一个类继承其父类和实现接口时，当接<br>口和父类中的方法重名时，将执行其父类中的方法</p></li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类根据实现场景和细节处理分为：匿名内部类 静态嵌套类 局部方法内部类</p><ol><li><p>内部接口只能是静态的 内部类可以是静态的</p></li><li><p>内部类和内部接口不能与所在的外部类同名</p></li><li><p>内部类可以实现继承 可以是抽象的</p></li><li><p>内部类和其所在的外部类可以互相访问彼此的属性和方法</p></li></ol><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>在计算机系统中，数据从外部设备<strong>流入内存</strong>称为<strong>输入</strong>，反之称为输出，Java中的IO操作是以<strong>流的形式</strong>完成的，<strong>流是按照一定顺序排列的，有起点和终点的数据集合</strong>。根据方向不同分为输入流和输出流。</p><p>java.io包中的类和接口主要定义了两种类型的数据流：字节流和字符流类。他们处理的数据单位不同，前者是字节，后者是JVM将字节转化成的以2字节unicode字符为基本单位的字符，采用了统一的编码标准，更国际化。字节流可以处理任何类型的对象，包括二进制对象，而字符流只能处理字符和字符串，但是能提供更高效的操作处理方法。</p><p>IO分为四大部分</p><ul><li>文件</li></ul><blockquote><ol><li><p>创建：File(String filePath)  File(File parent,String child)  File(String parent,String child) File(URI uri)</p></li><li><p>API:</p><p>String[] list(),list(FilenameFilter filter)<br>返回该目录中的所有文件名和目录名</p><p>boolean createNewFile()<br>当前抽象路径名指定的文件不存在时则创建一个空的文件</p><p>static File createTempFile(String prefix,String suffix)<br>在默认临时文件目录中创建一个临时文件 以指定的前缀和后缀命名</p><p>boolean delete() 删除当前抽象路径名指定的文件</p><p>boolean mkdir() 创建此抽象路径名指定的目录</p><p>boolean mkdirs() 创建此抽象路径名指定的目录 以及其所需但不存在父目录</p><p>boolean renameTo(File dest) 重命名此抽象路径名表示的文件</p></li></ol></blockquote><p>字符流和字节流的基类：Reader Writer InputStreamOutputStream都不能直接实例化对象 要用具体的子类的流实例化：FileInputStream FileOutputStream FileReader FileWriter</p><ul><li>字符流</li></ul><blockquote><ol><li><p>字符输入流:</p><p>Reader:StringReader(String s) FileReader(String filePath)FileReader(File f)</p></li><li><p>字符输出流</p><p>Writer:StringWriter(int initialSize) StringWriter() FileWriter(String filePath) FileWriter(File f)</p></li></ol></blockquote><ul><li>字节流</li></ul><blockquote><ol><li><p>字节输入流：</p><p>InputStream: FileInputStream…</p></li><li><p>字节输出流：</p><p>OutputStream:FileOutputStream…</p></li></ol></blockquote><ul><li>高级流</li></ul><blockquote><ol><li>转换流：就是字符流，只是将字节流转换成对应的字符流：<br>InputStreamReader(InputStream in) OutputStreamWriter(OutputStreamout)</li><li>缓冲流:</li><li>BufferedInputStream&#x2F;BufferedOutputStream(InputStream&#x2F;OutputStreamin&#x2F;out,int size)</li><li>ByteArrayInputStream(byte[] b,int offset,int length)ByteArrayOutputStream(int size)&#x2F;&#x2F;size以字节为单位 默认为32</li><li>其他流：</li><li>RandomAccessFile(String name&#x2F;File file ,String mode)&#x3D;&gt;mode&#x3D;”r”&#x2F;“w”分别表示读取或写入 name为指定文件名称</li><li>SequenceInputStream<br>用来把多个输入流组成的集合作为数据源，其能够依次对多个输入流读取，直到最后一个输入流读完结束。SequenceInputStream(InputStreams1,InputStream s2) SequenceInputStream(Enumeration streamEnum)</li></ol></blockquote><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常的类型会以填空题形式考察 try catch finally 和 throws throw的使用细节会出程序分析题</p><p>所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为<strong>系统异常（运行时异常）</strong>和<strong>普通异常（非运行时异常）</strong>，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉。</p><p>java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或throws<br>声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。</p><p>创建一个异常对象并把它送到运行系统的过程就是抛出异常。语法格式：throw new 异常类名（提示信息）</p><p>创建自己的异常类时需要继承Exception</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>填空题 程序分析题 程序改错题都可能出现</p><p>有关线程的基本概念：<strong>线程状态</strong>和<strong>创建线程类</strong>的基本步骤会以填空题形式考察</p><p>有关于线程同步 线程中止 守护线程会作为程序分析题和改错题考察具体实现细节</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><blockquote><p><img src="/zyq.github.io/./images/media/image3.jpeg">{width&#x3D;”5.822916666666667in”<br>height&#x3D;”5.770833333333333in”}</p></blockquote><h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><ol><li><p>继承Thread类 继承 重载run 创建 start</p></li><li><p>实现Runnable接口 然后将该类的对象作为构造参数 new一个Thread类，再利用new出来的该Thread类对象start</p></li></ol><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>synchronized</li></ol><blockquote><p>用该关键字修饰代码块或方法,保证在代码调用该方法和执行该代码块时，最多只有一个线程能访<br>问。</p></blockquote><ol start="2"><li>ReentrantLock类</li></ol><blockquote><p>多个线程的同步可以通过ReentrantLock对象调用newCondition()方法生成的condition对象来控制，满足条件的线程即可执行，其余线程进入等待状态(condition.await())，当条件改变时，唤醒(condition.signalAll())所有等待状态的线程并重新检测条件.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynUtil</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReentrantLock lock=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Condition condition=lock.newCondition();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-meta">@override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    SynUtil.lock.lock(); <span class="hljs-comment">//调用lock的lock方法 获得锁</span><br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">if</span>(xxx)<br>SynUtil.condition.await();<br><span class="hljs-comment">/*do something tile the condition change*/</span><br>SynUtil.condition.signalAll();<br>&#125;<span class="hljs-keyword">catch</span>&#123;Exception e&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>SynUtil.lock.unlock();<span class="hljs-comment">//释放锁</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程中止"><a href="#线程中止" class="headerlink" title="线程中止"></a>线程中止</h3><p>想要中止某个线程t，则调用t.interrupt();然后在t线程中的循环添加(!Thread.currentThread().isInterrupted()&amp;&amp;xxxx),注意，当t线程可能处于阻塞态或计时等待态时，执行t.interrupt()会抛出异常，因此需要为t的run重载的逻辑部分添加try catch</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程（Daemon Thread）是指程序运行在后台提供服务的线程，此类线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束后，程序结束并终结所有守护线程。反过来讲，只要任何非守护线程还在运行，程序就不会终止。计时器（Timer）线程是典型的守护线程，它的存在就是为其它线程提供计时服务，该线程本身并无明确的终止条件，当主线程结束后，作为守护线程，它会被自动终止。需要注意，绝对不要在守护线程中访问文件或数据库等持久化资源，因为守护线程可以在任意时刻被终止，有可能对持久化资源造成错误的修改。调用setDaemon(true)方法可以将一个线程设置为守护线程。</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>C-S工作模式：</p><p>网络通信需要通信双方来来协调完成，通常我们把主动提出网络通信请求的一方称为客户端，而被动等待其它主机提出请求才作出相应的一方称为服务器端。</p><p>服务器端运行服务程序<strong>循环等待并监听</strong>有无客户端向其提出通信请求，如果有客户端向其提出请求连<br>接，则立刻作出响应，因此服务器端也可以理解成提供服务的一端，而客户端为使用服务器端提供的服务。</p><p>客户端通信流程：</p><p>客户端指的是主动向对方提出连接请求的一端，客户端通信的过程如下</p><ol><li><p>创建Socket套接字</p></li><li><p>通过Socket套接字向服务器端提出连接请求</p></li></ol><blockquote><p>客户端通过调用Socket对象的connect() 方法向服务器端提出请求。</p></blockquote><ol start="3"><li>通过Socket套接字和服务器端建立输入输出流</li></ol><blockquote><p>客户端通过调用Socket对象的getInputStream()和getOutputStream()方法获取输入和输出流。</p></blockquote><ol start="4"><li>按照协议向套接字进行读和写操作</li></ol><blockquote><p>通过第（3）步所获取到的输入输出流，结合输入输出流完成数据的读写操作。</p></blockquote><ol start="5"><li>关闭套接字</li></ol><blockquote><p>通过调用Socket对象的close()方法关闭套接字。</p></blockquote><p>服务端通信流程：</p><ol><li><p>创建套接字ServerSocket</p></li><li><p>使服务器端套接字处于监听状态</p></li></ol><blockquote><p>服务器通过ServerSocket对象的accept() 方法对网络进行监听。</p></blockquote><ol start="3"><li>为套接字创建输入和输出流</li></ol><blockquote><p>监听到客户端的连接请求并实现连接后，通过accept()方法获取到一<br>个Socket对象，再通过其getInputStream()和 getOutputStream()方法获取输入和输出流。</p></blockquote><ol start="4"><li>按照协议向套接字进行读和写操作</li></ol><blockquote><p>通过第(3)步所获取到的输入输出流，结合输入输出流完成数据的读写操作。</p></blockquote><ol start="5"><li>关闭套接字</li></ol><blockquote><p>通过调用ServerSocket对象的close()方法关闭套接字。</p></blockquote><p><img src="/zyq.github.io/./images/media/image4.jpeg">{width&#x3D;”5.729166666666667in”<br>height&#x3D;”3.7083333333333335in”}</p><p>TCP,UDP:</p><p>TCP和UDP是网络体系结构中运输层的两个协议，能够提供两个主机的两个应用进程之间的通信。<br>TCP协议提供面向连接的可靠的数据传输服务，在双方传送数据之前需先建立连接，数据传递结束后需释放连接。TCP不提供广播或多播服务。由于TCP提供可靠的连接服务，会增加开销，因此适合于对双方通信质量要求较高，但实时性不强的场合，比如交互式通信。</p><p>UDP协议提供面向无连接的基于数据报交互的数据传输服务，通信双方在通信前不用建立连接，发送方根据对方的ip等地址信息和要发送的数据，封装成数据包发送给对方，接收方收到数据报后不需要回复。UDP协议虽然不提供可靠的通信服务，但减少了开销，适合于对通信质量要求不很高，但对实时性要求较高的场合，比如网络多媒体传输。</p><p>URL:</p><p>URL(Uniform Resource<br>Locater)是统一资源定位符的简称，能表示网络中资源的位置，这个资源可以是一个文件或目录，也可以是一个数据库。在计算机网络中通过资源的URL地址，则可以对其进行访<br>问。常见的网址就是一个典型的URL。</p><p>URL通常由４个部分构成，常见格式如下： 传输协议：&#x2F;&#x2F;主机名：端口号&#x2F;文件名</p><blockquote><p>通过URL对象的 openStream() 方法只能实现对资源信息的读取，URL对象的openConnection() 方法可以获得一个URLConnection对象，该对象不仅可以从资源中读取数据，还可以向资源中写入数据。</p></blockquote><h2 id="AWT"><a href="#AWT" class="headerlink" title="AWT"></a>AWT</h2><p>主要考察两部分：事件机制 和 布局管理事件机制极有可能出填空题</p><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>概念：</p><p>事件源：触发事件的图形组件，如标签，按钮，文本框等。</p><p>事件：用户对事件源进行的<strong>操作</strong>叫做事件。如单击按钮，文本框中按回车键，双击列表框，选中菜单项等。事件都对应一个事件类的实例。如单击按钮，将产生ActionEvent事件类的对象。</p><p>事件接收：Java为每个事件类定义一个事件监听器接口(implements)，并约定了事件处理方法(override)。</p><p>事件处理：在接收—处理环节，系统一旦监听到事件发生，就把该事件交给对应的事件处理方法(actionPerformed())，进而完成用户的操作目标。</p><p>例如，在某信息系统的登录界面，用户用鼠标单击了按钮button，那么事件源就是button按钮。单击button就会产生ActionEvent事件类的对象，其中包含有该事件的名称、来源等信息。系统把这个事件对象交给对应的方法去处理，该方法就是actionPerformed()，ActionEvent事件类的对象e作为该方法的<br>参数。</p><p><img src="/zyq.github.io/./images/media/image5.jpeg">{width&#x3D;”4.791665573053368in”<br>height&#x3D;”0.8020833333333334in”}<img src="/zyq.github.io/./images/media/image6.jpeg">{width&#x3D;”5.822916666666667in”<br>height&#x3D;”0.7395833333333334in”}</p><p>GUI开发中，事件处理的设计包含以下4步：</p><p>(1) 导入java.awt.event包； <code>import java.awt.*</code></p><p>(2) 实现监听器接口；<code> implements ActionEvent</code></p><p>(3) 将事件源注册给事件的监听者；<code> xxx.addActionListener(this)</code></p><p>(4) 具体实现监听器接口所约定的事件处理方法<code>@override public void actionPerformed(ActionEvent e)&#123;xxx&#125;</code></p><h3 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h3><p>布局管理器用于设置容器中各个组件的位置、大小、排列顺序以及组件间隔等；<br>包含组件的容器发生了位移或改变大小，组件相应变化由它来解决；</p><blockquote><p>它主要有FlowLayout 、 BorderLayout 、 GridLayout 和CardLayout 等类型。</p></blockquote><p><strong>FlowLayout</strong>布局也称作流式布局；它把组件从左到右，一行一行地排列，一行放满后另起一行。若某行组件未放满，则把组件居中放置在该行中间；容纳组件的容器大小发生改变时，FlowLayout布局管理器可以调整组件的相对位置，使得组件排列在一行或多行。</p><p><strong>BorderLayout</strong>中，容器被划分成东、西、南、北和中部5个区域；由常量BorderLayout.EAST、BorderLayout.WEST、BorderLayout.SOUTH、BorderLayout.NORTH和BorderLayout.CENTER表示；容器的每个区域只能添加一个组件。添加后该组件将占满这个区域；东、西、南和北4个区域中若出现哪一个未使用，则该区域归零，并且被中部区域所吞并；</p><p><strong>GridLayout</strong>称作网格布局，它展现为几行几列的网格区域；<br>组件需要被依次放入其中，一个组件要占一格；网格大小完全相同，并且要求组件大小与网格一致；</p><p><strong>CardLayout</strong>布局为选项卡风格； 它将组件处理为若干选项卡；程序一运行，将显示首个选项卡。其余选项卡既可以按照顺序逐一显示，也可以由操作人员指定显示。每个选项卡都有一个标记，点击此标记则显示相应选项卡下的组件。</p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>编程题 重点在于应用</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接具体步骤有：</p><ol><li><p>导入mysql.connector的jar包</p></li><li><p>import java.sql.*</p></li><li><p>三要素 <code>url=(&quot;jdbc:mysql://localhost:3306/xxx&quot;) username password</code></p></li><li><p>反射注册驱动 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></p></li><li><p>由驱动管理器建立连接</p><p><code>Connection con=DriverManager.getConnection(url,username,password);</code></p></li></ol><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p>连接好数据库后：</p><ol><li><p>创建statement对象 Statement s&#x3D;con.createStatement();</p></li><li><p>编写sql语句并用statement对象执行 String sql&#x3D;”xxxx”;s.executeXXX(sql);</p></li><li><p>接收结果：增删改影响行数:int rows&#x3D;s.executeXXX(sql);查询结果集：ResultSet rs&#x3D;s.executeQuery(sql);</p></li><li><p>展示查询结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">while</span>(rs.next())&#123;<br>String resultType1=rs.getString(<span class="hljs-string">&quot;property1&quot;</span>);<br><span class="hljs-type">int</span> resultType2=rs.getInt(<span class="hljs-string">&quot;property2&quot;</span>);<br>sout(resultType1+...+);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关闭资源，当执行完业务后一定要记得关闭资源,关闭一个资源对象后，该资源对象创建的所有资源也将被关闭。因此只需要关闭connection对象：con.close();</p></li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>访问数据库过程中可能产生SQLException异常，因此我们需要处理这些异常，异常处理不当将会造成JDBC对象无法关闭，造成系统资源浪费(用try catch finally编写，finally中关闭资源)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">try</span>&#123;<br>Connection c=DriverManager.getConnection(url,username,password);<br><span class="hljs-keyword">try</span>&#123;<br>Statement s=c.createStatement();<br>ResultSet rs=s.executeQuery(sql);<br>...<br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>c.close();<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span>(Exception e)&#123;<br><span class="hljs-comment">//处理</span><br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>除了查询表中的数据之外，JDBC还提供了表结构信息、数据库信息的功能，这类信息称metadata，<br>即关于数据的数据。例如如数据库中共有多少个表，每个表中共有几个字段，每个字段的名字是什么等等，这些信息都是metadata。</p><p>DatabaseMetaData db &#x3D; con.getMetaData();&#x2F;&#x2F;con是Connection对象</p><p>ResultSetMetaData table &#x3D; rs.getMetaData();&#x2F;&#x2F;rs是ResultSet对象</p><blockquote><p>举例：使用root账号连接位于本机的jdbc数据库，打印显示数据库中全部表结构，接收井执行用户输入的指令。若用户输入select语句 则显示查询结果 若输入update insert delete语句 则打印语句影响的行数 若输入exit 则程序正常结束 若用户输入非法指令 则结束程序并打印显示捕捉到的异常。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> JDBC_Review;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* @author :springbear</span><br><span class="hljs-comment">* @description :</span><br><span class="hljs-comment">    */</span><br><br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">instance</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//三要素</span><br>String url1=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/jdbc_S&quot;</span>;<br>String username=<span class="hljs-string">&quot;root&quot;</span>;<br>String password=<span class="hljs-string">&quot;zyq2004zyq&quot;</span>;<br>        <br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//注册驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">//获取连接</span><br>Connection c= DriverManager.getConnection(url1,username,password);<br>System.out.println(<span class="hljs-string">&quot;db connected&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//获取Statement对象</span><br>Statement s=c.createStatement();<br><span class="hljs-comment">//获取表结构</span><br>DatabaseMetaData databaseMetaData=c.getMetaData(); <span class="hljs-comment">//数据库</span><br>ResultSet tables=<br>databaseMetaData.getTables(<span class="hljs-string">&quot;jdbc_S&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;TABLE&quot;</span>,<span class="hljs-string">&quot;VIEW&quot;</span>&#125;);<span class="hljs-comment">//数据库中的表</span><br>ResultSetMetaData columns=<span class="hljs-literal">null</span>;<span class="hljs-comment">//表中的属性</span><br>ResultSet rs=<span class="hljs-literal">null</span>;<span class="hljs-comment">//接收 *查询语句返回的数据</span><br>String tableName=<span class="hljs-literal">null</span>;<span class="hljs-comment">//表名</span><br>StringBuilder table_mode=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-comment">//输出所有表名 和 对应的属性 并按照规范输出 TABLE(SS,XX,YY);</span><br><span class="hljs-keyword">while</span>(tables.next())&#123;<br>tableName=tables.getString(<span class="hljs-string">&quot;TABLE_NAME&quot;</span>);<br>                rs=s.executeQuery(<span class="hljs-string">&quot;select * from user&quot;</span>);<br>columns=rs.getMetaData();<br>table_mode.append(tableName);<br>table_mode.append(<span class="hljs-string">&quot;(&quot;</span>);<br>table_mode.append(columns.getColumnName(<span class="hljs-number">1</span>));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=columns.getColumnCount();i++)&#123;<br>table_mode.append(<span class="hljs-string">&quot;,&quot;</span>);<br>table_mode.append(columns.getColumnName(i));<br>                &#125;<br>table_mode.append(<span class="hljs-string">&quot;);&quot;</span>);<br>System.out.println(table_mode);<br>table_mode.delete(<span class="hljs-number">0</span>,table_mode.length());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;input sql&quot;</span>);<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>String command=in.nextLine();<br><span class="hljs-keyword">while</span>(command.toLowerCase().equals(<span class="hljs-string">&quot;exit&quot;</span>)==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-type">boolean</span> flag=s.execute(command);<br><span class="hljs-keyword">if</span>(flag==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-type">int</span> n=s.getUpdateCount();<br>System.out.println(<span class="hljs-string">&quot;Effect &quot;</span>+n);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>rs=s.getResultSet();<br>columns=rs.getMetaData();<br><span class="hljs-type">int</span> count=columns.getColumnCount();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=count;++i)<br>System.out.print(columns.getColumnLabel(i)+<span class="hljs-string">&quot;\t&quot;</span>);<br>System.out.println();<br><span class="hljs-keyword">while</span> (rs.next())&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=count;i++)<br>System.out.print(rs.getObject(i)+<span class="hljs-string">&quot;\t\t&quot;</span>);<br>System.out.println();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;next command:&quot;</span>);<br>command= in.nextLine();<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;farewell&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>c.close();<br>&#125;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>使用 PreparedStatement 比使用 Statement 的好处</p><ul><li><p>无须”拼接”SQL语句，编程更简单</p></li><li><p>预编译 SQL 语句，性能更好（MySQL 不支持 PreparedStatement 的性能优化）</p></li><li><p>可以防止 SQL 注入，安全性更好</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String sql=<span class="hljs-string">&quot;select id from user where name=? and password=?&quot;</span>;<br>PreparedStatement ps=con.preparedStatement(sql);<br>ps.setString(<span class="hljs-number">1</span>,name);<br>ps.setString(<span class="hljs-number">2</span>,password);<br>ResultSet rs=ps.exexuteQuery(); <span class="hljs-comment">//executeQuery不需要再绑定sql语句 因为ps本身就由sql语句创建出</span><br></code></pre></td></tr></table></figure><h3 id="增强结果集"><a href="#增强结果集" class="headerlink" title="增强结果集"></a>增强结果集</h3><p>在创建Statement或PreparedStatement对象时，执行相应参数可使结果集获得自由滚动和更新数据库的能力。</p><p>Statement stat &#x3D; conn.createStatement(type, concurrency);</p><p>PreparedStatement stat &#x3D;conn.prepareStatement(command, type, concurrency);<br>type和concurrency参数的取值均是ResultSet类中事先定义好的常量</p><p><img src="/zyq.github.io/./images/media/image7.jpeg">{width&#x3D;”6.174291338582677in”<br>height&#x3D;”3.224374453193351in”}</p><blockquote><p>rs.previous()  &#x2F;&#x2F;向后滚动1条记录</p><p>rs.relative(n) &#x2F;&#x2F;如果n为正整数，则向前滚动n条记录；反之则向后滚动</p><p>rs.absolute(n)  &#x2F;&#x2F;绝对定位到第n条记录</p><p>rs. first()   &#x2F;&#x2F;滚动到第一条记录</p><p>rs.last()    &#x2F;&#x2F;滚动到最后一条记录</p><p>rs. beforeFirst()  &#x2F;&#x2F;滚动到第一条记录之前，不指向任何记录</p><p>rs.afterLast()  &#x2F;&#x2F;滚动到最后一条记录之后，不指向任何记录</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第三行记录的密码改为“hello”</span><br>rs.absolute(<span class="hljs-number">3</span>); <span class="hljs-comment">//绝对定位到第3条记录</span><br>rs.updateString(<span class="hljs-string">&quot;password &quot;</span>, <span class="hljs-string">&quot;hello &quot;</span>); <span class="hljs-comment">//将该记录的password字段更新为“hello”</span><br>rs. updateRow(); <span class="hljs-comment">//提交更新</span><br>...<br><span class="hljs-comment">//插入一条记录(4, lucy, 9527)</span><br>rs. moveToInsertRow(); <span class="hljs-comment">//将游标移动到“插入行”的位置</span><br>rs. updateInt(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//将第一个字段的值设置为4</span><br>rs. updateString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;lucy&quot;</span>); <span class="hljs-comment">//将第二个字段的值设置为“lucy”</span><br>rs. updateString(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;9527&quot;</span>); <span class="hljs-comment">//将第三个字段的值设置为“9527”</span><br>rs.insertRow(); <span class="hljs-comment">//将新纪录插入表中</span><br>rs.moveToCurrentRow();<span class="hljs-comment">//将游标回归到原位置</span><br><span class="hljs-comment">//删除最后一条记录</span><br>rs.last();<br>rs.deleteRow();<br></code></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务(Transaction)是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列成。<br>事务具有原子性、一致性、隔离性、持续性四大特点。若事务顺利执行完毕，则通过commit方法提交。若事务运行的过程中发生了故障，则通过rollback方法回滚，系统将事务中已完成的操作全部撤消，回滚到事务的最初状态。</p><p>在JDBC中，默认情况下事务是自动提交的，即每条SQL语句都单独构成一个事务，执行完毕后立刻提交到数据库。若要将多条语句组成一个事务，必须调用Connection对象的setAutoCommit(false)方法，将自动提交修改为手动提交。事务结束后，调用Connection对象的commit()方法提交到数据库。若事务执行过程中发生故障，则需在处理异常的catch块中调用Connection对象的rollback()方法，回滚到初始状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        conn = DriverManager.getConnection(mysql_url, name, password);<br>        conn.setAutoCommit(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> conn.createStatement();<br>        stat.executeUpdate(command_1); <span class="hljs-comment">//更新语句1</span><br>        stat.executeUpdate(command_2); <span class="hljs-comment">//更新语句2</span><br>        ……<br>        stat.executeUpdate(command_n); <span class="hljs-comment">//更新语句n</span><br>        conn.commit();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        ex.printStackTrace();<br>        <span class="hljs-keyword">try</span> &#123;<br>        conn.rollback();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="行集"><a href="#行集" class="headerlink" title="行集"></a>行集</h3><p>增强的结果集功能已十分完善，但仍有一个严重的缺点，即在整个操作过程中必须一直占用数据库的连接，这使得结果集缺乏足够的灵活性，并且许多操作都在数据库服务器完成，没有充分利用客户机的计算资源。行集(RowSet)继承了ResultSet接口，却又无需一直占用数据库连接。</p><p>RowSet扩展了ResultSet接口，既能使用ResultSet中所有功能，又添加了新功能。默认情况下RowSet<br>对象都是可滚动的和可更新的。</p><p>大部分RowSet是非链接的，可以离线操作数据。</p><p>RowSet接口添加了对 JavaBeans 组件模型的 JDBC API 支持，可作为JavaBeans组件使用在可视化Bean 开发环境中。</p><p>某些RowSet是可以序列化的。</p><p>MySQL官方驱动不含对行集的实现，只能在Sun公司的com.sun.rowset.CachedRowSetImpl提供的参<br>考实现。</p><blockquote><p>CachedRowSet </p><p>WebRowSet</p><p>FilteredRowSet</p><p>JoinRowSet</p><p>JdbcRowSet</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>期末</category>
      
    </categories>
    
    
    <tags>
      
      <tag>期末</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/zyq.github.io/2023/11/19/%E5%89%8D%E7%AB%AF/VueTrick/"/>
    <url>/zyq.github.io/2023/11/19/%E5%89%8D%E7%AB%AF/VueTrick/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h1><h2 id="属性传值"><a href="#属性传值" class="headerlink" title="属性传值"></a>属性传值</h2><ol><li><p>涉及很多属性的传值时：设计对象并使用v-bind。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">const post = &#123;<br>  id: 1,<br>  title: &#x27;My Journey with Vue&#x27;<br>&#125;<br>&lt;BlogPost v-bind=&quot;post&quot; /&gt;<br>//等价于<br>&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;<br></code></pre></td></tr></table></figure></li><li><p>属性默认值：一般类型：default: xxx 数组或对象类型：default(<em>rawProps</em>) {return {message: ‘hello’,xxx:’xxxx’…}}</p><p>如果声明了 <code>default</code> 值，那么在 prop 的值被解析为 <code>undefined</code> 时，无论 prop 是未被传递还是显式指明的 <code>undefined</code>，都会改为 <code>default</code> 值(即default会抹除undefined)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-comment">// 基础类型检查</span><br>  <span class="hljs-comment">// （给出 `null` 和 `undefined` 值则会跳过任何类型检查）</span><br>  <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br>  <span class="hljs-comment">// 多种可能的类型</span><br>  <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>  <span class="hljs-comment">// 必传，且为 String 类型</span><br>  <span class="hljs-attr">propC</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-comment">// Number 类型的默认值</span><br>  <span class="hljs-attr">propD</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>  &#125;,<br>  <span class="hljs-comment">// 对象类型的默认值</span><br>  <span class="hljs-attr">propE</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>    <span class="hljs-comment">// 对象或数组的默认值</span><br>    <span class="hljs-comment">// 必须从一个工厂函数返回。</span><br>    <span class="hljs-comment">// 该函数接收组件所接收到的原始 prop 作为参数。</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params">rawProps</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 自定义类型校验函数</span><br>  <span class="hljs-attr">propF</span>: &#123;<br>    <span class="hljs-title function_">validator</span>(<span class="hljs-params">value</span>) &#123;<br>      <span class="hljs-comment">// The value must match one of these strings</span><br>      <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 函数类型的默认值</span><br>  <span class="hljs-attr">propG</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>,<br>    <span class="hljs-comment">// 不像对象或数组的默认，这不是一个</span><br>    <span class="hljs-comment">// 工厂函数。这会是一个用来作为默认值的函数</span><br>    <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default function&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">propH</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">MyClass</span><span class="hljs-comment">//可以为自定义的类</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>关于Boolean的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">Number</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">String</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被转换为 true</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">Number</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br>  <br><span class="hljs-comment">// disabled 将被解析为空字符串 (disabled=&quot;&quot;)</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">disabled</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Boolean</span>]<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>规范化：子组件不该直接去改prop.attribute 虽然无法通过这种方式更改父组件中的值，因为单项数据流，但是为了规范，实在要去修改传入的值可以通过计算属性，或者定义响应式变量，初值取自该属性值，以后对这个响应式变量做修改即可。特别是对于&#x3D;&#x3D;数组和对象这样的引用类型&#x3D;&#x3D;，子组件是可以更改并影响到父组件的，而且很难以被发现。对于传入的数组或对象属性更要注意！</p></li></ol><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li><p>在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p></li><li><p>事件校验：要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 <code>emit</code> 的内容，返回一个布尔值来表明事件是否合法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>const emit = defineEmits(&#123;<br>  // 没有校验<br>  click: null,<br><br>  // 校验 submit 事件<br>  submit: (&#123; email, password &#125;) =&gt; &#123;<br>    if (email &amp;&amp; password) &#123;<br>      return true<br>    &#125; else &#123;<br>      console.warn(&#x27;Invalid submit event payload!&#x27;)<br>      return false<br>    &#125;<br>  &#125;<br>&#125;)<br><br>function submitForm(email, password) &#123;<br>  emit(&#x27;submit&#x27;, &#123; email, password &#125;)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><ol><li><p>绑定组件：</p></li><li><p>组件内部需要做两件事：</p><ol><li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li><li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- CustomInput.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;modelValue&#x27;])<br>defineEmits([&#x27;update:modelValue&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    :value=&quot;modelValue&quot;<br>    @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>多个v-model：为组件中的不同属性分别绑定，首先要起别名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- MyComponent.vue --&gt;<br>&lt;script setup&gt;<br>defineProps([&#x27;title&#x27;])// 改！<br>defineEmits([&#x27;update:title&#x27;])// 改！<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;title&quot; //绑定别名！<br>    @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;//update这里也改！<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use:<br>&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt; //绑定title即可<br></code></pre></td></tr></table></figure><p>基于此，设置多个别名并绑定即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>defineProps(&#123;<br>  firstName: String,<br>  lastName: String<br>&#125;)<br><br>defineEmits([&#x27;update:firstName&#x27;, &#x27;update:lastName&#x27;])<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;firstName&quot;<br>    @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;lastName&quot;<br>    @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br><br>//when use<br>&lt;UserName<br>  v-model:first-name=&quot;first&quot;<br>  v-model:last-name=&quot;last&quot;<br>/&gt;<br></code></pre></td></tr></table></figure><p>4.自定义修饰：</p></li></ol><h2 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h2><ol><li><p>插槽位于父组件作用域，只能访问父组件中的数据而不能访问子组件中的数据</p></li><li><p>子组件的插槽中&#x2F;<slot>&#x2F;<slot>可以写入数据作为默认值</p></li><li><p>多插槽，为每个插槽起名即可：添加name属性，如不添加则默认名称：default</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">父组件<br>&lt;BaseLayout&gt;<br>  &lt;template v-slot:header&gt;  --&gt;&lt;template #header&gt;具名插槽简写<br>    &lt;!-- header 插槽的内容放这里 --&gt;<br>  &lt;/template&gt;<br>&lt;/BaseLayout&gt;<br>----------------------------------<br>子组件<br>&lt;div class=&quot;container&quot;&gt;<br>  &lt;header&gt;<br>    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;<br>  &lt;/header&gt;<br>  &lt;main&gt;<br>    &lt;slot&gt;&lt;/slot&gt;<br>  &lt;/main&gt;<br>  &lt;footer&gt;<br>    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;<br>  &lt;/footer&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure></li><li><p>默认情况下，如1.所说，但是有时想要实现属性的传递，在slot标签中绑定属性即可，在父组件使用这个子组件时 在子组件标签处绑定V-SLOT&#x3D;‘properties’ 然后再利用 但目前我还没有想到适合的使用场景，感觉关系很混乱，而且实在要实现其实完全可以用其他更规范的方式。</p></li></ol><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ol><li><p>当父组件想子组件传递数据，常常会用到prop，考虑一颗很高的组件树，如果想要父组件为深层的子组件传递某个值，用prop太难了，为了避免逐级透传，使用提供注入的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; ref, provide &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>provide(&#x27;key&#x27;, count) //注入属性key 值为count 响应式<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>应用层能为所有组件&#x3D;&#x3D;提供&#x3D;&#x3D;：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;)<br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-comment">/* 注入名 */</span> <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-comment">/* 值 */</span> <span class="hljs-string">&#x27;hello!&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>为子组件&#x3D;&#x3D;注入&#x3D;&#x3D;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; inject,ref &#125; from &#x27;vue&#x27;<br>const count = ref(0)<br>count = inject(&#x27;count&#x27;,99999)-----99999是默认值，当父组件没有提供属性值时，采用这个<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>原则：<strong>尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>，提高内聚性，易于维护。</p></li><li><p>Symbol:大型的应用，包含非常多的依赖提供，或者编写提供给其他开发者使用的组件库，最好使用 Symbol 来作为注入名以避免潜在的冲突。</p><p>先在一个单独的js文件中导出这些注入名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//in symbols.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectionKey = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-comment">//in provident</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-title function_">provide</span>(myInjectionKey, &#123; <span class="hljs-comment">/*</span><br><span class="hljs-comment">  要提供的数据</span><br><span class="hljs-comment">*/</span> &#125;);<br><span class="hljs-comment">//in injection</span><br><span class="hljs-comment">// 注入方组件</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectionKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./symbols.js&#x27;</span><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(myInjectionKey)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
